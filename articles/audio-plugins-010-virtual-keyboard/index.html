<!DOCTYPE html> <html lang=en> <head> <meta charset=utf-8> <meta http-equiv=X-UA-Compatible content="IE=edge,chrome=1"> <meta name=HandheldFriendly content=True> <meta name=MobileOptimized content=320> <meta name=viewport content="width=device-width"> <meta http-equiv=cleartype content=on> <meta property="fb:admins" content=100001493355877> <meta property="og:image" content="http://www.martin-finke.de/blog/img/making_audio_plugins_thumbnail.png"> <meta property="og:image:type" content="image/png"> <meta property="og:image:width" content=100> <meta property="og:image:height" content=100> <title>Making Audio Plugins Part 10: Virtual Keyboard - Martin Finke's Blog </title> <link rel=alternate href="/blog/feed.xml" type="application/rss+xml" title="Music &amp; Programming"> <link href="http://fonts.googleapis.com/css?family=Domine:700|Inconsolata:400,700" rel=stylesheet type="text/css"> <link rel=stylesheet href='/blog/css/4407aa6.css'> </head> <body class=article-detail> <header class=header> <div class=content-wrap> <h1>Making Audio Plugins Part 10: Virtual Keyboard</h1> <div class=taglinks><a href="/blog/tags/programming.html" class=taglink>Programming</a>, <a href="/blog/tags/making_audio_plugins.html" class=taglink>Making Audio Plugins</a> </div> </div> </header> <div id=content> <div class=content-wrap> <article class=article> <section class=content><p><span class=caps>REAPER</span>’s virtual keyboard is a little laborious to set up, and your customers may not always have a host with such functionality. Let’s add a little on-screen keyboard to our plugin’s <span class=caps>GUI</span>. <span class=more></span></p> <h2 id=the-gui-element>The <span class=caps>GUI</span>&nbsp;Element</h2> <p>In <span class=caps>WDL</span>-<span class=caps>OL</span>, <span class=caps>GUI</span> elements are called <em>controls</em>. <span class=caps>WDL</span>-<span class=caps>OL</span> comes with an <code>IKeyboardControl</code> which has all the functionality we need. It uses a background graphic and two sprites: One is a pressed black key, the other contains several pressed white keys. The reason for this is that all black keys have the same shape, but the white keys have different shapes. Initially, only the background will be visible. When a key is played, the <em>pressed</em> key graphic will be overlaid on top at the appropriate position.<br>If you are interested in creating a beautiful piano graphic yourself, check out <a href="http://naldzgraphics.net/tutorials/piano-app-ui-in-photoshop/">this tutorial</a>. Anyway, here are the three files that come with&nbsp;<span class=caps>WDL</span>-<span class=caps>OL</span>:</p> <p><div style="text-align: center;">Background:</div> <a href="/blog/articles/audio-plugins-010-virtual-keyboard/bg.png"><img src="/blog/articles/audio-plugins-010-virtual-keyboard/bg.png" alt=""></a></p> <p><div style="text-align: center;">Pressed black key:</div> <a href="/blog/articles/audio-plugins-010-virtual-keyboard/blackkey.png"><img src="/blog/articles/audio-plugins-010-virtual-keyboard/blackkey.png" alt=""></a></p> <p><div style="text-align: center;">Pressed white keys:</div> <a href="/blog/articles/audio-plugins-010-virtual-keyboard/whitekey.png"><img src="/blog/articles/audio-plugins-010-virtual-keyboard/whitekey.png" alt=""></a></p> <p>Download all three, put them in your project’s <em>/resources/img/</em> folder. Then drag them into Xcode to add them to the project. As usual with graphics, we’ll first add the filename to <em>resource.h</em>. While you’re there, remove the <em>knob.png</em> and <em>background.png</em> references and remove the two files from your&nbsp;project.</p> <pre><code class="lang-cpp"><span class="comment">// Unique IDs for each image resource.</span>
<span class="preprocessor">#define BG_ID         101</span>
<span class="preprocessor">#define WHITE_KEY_ID  102</span>
<span class="preprocessor">#define BLACK_KEY_ID  103</span>

<span class="comment">// Image resource locations for this plug.</span>
<span class="preprocessor">#define BG_FN         "resources/img/bg.png"</span>
<span class="preprocessor">#define WHITE_KEY_FN  "resources/img/whitekey.png"</span>
<span class="preprocessor">#define BLACK_KEY_FN  "resources/img/blackkey.png"</span>
</code></pre> <p>Also change the <span class=caps>GUI</span>&nbsp;size:</p> <pre><code class="lang-cpp"><span class="comment">// <span class="caps">GUI</span> default dimensions</span>
<span class="preprocessor">#define GUI_WIDTH 434</span>
<span class="preprocessor">#define GUI_HEIGHT 66</span>
</code></pre> <p>To have the png files included in windows builds, edit <em>Synthesis.rc</em> and modify the beginning to&nbsp;this:</p> <pre><code class="lang-cpp"><span class="preprocessor">#include "resource.h"</span>

BG_ID       <span class="caps">PNG</span> BG_FN
WHITE_KEY_ID       <span class="caps">PNG</span> WHITE_KEY_FN
BLACK_KEY_ID       <span class="caps">PNG</span> BLACK_KEY_FN
</code></pre> <p>Now add some public members to the <code>Synthesis</code> class (in <em>Synthesis.h</em>):</p> <pre><code class="lang-cpp"><span class="keyword">public</span>:
    <span class="comment">// ...</span>

    <span class="comment">// Needed for the <span class="caps">GUI</span> keyboard:</span>
    <span class="comment">// Should return non-zero if one or more keys are playing.</span>
    <span class="keyword">inline</span> <span class="keyword">int</span> GetNumKeys() <span class="keyword">const</span> { <span class="keyword">return</span> mMIDIReceiver.getNumKeys(); };
    <span class="comment">// Should return true if the specified key is playing.</span>
    <span class="keyword">inline</span> <span class="keyword">bool</span> GetKeyStatus(<span class="keyword">int</span> key) <span class="keyword">const</span> { <span class="keyword">return</span> mMIDIReceiver.getKeyStatus(key); };
    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> virtualKeyboardMinimumNoteNumber = <span class="number">48</span>;
    <span class="keyword">int</span> lastVirtualKeyboardNoteNumber;
</code></pre> <p>Initialize <code>lastVirtualKeyboardNoteNumber</code> in the initializer list (in <em>Synthesis.cpp</em>):</p> <pre><code class="lang-cpp">Synthesis::Synthesis(IPlugInstanceInfo instanceInfo)
    :   IPLUG_CTOR(kNumParams, kNumPrograms, instanceInfo),
    lastVirtualKeyboardNoteNumber(virtualKeyboardMinimumNoteNumber - <span class="number">1</span>) {
    <span class="comment">// ...</span>
}
</code></pre> <p>When <span class=caps>MIDI</span> notes are played from the host, they should be visible as pressed keys on our virtual keyboard. The virtual keyboard will call <code>getNumKeys</code> and <code>getKeyStatus</code> to find out which keys are currently being pressed. We have already implemented these functions on the <code>MIDIReceiver</code>, so we’re just passing it on.<br>The <code>private</code> section needs two&nbsp;additions:</p> <pre><code class="lang-cpp">IControl* mVirtualKeyboard;
<span class="keyword">void</span> processVirtualKeyboard();
</code></pre> <p>The <code>IControl</code> class is the base class of all the <span class=caps>GUI</span> controls. We can’t declare an instance of <code>IKeyboardControl</code> here because it isn’t known in header files. For that reason, we have to use a pointer. <em>IKeyboardControl.h</em> has some comments saying that you <em>“should include this header file after your plug-in class has already been declared, so it is propbably best to include it in your plug-in’s main .cpp file”</em>.<br>To make this a little more clear, let’s go into <em>Synthesis.cpp</em>. Add <code>#include &quot;IKeyboardControl.h&quot;</code> right before you <code>#include resource.h</code>. Now modify the constructor as&nbsp;follows:</p> <pre><code class="lang-cpp">Synthesis::Synthesis(IPlugInstanceInfo instanceInfo)
    :   IPLUG_CTOR(kNumParams, kNumPrograms, instanceInfo),
    lastVirtualKeyboardNoteNumber(virtualKeyboardMinimumNoteNumber - <span class="number">1</span>) {
    <span class="caps">TRACE</span>;

    IGraphics* pGraphics = MakeGraphics(<span class="keyword">this</span>, kWidth, kHeight);
    pGraphics-&gt;AttachBackground(BG_ID, BG_FN);

    IBitmap whiteKeyImage = pGraphics-&gt;LoadIBitmap(WHITE_KEY_ID, WHITE_KEY_FN, <span class="number">6</span>);
    IBitmap blackKeyImage = pGraphics-&gt;LoadIBitmap(BLACK_KEY_ID, BLACK_KEY_FN);

    <span class="comment">//                            C#     D#          F#      G#      A#</span>
    <span class="keyword">int</span> keyCoordinates[<span class="number">12</span>] = { <span class="number">0</span>, <span class="number">7</span>, <span class="number">12</span>, <span class="number">20</span>, <span class="number">24</span>, <span class="number">36</span>, <span class="number">43</span>, <span class="number">48</span>, <span class="number">56</span>, <span class="number">60</span>, <span class="number">69</span>, <span class="number">72</span> };
    mVirtualKeyboard = <span class="keyword">new</span> IKeyboardControl(<span class="keyword">this</span>, kKeybX, kKeybY, virtualKeyboardMinimumNoteNumber, <span class="comment">/* octaves: */</span> <span class="number">5</span>, &amp;whiteKeyImage, &amp;blackKeyImage, keyCoordinates);

    pGraphics-&gt;AttachControl(mVirtualKeyboard);

    AttachGraphics(pGraphics);

    CreatePresets();
}
</code></pre> <p>The interesting part begins after we have attached the background graphic. First we load the pressed black/white keys as <code>IBitmap</code>s. The second argument (<code>6</code>) to <code>LoadIBitmap</code> tells the graphics system that <em>whitekeys.png</em> contains six frames: <a name=virtual_keyboard_white_key_frames></a></p> <blockquote><q>By default pRegularKeys should contain 6 bitmaps (C/F, D, E/B, G, A, high C), while pSharpKey should only contain 1 bitmap (for all flat/sharp keys).</q><footer>IKeyboardControl.h</footer></blockquote> <p>The <code>keyCoordinates</code> array tells the system how far each key is offset from the left. Note that you only have to do this for one octave; <code>IKeyboardControl</code> will infer the coordinates for all other octaves.<br>On the next line, we assign a <code>new IKeyboardControl</code> to <code>mVirtualKeyboard</code>. We pass a lot of&nbsp;information:</p> <ul> <li>A pointer to our plugin instance. This is an example of the <a href="http://en.wikipedia.org/wiki/Delegation_pattern">delegate pattern</a>: The virtual keyboard will call <code>GetNumKeys</code> and <code>GetKeyStatus</code> on <code>this</code>.</li> <li>The keyboard’s X and Y coordinates on the&nbsp;<span class=caps>GUI</span>.</li> <li>The lowest note number. When you click the leftmost key, this note will be&nbsp;played.</li> <li>The number of&nbsp;octaves</li> <li>The addresses of our two <em>pressed key</em> images</li> <li>The X coordinate of each key in one&nbsp;octave</li> </ul> <p>Interestingly, the virtual keyboard knows nothing about <em>bg.png</em>. It doesn’t need it! This is good because the keyboard may be part of one big background bitmap and it would be annoying to cut out the keyboard part just to pass it to the <code>IKeyboardControl</code> constructor. It just acts when keys are&nbsp;pressed.</p> <p>If you have some C++ experience, writing <code>new</code> in the constructor may (and should) urge you to put <code>delete mVirtualKeyboard</code> in the destructor. If you do that and <em>unload</em> your plugin (i.e. remove it from a track), you’ll get a runtime exception. The reason is that when you&nbsp;call:</p> <pre><code class="lang-cpp">pGraphics-&gt;AttachControl(mVirtualKeyboard);
</code></pre> <p>You’re passing ownership to the graphics system. This means that the memory management is no longer your responsibility, and using <code>delete</code> will try to deallocate memory that has already been deallocated.<br>Now empty the <code>CreatePresets</code> function:</p> <pre><code class="lang-cpp"><span class="keyword">void</span> Synthesis::CreatePresets() {
}
</code></pre> <p>And add <code>kKeybX</code> and <code>kKeybY</code> to <code>ELayout</code>:</p> <pre><code class="lang-cpp"><span class="keyword">enum</span> ELayout
{
    kWidth = GUI_WIDTH,
    kHeight = GUI_HEIGHT,
    kKeybX = <span class="number">1</span>,
    kKeybY = <span class="number">0</span>
};
</code></pre> <p>For performance reasons, the <code>IKeyboardControl</code> doesn’t redraw itself just by itself. A common pattern in graphics programming is to mark a <span class=caps>GUI</span> component as <em>dirty</em>, which means that it will be redrawn on the next paint cycle. If you look in <em>IKeyboardControl.h</em>, particularly <code>OnMouseDown</code> and <code>OnMouseUp</code>, you’ll see that <code>mKey</code> is set to some value and <code>SetDirty</code> is called (as opposed to <code>Draw</code>). <code>SetDirty</code> is an <code>IControl</code> member function (found in <em>IControl.cpp</em>) that sets the control’s <code>mDirty</code> member to <code>true</code>. On every paint cycle, the graphics system repaints all controls whose <code>mDirty</code> is <code>true</code>. I’m going into such detail here because this is an important aspect of how the graphics system&nbsp;works.</p> <h2 id=reacting-to-external-midi>Reacting to External&nbsp;<span class=caps>MIDI</span></h2> <p>Until now, the keyboard marks itself dirty only when it’s clicked. It gets the status of pressed keys from the <code>mMIDIReceiver</code>, but it has to be informed when external <span class=caps>MIDI</span> is received. <code>mVirtualKeyboard</code> and <code>mMIDIReceiver</code> know nothing about each other, so we’ll modify <code>ProcessMidiMsg</code> (in <em>Synthesis.cpp</em>):</p> <pre><code class="lang-cpp"><span class="keyword">void</span> Synthesis::ProcessMidiMsg(IMidiMsg* pMsg) {
    mMIDIReceiver.onMessageReceived(pMsg);
    mVirtualKeyboard-&gt;SetDirty();
}
</code></pre> <p>First, <code>mMIDIReceiver</code> can update its <code>mLast...</code> members according to the received <span class=caps>MIDI</span> data. Then, <code>mVirtualKeyboard</code> is marked as dirty. So on the next paint cycle, the renderer will call <code>Draw</code> on <code>mVirtualKeyboard</code>, which will call <code>GetNumKeys</code> and <code>GetKeyStatus</code>. This may sound a little indirect at first, but it’s a clean design that keeps components separate and avoids redundant work.<br>Our virtual keyboard now reacts to external <span class=caps>MIDI</span> input and shows the appropriate keys as being&nbsp;pressed.</p> <h2 id=reacting-to-virtual-key-presses>Reacting to Virtual Key&nbsp;Presses</h2> <p>The last part that’s missing is the opposite direction: Reacting to clicks on the virtual keyboard, generating <span class=caps>MIDI</span> messages and passing them to <code>mMIDIReceiver</code>.<br>Add the following call to <code>ProcessDoubleReplacing</code>, right before the <code>for</code> loop:</p> <pre><code class="lang-cpp">processVirtualKeyboard();
</code></pre> <p>And implement the&nbsp;function:</p> <pre><code class="lang-cpp"><span class="keyword">void</span> Synthesis::processVirtualKeyboard() {
    IKeyboardControl* virtualKeyboard = (IKeyboardControl*) mVirtualKeyboard;
    <span class="keyword">int</span> virtualKeyboardNoteNumber = virtualKeyboard-&gt;GetKey() + virtualKeyboardMinimumNoteNumber;

    <span class="keyword">if</span>(lastVirtualKeyboardNoteNumber &gt;= virtualKeyboardMinimumNoteNumber &amp;&amp; virtualKeyboardNoteNumber != lastVirtualKeyboardNoteNumber) {
        <span class="comment">// The note number has changed from a valid key to something else (valid key or nothing). Release the valid key:</span>
        IMidiMsg midiMessage;
        midiMessage.MakeNoteOffMsg(lastVirtualKeyboardNoteNumber, <span class="number">0</span>);
        mMIDIReceiver.onMessageReceived(&amp;midiMessage);
    }

    <span class="keyword">if</span> (virtualKeyboardNoteNumber &gt;= virtualKeyboardMinimumNoteNumber &amp;&amp; virtualKeyboardNoteNumber != lastVirtualKeyboardNoteNumber) {
        <span class="comment">// A valid key is pressed that wasn't pressed the previous call. Send a "note on" message to the <span class="caps">MIDI</span> receiver:</span>
        IMidiMsg midiMessage;
        midiMessage.MakeNoteOnMsg(virtualKeyboardNoteNumber, virtualKeyboard-&gt;GetVelocity(), <span class="number">0</span>);
        mMIDIReceiver.onMessageReceived(&amp;midiMessage);
    }

    lastVirtualKeyboardNoteNumber = virtualKeyboardNoteNumber;
}
</code></pre> <p>After a cast, we get the pressed key’s <span class=caps>MIDI</span> note number using <code>GetKey</code>. <code>IKeyboardControl</code> doesn’t support multi-touch, so only one key can be clicked at once. The first <code>if</code> statement releases a key that is no longer clicked (if any). Since this function is called every <code>mBlockSize</code> samples, the second <code>if</code> ensures that clicking a key will only generate one <em>note on</em> message for a given click, and not one every <code>mBlockSize</code> samples. We’re remembering the <code>lastVirtualKeyboardNoteNumber</code> to avoid this kind of “re-triggering” on every&nbsp;call.</p> <h2 id=showtime->Showtime!</h2> <p>We’re ready to run our plugin again! You should be able to play notes using the plugin’s virtual keyboard. Using <span class=caps>REAPER</span>’s virtual keyboard (or any other <span class=caps>MIDI</span> input) should make the plugin’s <span class=caps>GUI</span> show the appropriate key<em>s</em> (plural) as being pressed. You will only hear a tone for the last-pressed key, though. We will address polyphony in a later&nbsp;post.</p> <p>We can play our favourite Beethoven with the sound of classic analogue waveforms! But the sound is a little “static” and you can hear click sounds when you press and release a key (especially using the sine waveform). So the next thing to do is to <a href="/blog/articles/audio-plugins-011-envelopes/">add envelopes</a>. You can download the current source files <a href="/blog/articles/audio-plugins-010-virtual-keyboard/source.zip">here</a>.</p> </section> </article> <div id=donation_prompt>If you found this useful, please feel free to <form action="https://www.paypal.com/cgi-bin/webscr" method=post target=_top class=donation-form> <input type=hidden name=cmd value=_s-xclick> <input type=hidden name=hosted_button_id value=JQDU8W5PJBWL6> <input type=hidden name=ref value="/blog/articles/audio-plugins-010-virtual-keyboard/"> <input type=image src="https://www.paypalobjects.com/en_US/i/btn/btn_donate_SM.gif" border=0 name=submit alt="PayPal - The safer, easier way to pay online!"><img alt="" border=0 src="https://www.paypalobjects.com/de_DE/i/scr/pixel.gif" width=1 height=1> </form>! </div> <iframe src="//www.facebook.com/plugins/like.php?href=http%3A%2F%2Fwww.martin-finke.de%2Fblog%2F&amp;width=450&amp;height=21&amp;colorscheme=light&amp;layout=button_count&amp;action=like&amp;show_faces=false&amp;send=false" scrolling=no frameborder=0 style="border: none; overflow: hidden; width: 200px; height: 21px;" allowtransparency=true></iframe> <div class=comments> <div id=disqus_thread></div> <script type="text/javascript">var disqus_shortname="martinfinke";(function(){var a=document.createElement("script");a.type="text/javascript";a.async=true;a.src="//"+disqus_shortname+".disqus.com/embed.js";(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(a)})();</script> <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript> <a href="http://disqus.com" class=dsq-brlink>comments powered by <span class=logo-disqus>| Disqus</span></a> </div> </div> </div> <footer> <div class=content-wrap> <div class=nav><a href="/blog/">« Index</a></div> <section class=copy> <p>&copy; 2015 Martin Finke – <a href="/blog/impressum.html" class=impressum-link>Impressum</a></p> </section> </div> </footer> <script src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script> <script>window.jQuery||document.write('<script src="/blog/js/vendor/jquery-1.10.2.min.js"><\/script>');</script> <script type="text/javascript">$(document).ready(function(){$('a:link[href^=http]:not([href*="martin-finke.de"])').attr("target","_blank")});</script> <script type="text/javascript">var _gaq=_gaq||[];_gaq.push(["_setAccount","UA-43375106-1"]);_gaq.push(["_trackPageview"]);(function(){var b=document.createElement("script");b.type="text/javascript";b.async=true;b.src=("https:"==document.location.protocol?"https://":"http://")+"stats.g.doubleclick.net/dc.js";var a=document.getElementsByTagName("script")[0];a.parentNode.insertBefore(b,a)})();</script> </body> </html>