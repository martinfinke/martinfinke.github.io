<!DOCTYPE html> <html lang=en> <head> <meta charset=utf-8> <meta http-equiv=X-UA-Compatible content="IE=edge,chrome=1"> <meta name=HandheldFriendly content=True> <meta name=MobileOptimized content=320> <meta name=viewport content="width=device-width"> <meta http-equiv=cleartype content=on> <meta property="fb:admins" content=100001493355877> <meta property="og:image" content="http://www.martin-finke.de/img/making_audio_plugins_thumbnail.png"> <meta property="og:image:type" content="image/png"> <meta property="og:image:width" content=100> <meta property="og:image:height" content=100> <title>Making Audio Plugins Part 16: Polyphony Part I - Martin Finke's Blog </title> <link rel=alternate href="/feed.xml" type="application/rss+xml" title="Music &amp; Programming"> <link href="http://fonts.googleapis.com/css?family=Domine:700|Inconsolata:400,700" rel=stylesheet type="text/css"> <link rel=stylesheet href='/css/4407aa6.css'> </head> <body class=article-detail> <header class=header> <div class=content-wrap> <h1>Making Audio Plugins Part 16: Polyphony Part I</h1> <div class=taglinks><a href="/tags/programming.html" class=taglink>Programming</a>, <a href="/tags/dsp.html" class=taglink>DSP</a>, <a href="/tags/making_audio_plugins.html" class=taglink>Making Audio Plugins</a> </div> </div> </header> <div id=content> <div class=content-wrap> <article class=article> <section class=content><p>Let’s create a polyphonic synthesizer from the components we already have! <span class=more></span></p> <p>In the <a href="/articles/audio-plugins-015-redesign/">last post</a> we have created our plugin’s parameters and the <span class=caps>UI</span>. Now we’ll build the underlying audio processing, but in a <a href="http://en.wikipedia.org/wiki/Polyphony_and_monophony_in_instruments">polyphonic</a> way! That means that we’ll be able to play up to 64 notes at the same time! This will change our plugin’s structure fundamentally, but we’ll be able to reuse the <code>Oscillator</code>, <code>EnvelopeGenerator</code>, <code>MIDIReceiver</code> and <code>Filter</code> classes we already&nbsp;have.</p> <p>In this post, we’ll create a <code>Voice</code> class that represents one playing note. We’ll then create a <code>VoiceManager</code> class that will make sure <code>Voice</code>s are being started whenever a note is pressed.<br>In the <a href="/articles/audio-plugins-017-polyphony-ii/">following post</a>, we’ll clean up code that’s not needed anymore, add pitch modulation, and make the <span class=caps>GUI</span> controls work. It sounds like quite a bit of work, but we’ve already got most of the components we need, and in the end we’ll have a polyphonic subtractive&nbsp;synthesizer!</p> <h2 id=what-goes-where->What goes&nbsp;where?</h2> <p>Let’s think for a brief moment about which parts of our plugin are global, and which parts are separate for each played note. Imagine you’re playing a few notes on your keyboard. Whenever you hit a note, you hear a tone that decays and maybe changes its filter cutoff over time using a filter envelope. When you hit another note while the last note is still playing, you hear another tone with decay and changing filter cutoff, but the previous tone is not affected! It keeps going <em>as if it is alone</em>. So each voice is independent with its own volume <span class=amp>&amp;</span> filter envelopes.<br>The <span class=caps>LFO</span> is global to our plugin. There’s just one that keeps running on and on, and it can’t be re-triggered at the start of a note.<br>So what about the filter? Obviously the filter’s <code>cutoff</code> and <code>resonance</code> are both global, because all voices listen to the same cutoff/resonance knob in our <span class=caps>GUI</span>. But the filter’s cutoff frequency is modulated by the filter envelope, so at any given time the <em>calculated cutoff</em> is different for each voice. If you have a brief look at the <code>Filter::cutoff</code> member function, you can see that it calls <code>getCalculatedCutoff</code>. So we need one <code>Filter</code> per <code>Voice</code>.<br>But can we create two global <code>Oscillator</code>s and share them across all voices? Each <code>Voice</code> can play a different note, i.e. a different frequency. So these have to be independent as&nbsp;well.</p> <p>In short, this will be our&nbsp;hierarchy:</p> <ul> <li>Our plugin has one <code>MIDIReceiver</code> and one <code>VoiceManager</code>.</li> <li>The <code>VoiceManager</code> has one <span class=caps>LFO</span> (which is an <code>Oscillator</code>) and many <code>Voice</code>s.</li> <li>A <code>Voice</code> has two <code>Oscillator</code>s, <em>two</em> <code>EnvelopeGenerator</code>s (for volume and filter) and one <code>Filter</code>.</li> </ul> <h2 id=the-voice-class>The <code>Voice</code> class</h2> <p>In the <em>SpaceBass</em> Xcode project, create a new C++ class and name it <em>Voice</em>. As always, make sure you add it to all targets. Open <em>Voice.h</em> and include our&nbsp;components:</p> <pre><code class="lang-cpp"><span class="preprocessor">#include "Oscillator.h"</span>
<span class="preprocessor">#include "EnvelopeGenerator.h"</span>
<span class="preprocessor">#include "Filter.h"</span>
</code></pre> <p>Inside the <code>class</code>, let’s begin with the <code>private</code> section:</p> <pre><code class="lang-cpp"><span class="keyword">private</span>:
    Oscillator mOscillatorOne;
    Oscillator mOscillatorTwo;
    EnvelopeGenerator mVolumeEnvelope;
    EnvelopeGenerator mFilterEnvelope;
    Filter mFilter;
</code></pre> <p>That’s pretty straightforward, right? Each voice has two oscillators, a volume envelope, a filter envelope and a filter.<br>Each voice is triggered with a certain <span class=caps>MIDI</span> note number and a velocity. Add these two (to <code>private</code>):</p> <pre><code class="lang-cpp">    <span class="keyword">int</span> mNoteNumber;
    <span class="keyword">int</span> mVelocity;
</code></pre> <p>Each of the following variables describes how much a parameter is&nbsp;modulated:</p> <pre><code class="lang-cpp">    <span class="keyword">double</span> mFilterEnvelopeAmount;
    <span class="keyword">double</span> mOscillatorMix;
    <span class="keyword">double</span> mFilterLFOAmount;
    <span class="keyword">double</span> mOscillatorOnePitchAmount;
    <span class="keyword">double</span> mOscillatorTwoPitchAmount;
    <span class="keyword">double</span> mLFOValue;
</code></pre> <p>All of these properties except for <code>mLFOValue</code> represent the knob values in our <span class=caps>GUI</span>. Actually they are always the same for all voices, but we’re not putting them globally in our plugin class. The reason is that each voice needs access to them on every sample, and the <code>Voice</code> class doesn’t even know our plugin class (there’s no <code>#include &quot;SpaceBass.h&quot;</code>). So it would be quite tedious to give this kind of access.<br>There’s one more value. Do you remember how <a href="/articles/audio-plugins-009-receiving-midi/#adding_isMuted_property">we added a <code>isMuted</code> property</a> to the <code>Oscillator</code> class? We’ll move this to <code>Voice</code> level, so whenever a voice isn’t active, it’s not processing anything (this includes its envelopes and filter). Add this&nbsp;line:</p> <pre><code class="lang-cpp">    <span class="keyword">bool</span> isActive;
</code></pre> <p>Now let’s add the <code>public</code> section <em>above</em> the <code>private</code> section. We’ll start with the constructor: <a name=connect_set_free></a></p> <pre><code class="lang-cpp"><span class="keyword">public</span>:
    Voice()
    : mNoteNumber(-<span class="number">1</span>),
    mVelocity(<span class="number">0</span>),
    mFilterEnvelopeAmount(<span class="number">0.0</span>),
    mFilterLFOAmount(<span class="number">0.0</span>),
    mOscillatorOnePitchAmount(<span class="number">0.0</span>),
    mOscillatorTwoPitchAmount(<span class="number">0.0</span>),
    mOscillatorMix(<span class="number">0.5</span>),
    mLFOValue(<span class="number">0.0</span>),
    isActive(<span class="keyword">false</span>) {
        <span class="comment">// Set myself free everytime my volume envelope has fully faded out of <span class="caps">RELEASE</span> stage:</span>
        mVolumeEnvelope.finishedEnvelopeCycle.Connect(<span class="keyword">this</span>, &amp;Voice::setFree);
    };
</code></pre> <p>This initializes the member variables to sensible defaults. Note that a <code>Voice</code> is not active by default. Also, by using the <code>EnvelopeGenerator</code>‘s <a href="/articles/audio-plugins-011-envelopes/#signals_slots">Signal <span class=amp>&amp;</span> Slot</a> mechanism, we set a voice <em>free</em> whenever the volume envelope goes out of release stage.<br>Let’s add setters for the members. Add the following to the <code>public</code> section:</p> <pre><code class="lang-cpp">    <span class="keyword">inline</span> <span class="keyword">void</span> setFilterEnvelopeAmount(<span class="keyword">double</span> amount) { mFilterEnvelopeAmount = amount; }
    <span class="keyword">inline</span> <span class="keyword">void</span> setFilterLFOAmount(<span class="keyword">double</span> amount) { mFilterLFOAmount = amount; }
    <span class="keyword">inline</span> <span class="keyword">void</span> setOscillatorOnePitchAmount(<span class="keyword">double</span> amount) { mOscillatorOnePitchAmount = amount; }
    <span class="keyword">inline</span> <span class="keyword">void</span> setOscillatorTwoPitchAmount(<span class="keyword">double</span> amount) { mOscillatorTwoPitchAmount = amount; }
    <span class="keyword">inline</span> <span class="keyword">void</span> setOscillatorMix(<span class="keyword">double</span> mix) { mOscillatorMix = mix; }
    <span class="keyword">inline</span> <span class="keyword">void</span> setLFOValue(<span class="keyword">double</span> value) { mLFOValue = value; }

    <span class="keyword">inline</span> <span class="keyword">void</span> setNoteNumber(<span class="keyword">int</span> noteNumber) {
        mNoteNumber = noteNumber;
        <span class="keyword">double</span> frequency = <span class="number">440.0</span> * <span class="built_in">pow</span>(<span class="number">2.0</span>, (mNoteNumber - <span class="number">69.0</span>) / <span class="number">12.0</span>);
        mOscillatorOne.setFrequency(frequency);
        mOscillatorTwo.setFrequency(frequency);
    }
</code></pre> <p>The only interesting part here is <code>setNoteNumber</code>. It calculates the frequency for the given note (it’s the same formula we used before) and passes it to both oscillators. Below that, add&nbsp;this:</p> <pre><code class="lang-cpp">    <span class="keyword">double</span> nextSample();
    <span class="keyword">void</span> setFree();
</code></pre> <p>Just like <code>Oscillator::nextSample</code> gives us the output of an <code>Oscillator</code>, <code>Voice::nextSample</code> gives us <em>the total output of a voice</em>, after volume envelope and filtering. Let’s implement it (in <em>Voice.cpp</em>):</p> <pre><code class="lang-cpp"><span class="keyword">double</span> Voice::nextSample() {
    <span class="keyword">if</span> (!isActive) <span class="keyword">return</span> <span class="number">0.0</span>;

    <span class="keyword">double</span> oscillatorOneOutput = mOscillatorOne.nextSample();
    <span class="keyword">double</span> oscillatorTwoOutput = mOscillatorTwo.nextSample();
    <span class="keyword">double</span> oscillatorSum = ((<span class="number">1</span> - mOscillatorMix) * oscillatorOneOutput) + (mOscillatorMix * oscillatorTwoOutput);

    <span class="keyword">double</span> volumeEnvelopeValue = mVolumeEnvelope.nextSample();
    <span class="keyword">double</span> filterEnvelopeValue = mFilterEnvelope.nextSample();

    mFilter.setCutoffMod(filterEnvelopeValue * mFilterEnvelopeAmount + mLFOValue * mFilterLFOAmount);

    <span class="keyword">return</span> mFilter.process(oscillatorSum * volumeEnvelopeValue * mVelocity / <span class="number">127.0</span>);
}
</code></pre> <p>The first line ensures that a voice doesn’t calculate anything while it’s not active. It just returns a muted output. The following three lines get the <code>nextSample</code> from both oscillators and sum them together according to <code>mOscillatorMix</code>. When <code>mOscillatorMix</code> is <code>0</code>, only <code>oscillatorOneOutput</code> can be heard. When it’s <code>1</code>, we only hear <code>oscillatorTwoOutput</code>. At <code>0.5</code>, both oscillators are equally loud.<br>After that, we get the <code>nextSample</code> from both envelopes. We then apply the <code>filterEnvelopeValue</code> to the filter cutoff, but we also take the current <span class=caps>LFO</span> value into account. So the cutoff modulation is the sum of the filter envelope output and the <span class=caps>LFO</span> output.<br>The pitch modulation for both oscillators is just the <span class=caps>LFO</span> output multiplied by the pitch modulation amount. We’ll implement that in a bit.<br>The last line is quite interesting, let’s start inside the parentheses: We take the sum of our two oscillators, apply the volume envelope and velocity, and send the result through <code>mFilter.process</code>. This gets us the filtered output, which we&nbsp;return.</p> <p>The implementation of <code>setFree</code> is pretty&nbsp;simple:</p> <pre><code class="lang-cpp"><span class="keyword">void</span> Voice::setFree() {
    isActive = <span class="keyword">false</span>;
}
</code></pre> <p>As you can see, this is just used to return a voice to inactive state. As described <a href="/articles/audio-plugins-016-polyphony/#connect_set_free">above</a>, this will be called whenever a voice’s <code>mVolumeEnvelope</code> has fully faded&nbsp;out.</p> <h2 id=the-voicemanager->The <code>VoiceManager</code></h2> <p>Let’s implement a class for managing voices! Create a new class named <em>VoiceManager</em>. In the header, start with this&nbsp;code:</p> <pre><code class="lang-cpp"><span class="preprocessor">#include "Voice.h"</span>

<span class="keyword">class</span> VoiceManager {
};
</code></pre> <p>Add the following <code>private</code> members:</p> <pre><code class="lang-cpp"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> NumberOfVoices = <span class="number">64</span>;
Voice voices[NumberOfVoices];
Oscillator mLFO;
Voice* findFreeVoice();
</code></pre> <p>The constant <code>NumberOfVoices</code> indicates how many voices can play at the same time. In the next line, we create an array of <code>Voice</code>s. This uses memory for 64 voices, so you could think about using <a href="http://www.cplusplus.com/doc/tutorial/dynamic/">dynamic memory</a> for this. However, our plugin class is allocated dynamically (search for <code>&quot;new PLUG_CLASS_NAME&quot;</code> in <em>IPlug_include_in_plug_src.h</em>).<br>So all members of our plugin class go on the heap as&nbsp;well.</p> <p><code>mLFO</code> is the global <span class=caps>LFO</span> for our plugin. It never gets retriggered, it just runs freely. You could argue that this should be inside the plugin class (a <code>VoiceManager</code> doesn’t have to know about an <span class=caps>LFO</span>). But this introduces another layer of separation between the <code>Voice</code>s and the <span class=caps>LFO</span>, which means that we would need more <a href="http://en.wikipedia.org/wiki/Glue_code">Glue Code</a>.<br><code>findFreeVoice</code> is a utility function that we can use to get a voice that’s not currently playing. Add the implementation to <em>VoiceManager.cpp</em>:</p> <pre><code class="lang-cpp">Voice* VoiceManager::findFreeVoice() {
    Voice* freeVoice = NULL;
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NumberOfVoices; i++) {
        <span class="keyword">if</span> (!voices[i].isActive) {
            freeVoice = &amp;(voices[i]);
            <span class="keyword">break</span>;
        }
    }
    <span class="keyword">return</span> freeVoice;
}
</code></pre> <p>This just iterates over all voices and finds the first one that isn’t currently playing. We’re <code>return</code>ing a pointer (instead of a <code>&amp;</code> reference) here because as you can see, it’s possible to return <code>NULL</code>. This wouldn’t be allowed when we return a reference. In this case, <code>NULL</code> means that all voices are currently&nbsp;playing.</p> <p>Now add the following <code>public</code> function&nbsp;prototypes:</p> <pre><code class="lang-cpp"><span class="keyword">void</span> onNoteOn(<span class="keyword">int</span> noteNumber, <span class="keyword">int</span> velocity);
<span class="keyword">void</span> onNoteOff(<span class="keyword">int</span> noteNumber, <span class="keyword">int</span> velocity);
<span class="keyword">double</span> nextSample();
</code></pre> <p>As the name implies, <code>onNoteOn</code> will be called whenever our plugin receives a <span class=caps>MIDI</span> note on message. <code>onNoteOff</code> will be called on every note off message. Let’s implement these (in <em>VoiceManager.cpp</em>):</p> <pre><code class="lang-cpp"><span class="keyword">void</span> VoiceManager::onNoteOn(<span class="keyword">int</span> noteNumber, <span class="keyword">int</span> velocity) {
    Voice* voice = findFreeVoice();
    <span class="keyword">if</span> (!voice) {
        <span class="keyword">return</span>;
    }
    voice-&gt;reset();
    voice-&gt;setNoteNumber(noteNumber);
    voice-&gt;mVelocity = velocity;
    voice-&gt;isActive = <span class="keyword">true</span>;
    voice-&gt;mVolumeEnvelope.enterStage(EnvelopeGenerator::ENVELOPE_STAGE_ATTACK);
    voice-&gt;mFilterEnvelope.enterStage(EnvelopeGenerator::ENVELOPE_STAGE_ATTACK);
}
</code></pre> <p>First, we’re finding a free voice using the <code>findFreeVoice</code> function we created above. If there’s no free voice, we just <code>return</code>. This means that when all voices are in use, pressing a note will do nothing. Implementing <a href="http://electronicmusic.wikia.com/wiki/Voice_stealing">voice stealing</a> will be the topic of a later post. If we get a free voice, we have to somehow <code>reset</code> it to a blank state (we’ll implement that in a moment). We then <code>setNoteNumber</code> and <code>mVelocity</code> to the right values. We mark the voice as active and make both envelopes go into attack stage.<br>When you try to build this, you’ll get an error for trying to access <code>Voice</code>‘s <code>private</code> members from outside. In my opinion, the best solution here is to use the <a href="http://en.wikipedia.org/wiki/Friend_class"><code>friend</code></a> keyword. Add the following line at the beginning of <code>public</code> in <em>Voice.h</em>:</p> <pre><code class="lang-cpp"><span class="keyword">friend</span> <span class="keyword">class</span> VoiceManager;
</code></pre> <p>With this line, <code>Voice</code> gives <code>VoiceManager</code> access to all its <code>private</code> members. I’m no advocate of overusing this feature, but when you have a <code>class Foo</code> and a <code>class FooManager</code>, it’s a good way to avoid writing a lot of&nbsp;setters.</p> <p>Let’s implement <code>onNoteOff</code>:</p> <pre><code class="lang-cpp"><span class="keyword">void</span> VoiceManager::onNoteOff(<span class="keyword">int</span> noteNumber, <span class="keyword">int</span> velocity) {
    <span class="comment">// Find the voice(s) with the given noteNumber:</span>
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NumberOfVoices; i++) {
        Voice&amp; voice = voices[i];
        <span class="keyword">if</span> (voice.isActive &amp;&amp; voice.mNoteNumber == noteNumber) {
            voice.mVolumeEnvelope.enterStage(EnvelopeGenerator::ENVELOPE_STAGE_RELEASE);
            voice.mFilterEnvelope.enterStage(EnvelopeGenerator::ENVELOPE_STAGE_RELEASE);
        }
    }
}
</code></pre> <p>We’re finding all voice<strong>s</strong> (!) with the note number that was released, and put both of their envelopes in the release stage. Why the plural? Can there be more than one active voice for a given note number?<br>Imagine you have a long decay on the volume envelope. You press a key on the keyboard and release it. While it’s fading out, you quickly hit that key again. Of course you don’t want to cut the old note off, and you also want to hear the new note. So you need two voices. If you have a long release time and keep hammering one key quickly, you may have a lot of active voices for a given note number.<br>So what happens if you have 5 active voices for the middle C and you release the key? <code>onNoteOff</code> gets called and puts <em>all 5 voices</em> into release stage. 4 of them were already in that stage, so let’s have a look at the first line of <code>EnvelopeGenerator::enterStage</code>:</p> <pre><code class="lang-cpp"><span class="keyword">if</span> (currentStage == newStage) <span class="keyword">return</span>;
</code></pre> <p>As you can see, it won’t have any effect on the 4 voices that already entered release stage. So it’s not a&nbsp;problem.</p> <p>Now let’s implement the <code>VoiceManager</code>‘s <code>nextSample</code> member function. It should give the summed output of all active&nbsp;voices.</p> <pre><code class="lang-cpp"><span class="keyword">double</span> VoiceManager::nextSample() {
    <span class="keyword">double</span> output = <span class="number">0.0</span>;
    <span class="keyword">double</span> lfoValue = mLFO.nextSample();
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NumberOfVoices; i++) {
        Voice&amp; voice = voices[i];
        voice.setLFOValue(lfoValue);
        output += voice.nextSample();
    }
    <span class="keyword">return</span> output;
}
</code></pre> <p>As you can see, we’re starting with silence (<code>0.0</code>). We then iterate over all voices, set the current <span class=caps>LFO</span> value, and add the voice’s output to the sum. Remember, if the voice isn’t active, <code>Voice::nextSample</code> will return immediately without&nbsp;calculating.</p> <h2 id=reusable-components>Reusable&nbsp;Components</h2> <p>Until now, we have created an <code>Oscillator</code> and <code>Filter</code> instance and have used it for the whole time our plugin is running. But our <code>VoiceManager</code> re-uses free voices. So we need a way to reset a voice completely to its initial state. Let’s start in <em>Voice.h</em> by adding a <code>public</code> member&nbsp;function:</p> <pre><code class="lang-cpp"><span class="keyword">void</span> reset();
</code></pre> <p>Put the implementation in <em>Voice.cpp</em>:</p> <pre><code class="lang-cpp"><span class="keyword">void</span> Voice::reset() {
    mNoteNumber = -<span class="number">1</span>;
    mVelocity = <span class="number">0</span>;
    mOscillatorOne.reset();
    mOscillatorTwo.reset();
    mVolumeEnvelope.reset();
    mFilterEnvelope.reset();
    mFilter.reset();
}
</code></pre> <p>As you can see, we’re resetting <code>mNoteNumber</code> and <code>mVelocity</code>. We then reset the oscillators, envelopes and the filter. Let’s create these member functions! Starting in <em>Oscillator.h</em>, add the <code>public</code> member&nbsp;function:</p> <pre><code class="lang-cpp"><span class="keyword">void</span> reset() { mPhase = <span class="number">0.0</span>; }
</code></pre> <p>This lets the waveform start from the beginning everytime a voice starts to play.<br>While you’re there, remove the <code>private</code> <code>isMuted</code> property. Also remove it from the constructor’s initializer list and remove the <code>public</code> member function <code>setMuted</code>. We’re now handling the active/inactive state on the <code>Voice</code> level, so the <code>Oscillator</code> doesn’t need it anymore. In <em>Oscillator.cpp</em>, edit <code>Oscillator::nextSample</code> and remove this&nbsp;line:</p> <pre><code class="lang-cpp"><span class="comment">// remove this line:</span>
<span class="keyword">if</span>(isMuted) <span class="keyword">return</span> value;
</code></pre> <p>The <code>reset</code> function for the <code>EnvelopeGenerator</code> is a little longer. Put this in <code>EnvelopeGenerator</code>‘s <code>public</code> section (in <em>EnvelopeGenerator.h</em>):</p> <pre><code class="lang-cpp"><span class="keyword">void</span> reset() {
    currentStage = ENVELOPE_STAGE_OFF;
    currentLevel = minimumLevel;
    multiplier = <span class="number">1.0</span>;
    currentSampleIndex = <span class="number">0</span>;
    nextStageSampleIndex = <span class="number">0</span>;
}
</code></pre> <p>As you can see, we have more values to reset here, but it’s still pretty straightforward. Finally, add the function for the <code>Filter</code> class (again, in <code>public</code>):</p> <pre><code class="lang-cpp"><span class="keyword">void</span> reset() {
    buf0 = buf1 = buf2 = buf3 = <span class="number">0.0</span>;
}
</code></pre> <p>As you can see from the <a href="/articles/audio-plugins-013-filter/#filter_algorithm">filter algorithm</a>, these values are the filter’s <em>previous output</em> samples. When we re-use a voice, we want these to be&nbsp;clean.</p> <p>To summarize, whenever the <code>VoiceManager</code> reuses a <code>Voice</code>, it calls <code>reset</code> on it. This, in turn, calls <code>reset</code> on the voice’s <code>Oscillator</code>s, the <code>EnvelopeGenerator</code>s and the <code>Filter</code>. </p> <h2 id=-static-or-not-static-><code>static</code> or not <code>static</code>?</h2> <p>These member variables are the same for all&nbsp;voices:</p> <ul> <li><code>Oscillator</code>: <code>mOscillatorMode</code></li> <li><code>Filter</code>: <code>cutoff</code>, <code>resonance</code>, <code>mode</code></li> <li><code>EnvelopeGenerator</code>: the <code>stageValue</code>s</li> </ul> <p>At first I thought that this kind of duplication is evil and these things should be <code>static</code> members. Let’s imagine that <code>mOscillatorMode</code> was static. That would mean that our <span class=caps>LFO</span> always has the same waveform as our regular oscillators, which is not what we want. Also, making the <code>EnvelopeGenerator</code>‘s <code>stageValue</code>s <code>static</code> would mean that the volume and filter envelope are always the same.<br>This could be solved through inheritance: We could make a <code>VolumeEnvelope</code> and <code>FilterEnvelope</code> <code>class</code>, and have both inherit from <code>EnvelopeGenerator</code>. <code>stageValue</code> could be <code>static</code>, and both <code>VolumeEnvelope</code> and <code>FilterEnvelope</code> could override it. That would give a clean separation between the two, and all voices would be able to share the <code>static</code> members. But we’re not talking about a significant amount of memory here. The <em>overhead</em> (if any) is to keep these variables in sync across all voices’ volume/filter&nbsp;envelopes.</p> <p>There’s one thing that should be <code>static</code>, though: The <code>sampleRate</code>. There’s no point in having different components run at different sample rates. In <em>Oscillator.h</em>, make the <code>mSampleRate</code> <code>static</code>:</p> <pre><code class="lang-cpp"><span class="keyword">static</span> <span class="keyword">double</span> mSampleRate;
</code></pre> <p>This means that we shouldn’t initialize it through the initializer list anymore. Remove the <code>mSampleRate(44100.0)</code>. Go into <em>Oscillator.cpp</em> and add this line right after the <code>#include</code>:</p> <pre><code class="lang-cpp"><span class="keyword">double</span> Oscillator::mSampleRate = <span class="number">44100.0</span>;
</code></pre> <p>The sample rate is now <code>static</code>, so all <code>Oscillator</code>s use the same&nbsp;one.</p> <p>Let’s do the same for the <code>EnvelopeGenerator</code>! Make the <code>private</code> member <code>sampleRate</code> <code>static</code>, remove it from the constructor’s initializer list and add the initialization to <em>EnvelopeGenerator.cpp</em>:</p> <pre><code class="lang-cpp"><span class="keyword">double</span> EnvelopeGenerator::sampleRate = <span class="number">44100.0</span>;
</code></pre> <p>Back in <em>EnvelopeGenerator.h</em>, make the setter <code>static</code>:</p> <pre><code class="lang-cpp"><span class="keyword">static</span> <span class="keyword">void</span> setSampleRate(<span class="keyword">double</span> newSampleRate);
</code></pre> <p>We’ve added a lot of new functionality! In the <a href="/articles/audio-plugins-017-polyphony-ii/">next post</a>, we’ll clean up and make our plugin’s knobs work again. You can download the source files <a href="/articles/audio-plugins-016-polyphony/source.zip">here</a>.</p> </section> </article> <div id=donation_prompt>If you found this useful, please feel free to <form action="https://www.paypal.com/cgi-bin/webscr" method=post target=_top class=donation-form> <input type=hidden name=cmd value=_s-xclick> <input type=hidden name=hosted_button_id value=JQDU8W5PJBWL6> <input type=hidden name=ref value="/articles/audio-plugins-016-polyphony/"> <input type=image src="https://www.paypalobjects.com/en_US/i/btn/btn_donate_SM.gif" border=0 name=submit alt="PayPal - The safer, easier way to pay online!"><img alt="" border=0 src="https://www.paypalobjects.com/de_DE/i/scr/pixel.gif" width=1 height=1> </form>! </div> <iframe src="//www.facebook.com/plugins/like.php?href=http%3A%2F%2Fwww.martin-finke.de%2Fblog%2F&amp;width=450&amp;height=21&amp;colorscheme=light&amp;layout=button_count&amp;action=like&amp;show_faces=false&amp;send=false" scrolling=no frameborder=0 style="border: none; overflow: hidden; width: 200px; height: 21px;" allowtransparency=true></iframe> <div class=comments> <div id=disqus_thread></div> <script type="text/javascript">var disqus_shortname="martinfinke";(function(){var a=document.createElement("script");a.type="text/javascript";a.async=true;a.src="//"+disqus_shortname+".disqus.com/embed.js";(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(a)})();</script> <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript> <a href="http://disqus.com" class=dsq-brlink>comments powered by <span class=logo-disqus>| Disqus</span></a> </div> </div> </div> <footer> <div class=content-wrap> <div class=nav><a href="/">« Index</a></div> <section class=copy> <p>&copy; 2015 Martin Finke – <a href="/impressum.html" class=impressum-link>Impressum</a></p> </section> </div> </footer> <script src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script> <script>window.jQuery||document.write('<script src="/js/vendor/jquery-1.10.2.min.js"><\/script>');</script> <script type="text/javascript">$(document).ready(function(){$('a:link[href^=http]:not([href*="martin-finke.de"])').attr("target","_blank")});</script> <script type="text/javascript">var _gaq=_gaq||[];_gaq.push(["_setAccount","UA-43375106-1"]);_gaq.push(["_trackPageview"]);(function(){var b=document.createElement("script");b.type="text/javascript";b.async=true;b.src=("https:"==document.location.protocol?"https://":"http://")+"stats.g.doubleclick.net/dc.js";var a=document.getElementsByTagName("script")[0];a.parentNode.insertBefore(b,a)})();</script> </body> </html>