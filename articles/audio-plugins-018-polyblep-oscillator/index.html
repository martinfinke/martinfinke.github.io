<!DOCTYPE html> <html lang=en> <head> <meta charset=utf-8> <meta http-equiv=X-UA-Compatible content="IE=edge,chrome=1"> <meta name=HandheldFriendly content=True> <meta name=MobileOptimized content=320> <meta name=viewport content="width=device-width"> <meta http-equiv=cleartype content=on> <meta property="fb:admins" content=100001493355877> <meta property="og:image" content="http://www.martin-finke.de/img/making_audio_plugins_thumbnail.png"> <meta property="og:image:type" content="image/png"> <meta property="og:image:width" content=100> <meta property="og:image:height" content=100> <title>Making Audio Plugins Part 18: PolyBLEP Oscillator - Martin Finke's Blog </title> <link rel=alternate href="/feed.xml" type="application/rss+xml" title="Music &amp; Programming"> <link href="http://fonts.googleapis.com/css?family=Domine:700|Inconsolata:400,700" rel=stylesheet type="text/css"> <link rel=stylesheet href='/css/4407aa6.css'> </head> <body class=article-detail> <header class=header> <div class=content-wrap> <h1>Making Audio Plugins Part 18: PolyBLEP Oscillator</h1> <div class=taglinks><a href="/tags/programming.html" class=taglink>Programming</a>, <a href="/tags/dsp.html" class=taglink>DSP</a>, <a href="/tags/making_audio_plugins.html" class=taglink>Making Audio Plugins</a> </div> </div> </header> <div id=content> <div class=content-wrap> <article class=article> <section class=content><p>Let’s create an oscillator with much less aliasing! <span class=more></span> This is an <em>optional</em> improvement, you don’t have to do it. Our <em>SpaceBass</em> synth will work the same as before, but it will sound much better in higher&nbsp;octaves.</p> <h2 id=analyzing-the-spectrum>Analyzing the&nbsp;Spectrum</h2> <p>I’d like to introduce a very good free plugin: <a href="http://www.voxengo.com/product/span/">Voxengo <span class=caps>SPAN</span></a>. Basically you can insert it on a track, and it will show you the spectrum of the signal going through it. We’re not quite ready to write our own <a href="http://en.wikipedia.org/wiki/Fast_Fourier_transform"><span class=caps>FFT</span></a> testing routines, so this will be indispensable to compare different algorithms and see what’s going on.<br>Download and install it. Run the <em>SpaceBass</em> plugin in <span class=caps>REAPER</span>, open its <span class=caps>GUI</span> and make sure&nbsp;that:</p> <ul> <li>The oscillator <em>Mix</em> knob is turned all the way to the left (so you only hear oscillator&nbsp;1)</li> <li>Oscillator 1 is set to the <em>square</em> waveform</li> <li>Filter cutoff is at max, resonance at&nbsp;min</li> <li>Filter <span class=caps>LFO</span> amount is at min, env amount is in central&nbsp;position</li> </ul> <p>With these settings, you can hear the raw waveform of oscillator 1. Now insert the <em><span class=caps>SPAN</span></em> plugin right after <em>SpaceBass</em>. Play a fairly high note (I used A6), and you should see something like&nbsp;this:</p> <p><a href="/articles/audio-plugins-018-polyblep-oscillator/square_aliased.png"><img src="/articles/audio-plugins-018-polyblep-oscillator/square_aliased.png" alt=""></a></p> <p>Here’s how to read this graph: The x axis is the frequency (in Hz), going from 66 Hz to 20 kHz here. The spacing is <em>logarithmic</em>, which just means that the space between octaves is always the same: The gap between C1 and C2 is the same as the gap between C7 and C8. Octaves have a ratio of <em>times two</em>, but harmonics are just <em>multiples</em> of the fundamental frequency. This means that harmonics are <em>not</em> spaced evenly in the graph. The y axis is the amplitude (in decibels). So you can see at a glance which frequencies are currently present in the signal.<br>Depending on your settings, it may look a little different, but it’s clear that there’s something wrong: For a square wave, you’d expect a series of peaks that decrease in volume (the higher the frequency), with <em>nothing in between</em>. Especially not below the fundamental (i.e. in the left portion of the above image). As <a href="/articles/audio-plugins-008-synthesizing-waveforms/#aliasing">described before</a>, this is called <em>Aliasing</em>.</p> <p>So what do we do about it? There are different solutions. You get the best results by synthesizing a <a href="http://en.wikipedia.org/wiki/Fourier_series">Fourier series</a> to approximate the square waveform. This just means that you layer sine waves with the correct amplitudes (starting at the fundamental, and one for each harmonic), <em>but you stop when you reach the nyquist frequency</em>. This additive approach would give a perfectly <em>bandlimited</em> waveform (i.e. one that only has spectral content from the fundamental to the nyquist frequency).<br>Of course there’s a catch. This method may be good for high octaves (where the fundamental is so high that there aren’t many harmonics until the nyquist frequency). But for low octaves you have to layer <em>a lot</em> of sine waves: If you’re working at a sample rate of 44.1 kHz, a saw wave with a fundamental of 100 Hz will have 219 harmonics until the nyquist, so you’d have to calculate a total of 220 <code>sin()</code> values every sample. Of course, in a polyphonic synth, multiply this by the number of notes being played.<br>You could argue that you only have to do the layering once for every played note. This is true as long as you don’t have any pitch modulation. With pitch modulation, the frequency can change <em>every sample</em>, so it’d be a lot of work to layer the sine waves again and&nbsp;again.</p> <h2 id=blips-and-bleps>BLIPs and&nbsp;BLEPs</h2> <p>There are other approaches, most&nbsp;notably:</p> <ul> <li><a href="https://ccrma.stanford.edu/~stilti/papers/blit.pdf"><em>Bandlimited Impulse Train&nbsp;(<span class=caps>BLIT</span>)</em></a> </li> <li><a href="http://www.cs.cmu.edu/~eli/papers/icmc01-hardsync.pdf"><em>Minimum-Phase Bandlimited Step&nbsp;(MinBLEP)</em></a></li> <li><a href="http://www.kvraudio.com/forum/viewtopic.php?t=375517"><em>Polynomial Bandlimited Step&nbsp;(PolyBLEP)</em></a></li> </ul> <p>The two <em><span class=caps>BLEP</span></em> approaches are based on the fact that the aliasing is only caused by the sharp jumps in the waveform. With the waveforms we currently have, only the sharp edges are the problem. So can we just round them like a piece of wood? Just rounding the edges would be equivalent to gentle low-pass filtering, which is not what we want. We want no filtering up to the nyquist frequency, and nothing above that. We want the same result as if we had layered sine waves.<br>A square wave created from sine waves looks like this: <a href="/articles/audio-plugins-018-polyblep-oscillator/Fourier_series_and_transform.gif"><img src="/articles/audio-plugins-018-polyblep-oscillator/Fourier_series_and_transform.gif" alt=""></a> The blue parts are the sine waves that are layered, the red part is the resulting bandlimited square wave. As you can see, it’s not just a square with rounded edges. It has these characteristic <em>ripples</em>.<br>In simple terms, the two <em><span class=caps>BLEP</span></em> approaches first generate a waveform <a href="/articles/audio-plugins-008-synthesizing-waveforms/">just like we did</a>, and then layer the ripples on top. Doing that removes (or greatly reduces) the&nbsp;aliasing.</p> <p>If you’ve visited the links above, you’re maybe guessing that the PolyBLEP approach is the easiest to use. In that case, your intuition is spot-on, and that’s why we’re going to use&nbsp;PolyBLEPs!</p> <h2 id=the-polybleposcillator-class>The PolyBLEPOscillator&nbsp;Class</h2> <p>A <code>PolyBLEPOscillator</code> <a href="http://en.wikipedia.org/wiki/Is-a">is a</a>n <code>Oscillator</code>, so we will use <a href="http://www.learncpp.com/cpp-tutorial/115-inheritance-and-access-specifiers/">public inheritance</a>. <code>Oscillator</code> will be the base class, and it’ll take care&nbsp;of:</p> <p>In the <em>SpaceBass</em> project, create a new class called <em>PolyBLEPOscillator</em> and add it to all targets. If you didn’t follow the previous posts or don’t have the project, feel free to <a href="/articles/audio-plugins-018-polyblep-oscillator/SpaceBass_before.zip">download it</a> and start from&nbsp;there.</p> <p>This is the class&nbsp;definition:</p> <pre><code class="lang-cpp"><span class="preprocessor">#include "Oscillator.h"</span>

<span class="keyword">class</span> PolyBLEPOscillator: <span class="keyword">public</span> Oscillator {
<span class="keyword">public</span>:
    PolyBLEPOscillator() : lastOutput(<span class="number">0.0</span>) { updateIncrement(); };
    <span class="keyword">double</span> nextSample();
<span class="keyword">private</span>:
    <span class="keyword">double</span> poly_blep(<span class="keyword">double</span> t);
    <span class="keyword">double</span> lastOutput;
};
</code></pre> <p>We’re inheriting publicly from <code>Oscillator</code>. To override how waveforms are calculated, we define a new <code>nextSample</code> member function (more on that later). We add another <code>private</code> function called <code>poly_blep</code>, which will generate the ripples at the edges. The <code>lastOutput</code> variable saves the last output value (this will only be needed for the triangle wave).<br>In <em>PolyBLEPOscillator.cpp</em>, add the implementation for <code>poly_blep</code>:</p> <pre><code class="lang-cpp"><span class="comment">// PolyBLEP by Tale</span>
<span class="comment">// (slightly modified)</span>
<span class="comment">// http://www.kvraudio.com/forum/viewtopic.php?t=375517</span>
<span class="keyword">double</span> PolyBLEPOscillator::poly_blep(<span class="keyword">double</span> t)
{
    <span class="keyword">double</span> dt = mPhaseIncrement / twoPI;
    <span class="comment">// 0 &lt;= t &lt; 1</span>
    <span class="keyword">if</span> (t &lt; dt) {
        t /= dt;
        <span class="keyword">return</span> t+t - t*t - <span class="number">1.0</span>;
    }
    <span class="comment">// -1 &lt; t &lt; 0</span>
    <span class="keyword">else</span> <span class="keyword">if</span> (t &gt; <span class="number">1.0</span> - dt) {
        t = (t - <span class="number">1.0</span>) / dt;
        <span class="keyword">return</span> t*t + t+t + <span class="number">1.0</span>;
    }
    <span class="comment">// 0 otherwise</span>
    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0.0</span>;
}
</code></pre> <p>The math may look complicated, but basically this function almost always <code>return</code>s <code>0.0</code>, except then we’re close to an edge. The first <code>if</code> branch means that we’re at the beginning of a period, and the <code>else if</code> means that we’re right before the end. This is the right behaviour for a saw wave, because in a saw wave there’s only one jump, which is between two&nbsp;periods.</p> <p>Before we can implement <code>nextSample</code>, we have to make some changes to the <code>Oscillator</code> class. In <em>Oscillator.h</em>, make the <code>nextSample</code> function <code>virtual</code>:</p> <pre><code class="lang-cpp"><span class="keyword">virtual</span> <span class="keyword">double</span> nextSample();
</code></pre> <p>This means that we can override <code>nextSample</code>‘s default behaviour in our subclass. Using <code>virtual</code> in time-critical code isn’t the best solution performance-wise. You can avoid this by using templates (and still get away without duplicating code), but I want to keep things simple here and stick to the topic of synthesis.<br>Change the <code>private:</code> to <code>protected:</code>. This will allow access to things like <code>mPhase</code> from <code>PolyBLEPOscillator</code>s member functions.<br>As described above, we will reuse the (aliased) waveforms from <code>Oscillator</code> as a starting point, and then layer <code>poly_blep</code> on top. Right now, <code>nextSample</code> calculates the waveform <em>and</em> increments the <code>mPhase</code>. We have to separate these two unrelated things. Add this <code>protected</code> member&nbsp;function:</p> <pre><code class="lang-cpp"><span class="keyword">double</span> naiveWaveformForMode(OscillatorMode mode);
</code></pre> <p>This function will contain the (aliased) waveform generation code. <em>Naive</em> in this case means that it generates the waveforms in a <em>naive</em> and incorrect way, without caring about aliasing. Let’s go into <em>Oscillator.cpp</em> and write it! (You don’t need to type this by hand, because it’s almost the same as <code>Oscillator::nextSample</code>)</p> <pre><code class="lang-cpp"><span class="keyword">double</span> Oscillator::naiveWaveformForMode(OscillatorMode mode) {
    <span class="keyword">double</span> value;
    <span class="keyword">switch</span> (mode) {
        <span class="keyword">case</span> OSCILLATOR_MODE_SINE:
            value = <span class="built_in">sin</span>(mPhase);
            <span class="keyword">break</span>;
        <span class="keyword">case</span> OSCILLATOR_MODE_SAW:
            value = (<span class="number">2.0</span> * mPhase / twoPI) - <span class="number">1.0</span>;
            <span class="keyword">break</span>;
        <span class="keyword">case</span> OSCILLATOR_MODE_SQUARE:
            <span class="keyword">if</span> (mPhase &lt; mPI) {
                value = <span class="number">1.0</span>;
            } <span class="keyword">else</span> {
                value = -<span class="number">1.0</span>;
            }
            <span class="keyword">break</span>;
        <span class="keyword">case</span> OSCILLATOR_MODE_TRIANGLE:
            value = -<span class="number">1.0</span> + (<span class="number">2.0</span> * mPhase / twoPI);
            value = <span class="number">2.0</span> * (<span class="built_in">fabs</span>(value) - <span class="number">0.5</span>);
            <span class="keyword">break</span>;
        <span class="keyword">default</span>:
            <span class="keyword">break</span>;
    }
    <span class="keyword">return</span> value;
}
</code></pre> <p>The two differences from <code>Oscillator::nextSample</code> are:</p> <ul> <li>We’re choosing the waveform based on the <code>mode</code> parameter passed in from outside (instead of <code>mOscillatorMode</code>)</li> <li>The saw wave is now upwards (instead of&nbsp;downwards)</li> </ul> <p>Since this now contains all the code from <code>Oscillator::nextSample</code>, we can replace <code>nextSample</code> with&nbsp;this:</p> <pre><code class="lang-cpp"><span class="keyword">double</span> Oscillator::nextSample() {
    <span class="keyword">double</span> value = naiveWaveformForMode(mOscillatorMode);
    mPhase += mPhaseIncrement;
    <span class="keyword">while</span> (mPhase &gt;= twoPI) {
        mPhase -= twoPI;
    }
    <span class="keyword">return</span> value;
}
</code></pre> <p>It just calls <code>naiveWaveformForMode</code> to calculate the waveform, and then increments the <code>mPhase</code>. </p> <h2 id=generating-polyblep-waveforms>Generating PolyBLEP&nbsp;Waveforms</h2> <p>Let’s go back to <em>PolyBLEPOscillator.cpp</em> and implement <code>nextSample</code>. Start with&nbsp;this:</p> <pre><code class="lang-cpp"><span class="keyword">double</span> PolyBLEPOscillator::nextSample() {
    <span class="keyword">double</span> value = <span class="number">0.0</span>;
    <span class="keyword">double</span> t = mPhase / twoPI;

    <span class="keyword">if</span> (mOscillatorMode == OSCILLATOR_MODE_SINE) {
        value = naiveWaveformForMode(OSCILLATOR_MODE_SINE);
    } <span class="keyword">else</span> <span class="keyword">if</span> (mOscillatorMode == OSCILLATOR_MODE_SAW) {
        value = naiveWaveformForMode(OSCILLATOR_MODE_SAW);
        value -= poly_blep(t);
    }
</code></pre> <p>The <code>t</code> variable is needed for the way the <code>poly_blep</code> function works. It’s the current phase divided by <code>twoPI</code>, so it’s between <code>0</code> and <code>1</code>. The <code>if</code> statement distinguishes between the different waveforms. For the sine wave, we don’t have to worry about aliasing (because there are no harmonics), so we just use the naive waveform. For the saw wave, we first get the aliased waveform value from <code>Oscillator</code>. We then layer the output of <code>poly_blep</code> on top, and that’s it!<br>We will generate the triangle wave by first generating a square wave, and then <em>integrating it</em>. We’re working with discrete samples, so <em>integrating</em> just means <em>summing values</em>. If you think about it, a square wave starts with all-one values, so summing these up gives a linear rise. After half a period, the square wave jumps to all-minus-one, so summing those means a linear decay. A triangle wave is just that: A linear rise followed by a linear decay, followed by a rise and so on.<br>With this in mind, we’ll make a square wave for both the square <em>and</em> the triangle&nbsp;wave:</p> <pre><code class="lang-cpp">    <span class="keyword">else</span> {
        value = naiveWaveformForMode(OSCILLATOR_MODE_SQUARE);
        value += poly_blep(t);
        value -= poly_blep(<span class="built_in">fmod</span>(t + <span class="number">0.5</span>, <span class="number">1.0</span>));
</code></pre> <p>Again, we’re starting with the naive (aliased) waveform. This time, though, we’re adding <em>two</em> PolyBLEPs! One at the start of a period, and the other offset by <code>0.5</code> (i.e. half a period). If you picture a square wave, it’s clear why we need two: A square wave has two jumps per period, whereas a saw wave only has one.<br>The only one missing is the triangle! Add this (at the end of the <code>else</code> block!):</p> <pre><code class="lang-cpp">        <span class="keyword">if</span> (mOscillatorMode == OSCILLATOR_MODE_TRIANGLE) {
            <span class="comment">// Leaky integrator: y[n] = A * x[n] + (1 - A) * y[n-1]</span>
            value = mPhaseIncrement * value + (<span class="number">1</span> - mPhaseIncrement) * lastOutput;
            lastOutput = value;
        }
</code></pre> <p>I wrote above that we just have to integrate the square wave. I <strong>don’t</strong> encourage you to try that, because it will cause the waveform to become more and more offset into very large values (which could damage your speakers). Instead, we’re using a <em>leaky integrator</em>. It adds the previous output, but multiplied by a value slightly below <code>1</code>. This prevents the offset from accumulating.<br>Let’s round this off by adding the phase incrementation (this is the same as&nbsp;before):</p> <pre><code class="lang-cpp">    }

    mPhase += mPhaseIncrement;
    <span class="keyword">while</span> (mPhase &gt;= twoPI) {
        mPhase -= twoPI;
    }
    <span class="keyword">return</span> value;
}
</code></pre> <p>And just like that, the <code>PolyBLEPOscillator</code> is&nbsp;finished!</p> <h2 id=using-the-new-oscillator>Using the new&nbsp;Oscillator</h2> <p>To use our shiny new <code>PolyBLEPOscillator</code>, we just have to change a few lines in <em>Voice.h</em>. Replace the <code>#include &quot;Oscillator.h&quot;</code> with&nbsp;this:</p> <pre><code class="lang-cpp"><span class="preprocessor">#include "PolyBLEPOscillator.h"</span>
</code></pre> <p>In the <code>private</code> section, turn <code>mOscillatorOne</code> and <code>mOscillatorTwo</code> into <code>PolyBLEPOscillator</code>s:</p> <pre><code class="lang-cpp">PolyBLEPOscillator mOscillatorOne;
PolyBLEPOscillator mOscillatorTwo;
</code></pre> <p>And that’s it! Run your plugin and have a look at the spectrum using <span class=caps>SPAN</span>. You’ll see that the aliasing is <em>greatly</em> reduced. Here are some screenshots for comparison. You can click on them to toggle between the old <code>Oscillator</code> and the new <code>PolyBLEPOscillator</code>:</p> <p><a class=image-toggler><span class=description><code>Oscillator</code> Saw (aliased):</span> <img src="/articles/audio-plugins-018-polyblep-oscillator/saw_aliased.png" alt=""> <span class=description><code>PolyBLEPOscillator</code> Saw:</span> <img src="/articles/audio-plugins-018-polyblep-oscillator/saw_polyblep.png" alt=""> </a></p> <p><a class=image-toggler><span class=description><code>Oscillator</code> Square (aliased):</span> <img src="/articles/audio-plugins-018-polyblep-oscillator/square_aliased.png" alt=""> <span class=description><code>PolyBLEPOscillator</code> Square:</span> <img src="/articles/audio-plugins-018-polyblep-oscillator/square_polyblep.png" alt=""> </a></p> <p><a class=image-toggler><span class=description><code>Oscillator</code> Triangle (aliased):</span> <img src="/articles/audio-plugins-018-polyblep-oscillator/triangle_aliased.png" alt=""> <span class=description><code>PolyBLEPOscillator</code> Triangle:</span> <img src="/articles/audio-plugins-018-polyblep-oscillator/triangle_polyblep.png" alt=""> </a></p> <h2 id=so-what-about-the-lfo->So what about the&nbsp;<span class=caps>LFO</span>?</h2> <p>But we’re still using the old <code>Oscillator</code> for the <span class=caps>LFO</span>! Should we use the <code>PolyBLEPOscillator</code> instead? Well, in an <span class=caps>LFO</span> you actually <em>want</em> the sharp edges, they can be handy for crazy sound effects. And the aliasing concern doesn’t really matter here because an <span class=caps>LFO</span>’s fundamental is usually very low (below 30 Hz). Each harmonic has a lower amplitude than the one below it, so the harmonics above the nyquist frequency have a <em>very</em> low&nbsp;amplitude.</p> <h2 id=summary>Summary</h2> <p>We have generated anti-aliased saw and square waveforms from the aliasing counterparts by layering PolyBLEPs on top. We have generated the triangle wave by (leaky) integrating the anti-aliased square wave. We can now happily play our synth even at very high octaves without getting nasty unharmonic frequencies! You can download the source code <a href="/articles/audio-plugins-018-polyblep-oscillator/source.zip">here</a>. Thanks for joining in and see you next&nbsp;time!</p> </section> </article> <div id=donation_prompt>If you found this useful, please feel free to <form action="https://www.paypal.com/cgi-bin/webscr" method=post target=_top class=donation-form> <input type=hidden name=cmd value=_s-xclick> <input type=hidden name=hosted_button_id value=JQDU8W5PJBWL6> <input type=hidden name=ref value="/articles/audio-plugins-018-polyblep-oscillator/"> <input type=image src="https://www.paypalobjects.com/en_US/i/btn/btn_donate_SM.gif" border=0 name=submit alt="PayPal - The safer, easier way to pay online!"><img alt="" border=0 src="https://www.paypalobjects.com/de_DE/i/scr/pixel.gif" width=1 height=1> </form>! </div> <iframe src="//www.facebook.com/plugins/like.php?href=http%3A%2F%2Fwww.martin-finke.de%2Fblog%2F&amp;width=450&amp;height=21&amp;colorscheme=light&amp;layout=button_count&amp;action=like&amp;show_faces=false&amp;send=false" scrolling=no frameborder=0 style="border: none; overflow: hidden; width: 200px; height: 21px;" allowtransparency=true></iframe> <div class=comments> <div id=disqus_thread></div> <script type="text/javascript">var disqus_shortname="martinfinke";(function(){var a=document.createElement("script");a.type="text/javascript";a.async=true;a.src="//"+disqus_shortname+".disqus.com/embed.js";(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(a)})();</script> <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript> <a href="http://disqus.com" class=dsq-brlink>comments powered by <span class=logo-disqus>| Disqus</span></a> </div> </div> </div> <footer> <div class=content-wrap> <div class=nav><a href="/">« Index</a></div> <section class=copy> <p>&copy; 2015 Martin Finke – <a href="/impressum.html" class=impressum-link>Impressum</a></p> </section> </div> </footer> <script src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script> <script>window.jQuery||document.write('<script src="/js/vendor/jquery-1.10.2.min.js"><\/script>');</script> <script type="text/javascript">$(document).ready(function(){$('a:link[href^=http]:not([href*="martin-finke.de"])').attr("target","_blank")});</script> <script type="text/javascript">$(document).ready(function(){$(".image-toggler").each(function(){var a=$(this);a.children(".description").eq(0).add(a.children("img").eq(0)).addClass("hidden")});$(document.body).on("click",".image-toggler",function(a){var b=$(this);b.children(".description, img").toggleClass("hidden")})});</script> <script type="text/javascript">var _gaq=_gaq||[];_gaq.push(["_setAccount","UA-43375106-1"]);_gaq.push(["_trackPageview"]);(function(){var b=document.createElement("script");b.type="text/javascript";b.async=true;b.src=("https:"==document.location.protocol?"https://":"http://")+"stats.g.doubleclick.net/dc.js";var a=document.getElementsByTagName("script")[0];a.parentNode.insertBefore(b,a)})();</script> </body> </html>