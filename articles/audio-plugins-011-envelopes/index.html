<!DOCTYPE html> <html lang=en> <head> <meta charset=utf-8> <meta http-equiv=X-UA-Compatible content="IE=edge,chrome=1"> <meta name=HandheldFriendly content=True> <meta name=MobileOptimized content=320> <meta name=viewport content="width=device-width"> <meta http-equiv=cleartype content=on> <meta property="fb:admins" content=100001493355877> <meta property="og:image" content="http://www.martin-finke.de/blog/img/making_audio_plugins_thumbnail.png"> <meta property="og:image:type" content="image/png"> <meta property="og:image:width" content=100> <meta property="og:image:height" content=100> <title>Making Audio Plugins Part 11: Envelopes - Martin Finke's Blog </title> <link rel=alternate href="/blog/feed.xml" type="application/rss+xml" title="Music &amp; Programming"> <link href="http://fonts.googleapis.com/css?family=Domine:700|Inconsolata:400,700" rel=stylesheet type="text/css"> <link rel=stylesheet href='/blog/css/4407aa6.css'> </head> <body class=article-detail> <header class=header> <div class=content-wrap> <h1>Making Audio Plugins Part 11: Envelopes</h1> <div class=taglinks><a href="/blog/tags/programming.html" class=taglink>Programming</a>, <a href="/blog/tags/dsp.html" class=taglink>DSP</a>, <a href="/blog/tags/making_audio_plugins.html" class=taglink>Making Audio Plugins</a> </div> </div> </header> <div id=content> <div class=content-wrap> <article class=article> <section class=content><p>Sound is only interesting when there’s variation over time. Let’s create an envelope generator to make variations in volume! <span class=more></span></p> <h2 id=envelope-generator-basics>Envelope Generator&nbsp;Basics</h2> <p>If you’re not familiar with the term <em><span class=caps>ADSR</span></em> (meaning <em>Attack Decay Sustain Release</em>), please read <a href="http://en.wikipedia.org/wiki/Synthesizer#ADSR_envelope">this</a> before we go on.<br>Basically, our envelope generator is a <a href="http://en.wikipedia.org/wiki/Finite-state_machine">finite state machine</a> with the states <em>Off</em>, <em>Attack</em>, <em>Decay</em>, <em>Sustain</em> and <em>Release</em>. That’s a fancy way of saying that at any given point in time, it is in exactly one of those states. In envelope terms, these are called <em>stages</em>. Going from one stage to another will be done by calling the <code>enterStage</code> member function.<br>A few key points about envelope&nbsp;stages:</p> <ul> <li>The generator gets out of the <span class=caps>ATTACK</span>, <span class=caps>DECAY</span> and <span class=caps>RELEASE</span> stage by itself: After a given time has passed, it calls <code>enterStage</code> to go to the next&nbsp;stage.</li> <li>It stays in the <span class=caps>OFF</span> and <span class=caps>SUSTAIN</span> stages indefinitely, until <code>enterStage</code> is called from&nbsp;outside.</li> <li>Therefore, <span class=caps>ATTACK</span>, <span class=caps>DECAY</span> and <span class=caps>RELEASE</span> are <em>time</em> values, but <span class=caps>SUSTAIN</span> is a <em>level</em> value.</li> <li>It can enter the <span class=caps>RELEASE</span> stage coming from the <span class=caps>ATTACK</span>, <span class=caps>DECAY</span> or <span class=caps>SUSTAIN</span>&nbsp;stage.</li> <li>When entering <span class=caps>RELEASE</span>, it should decay <em>from the current level</em> down to&nbsp;zero.</li> </ul> <p>For each sample, the envelope generator will give us a <code>double</code> between zero and one. We’ll get the current value from the envelope generator, and then we’ll <em>multiply</em> our signal with this value. This way, the signal’s volume will be determined by the envelope: We’ll be able to create tones that fade in slowly or quickly decay in&nbsp;volume.</p> <h2 id=the-envelopegenerator-class>The <code>EnvelopeGenerator</code> Class</h2> <p>Create a new C++ class named <code>EnvelopeGenerator</code> and add it to all targets. Go into <em>EnvelopeGenerator.h</em> and add the following class declaration (between <code>#define</code> and <code>#endif</code>):</p> <pre><code class="lang-cpp"><span class="preprocessor">#include &lt;cmath&gt;</span>

<span class="keyword">class</span> EnvelopeGenerator {
<span class="keyword">public</span>:
    <span class="keyword">enum</span> EnvelopeStage {
        ENVELOPE_STAGE_OFF = <span class="number">0</span>,
        ENVELOPE_STAGE_ATTACK,
        ENVELOPE_STAGE_DECAY,
        ENVELOPE_STAGE_SUSTAIN,
        ENVELOPE_STAGE_RELEASE,
        kNumEnvelopeStages
    };
    <span class="keyword">void</span> enterStage(EnvelopeStage newStage);
    <span class="keyword">double</span> nextSample();
    <span class="keyword">void</span> setSampleRate(<span class="keyword">double</span> newSampleRate);
    <span class="keyword">inline</span> EnvelopeStage getCurrentStage() <span class="keyword">const</span> { <span class="keyword">return</span> currentStage; };
    <span class="keyword">const</span> <span class="keyword">double</span> minimumLevel;

    EnvelopeGenerator() :
    minimumLevel(<span class="number">0.0001</span>),
    currentStage(ENVELOPE_STAGE_OFF),
    currentLevel(minimumLevel),
    multiplier(<span class="number">1.0</span>),
    sampleRate(<span class="number">44100.0</span>),
    currentSampleIndex(<span class="number">0</span>),
    nextStageSampleIndex(<span class="number">0</span>) {
        stageValue[ENVELOPE_STAGE_OFF] = <span class="number">0.0</span>;
        stageValue[ENVELOPE_STAGE_ATTACK] = <span class="number">0.01</span>;
        stageValue[ENVELOPE_STAGE_DECAY] = <span class="number">0.5</span>;
        stageValue[ENVELOPE_STAGE_SUSTAIN] = <span class="number">0.1</span>;
        stageValue[ENVELOPE_STAGE_RELEASE] = <span class="number">1.0</span>;
    };
<span class="keyword">private</span>:
    EnvelopeStage currentStage;
    <span class="keyword">double</span> currentLevel;
    <span class="keyword">double</span> multiplier;
    <span class="keyword">double</span> sampleRate;
    <span class="keyword">double</span> stageValue[kNumEnvelopeStages];
    <span class="keyword">void</span> calculateMultiplier(<span class="keyword">double</span> startLevel, <span class="keyword">double</span> endLevel, <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> lengthInSamples);
    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> currentSampleIndex;
    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> nextStageSampleIndex;
};
</code></pre> <p>First, we’re defining an <code>enum</code> with all the envelope stages. We add <code>kNumEnvelopeStages</code> at the end so we know how many stages there are. Note that we’re scoping the <code>enum</code> to the <code>EnvelopeGenerator</code> class. This means that it won’t go into the global namespace.<br>We’ll discuss the member functions when we implement them. <code>minimumLevel</code> is needed because the envelope calculations don’t work with an amplitude of zero. We initialize it to the very small value of <code>0.001</code>.<br>The initializer list makes sure that the envelope is in the <code>OFF</code> stage by default and initializes the <code>stageValue</code> array to some default values: Short attack, 0.5 seconds decay, quiet sustain, one second release.<br>In the <code>private</code> section, <code>currentStage</code> indicates what stage the envelope is currently in. <code>currentLevel</code> is the current envelope level that we’ll get on every sample. The <code>multiplier</code> is responsible for the exponential decay as <a href="/blog/articles/audio-plugins-011-envelopes/#decay_multiplier">described below</a>.<br>During <span class=caps>ATTACK</span>, <span class=caps>DECAY</span> and <span class=caps>RELEASE</span>, the generator has to keep track of where it currently is so it can enter the next stage after a given time (i.e. after the transition is finished). Instead of comparing some <code>double</code> value, we’re using a <code>currentSampleIndex</code>. Open <em>EnvelopeGenerator.cpp</em> and add the following&nbsp;implementation:</p> <pre><code class="lang-cpp"><span class="keyword">double</span> EnvelopeGenerator::nextSample() {
    <span class="keyword">if</span> (currentStage != ENVELOPE_STAGE_OFF &amp;&amp;
        currentStage != ENVELOPE_STAGE_SUSTAIN) {
        <span class="keyword">if</span> (currentSampleIndex == nextStageSampleIndex) {
            EnvelopeStage newStage = <span class="keyword">static_cast</span>&lt;EnvelopeStage&gt;(
                (currentStage + <span class="number">1</span>) % kNumEnvelopeStages
            );
            enterStage(newStage);
        }
        currentLevel *= multiplier;
        currentSampleIndex++;
    }
    <span class="keyword">return</span> currentLevel;
}
</code></pre> <p>If the generator is in <span class=caps>ATTACK</span>, <span class=caps>DECAY</span> or <span class=caps>RELEASE</span> stage and the <code>currentSampleIndex</code> has reached the value of <code>nextStageSampleIndex</code>, we just get the next item from the <code>EnvelopeStage</code> <code>enum</code>. Because of the modulo operator, it will go back to <code>ENVELOPE_STAGE_OFF</code> after <code>ENVELOPE_STAGE_RELEASE</code> (which is what we want). Finally, we call <code>enterStage</code> to go into the next stage.<br>We then modify the <code>currentLevel</code> and increment the <code>currentSampleIndex</code> to keep track of time. Note that this doesn’t happen in the <span class=caps>OFF</span> and <span class=caps>SUSTAIN</span> stages: In these stages the level must stay the same, so there’s no need to calculate. The same goes for <code>currentSampleIndex</code>: The <span class=caps>OFF</span> and <span class=caps>SUSTAIN</span> stages don’t expire after a given time, so the generator doesn’t have to check if they are&nbsp;over.</p> <p><a name=decay_multiplier></a></p> <h2 id=transitions-over-time>Transitions Over&nbsp;Time</h2> <p>In the <span class=caps>ATTACK</span>, <span class=caps>DECAY</span> and <span class=caps>RELEASE</span> stage, the generator transitions between two values over a given amount of time. Our ear perceives volume <a href="http://en.wikibooks.org/wiki/Engineering_Acoustics/The_Human_Ear_and_Sound_Perception">in a <em>logarithmic</em> way</a>. So in order to <em>hear</em> a volume change as linear, it has to be <em>exponential</em>.<br>There are different ways to calculate an exponential curve between two points. The most intuitive would be to call <code>exp</code> (from <code>&lt;cmath&gt;</code>) on every sample. However, there’s a smarter way that calculates a multiplier based on the two values and the given time. On every sample, the current envelope value is multiplied with this value.<br>Implement the following function to calculate the value (it’s based on Christian Schoenebeck’s <a href="http://www.musicdsp.org/showone.php?id=189">Fast Exponential Envelope Generator</a>):</p> <pre><code class="lang-cpp"><span class="keyword">void</span> EnvelopeGenerator::calculateMultiplier(<span class="keyword">double</span> startLevel,
                                            <span class="keyword">double</span> endLevel,
                                            <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> lengthInSamples) {
    multiplier = <span class="number">1.0</span> + (<span class="built_in">log</span>(endLevel) - <span class="built_in">log</span>(startLevel)) / (lengthInSamples);
}
</code></pre> <p>At this point it’s not that important to fully understand the equation. Just be aware that this function takes <code>startLevel</code>, <code>endLevel</code> and the transition’s <code>lengthInSamples</code> and calculates a <code>multiplier</code> that will be a number slightly below or slightly above 1. We’ll multiply <code>currentLevel</code> with this to get an exponential transition. By the way, <code>log()</code> is the <em>natural</em> logarithm.</p> <h2 id=changing-envelope-stages>Changing Envelope&nbsp;Stages</h2> <p>Now that we know how to calculate the <code>multiplier</code>, let’s implement <code>enterStage</code>:</p> <pre><code class="lang-cpp"><span class="keyword">void</span> EnvelopeGenerator::enterStage(EnvelopeStage newStage) {
    currentStage = newStage;
    currentSampleIndex = <span class="number">0</span>;
    <span class="keyword">if</span> (currentStage == ENVELOPE_STAGE_OFF ||
        currentStage == ENVELOPE_STAGE_SUSTAIN) {
        nextStageSampleIndex = <span class="number">0</span>;
    } <span class="keyword">else</span> {
        nextStageSampleIndex = stageValue[currentStage] * sampleRate;
    }
    <span class="keyword">switch</span> (newStage) {
        <span class="keyword">case</span> ENVELOPE_STAGE_OFF:
            currentLevel = <span class="number">0.0</span>;
            multiplier = <span class="number">1.0</span>;
            <span class="keyword">break</span>;
        <span class="keyword">case</span> ENVELOPE_STAGE_ATTACK:
            currentLevel = minimumLevel;
            calculateMultiplier(currentLevel,
                                <span class="number">1.0</span>,
                                nextStageSampleIndex);
            <span class="keyword">break</span>;
        <span class="keyword">case</span> ENVELOPE_STAGE_DECAY:
            currentLevel = <span class="number">1.0</span>;
            calculateMultiplier(currentLevel,
                                fmax(stageValue[ENVELOPE_STAGE_SUSTAIN], minimumLevel),
                                nextStageSampleIndex);
            <span class="keyword">break</span>;
        <span class="keyword">case</span> ENVELOPE_STAGE_SUSTAIN:
            currentLevel = stageValue[ENVELOPE_STAGE_SUSTAIN];
            multiplier = <span class="number">1.0</span>;
            <span class="keyword">break</span>;
        <span class="keyword">case</span> ENVELOPE_STAGE_RELEASE:
            <span class="comment">// We could go from <span class="caps">ATTACK</span>/<span class="caps">DECAY</span> to <span class="caps">RELEASE</span>,</span>
            <span class="comment">// so we're not changing currentLevel here.</span>
            calculateMultiplier(currentLevel,
                                minimumLevel,
                                nextStageSampleIndex);
            <span class="keyword">break</span>;
        <span class="keyword">default</span>:
            <span class="keyword">break</span>;
    }
}
</code></pre> <p>After updating <code>currentStage</code> to the new value, we make sure that <code>currentSampleIndex</code> starts counting from zero again. Then we calculate how long (i.e. <em>how many samples</em>) it will take until the next stage. As already mentioned, this is only needed for the <span class=caps>ATTACK</span>, <span class=caps>DECAY</span> and <span class=caps>RELEASE</span> stages. Since <code>stageValue[currentStage]</code> gives us a <code>double</code> value (the stage duration in seconds), we multiply with sampleRate to get the stage length <em>in samples</em>.<br>The <code>switch</code> branches between the possible stages. In the <span class=caps>OFF</span> case, we just set the level to zero and the multiplier to one (actually we don’t <em>have</em> to do that, but to me it looks more consistent). For <span class=caps>ATTACK</span>, we make sure to start from the very silent <code>minimumLevel</code> and we calculate the multiplier, so the transition will be from the currentLevel to <code>1.0</code>. For <span class=caps>DECAY</span>, we let the level fall from the current value to the sustain level (<code>stageValue[ENVELOPE_STAGE_SUSTAIN]</code>), but using <code>fmax</code> we make sure that it doesn’t reach zero. The <span class=caps>RELEASE</span> stage decays from the <code>currentLevel</code> (whatever that is) to the <code>minimumLevel</code>. As explained by the comment, we’re not changing <code>currentLevel</code> here because we don’t know from which stage and level it is entering <span class=caps>RELEASE</span> stage.<br>The <span class=caps>SUSTAIN</span> stage is a special case. As already mentioned, <code>stageValue[ENVELOPE_STAGE_SUSTAIN]</code> holds a <em>level</em> value, not a <em>time</em> value. So we just assign that to <code>currentLevel</code>.</p> <h2 id=a-first-test>A First&nbsp;Test</h2> <p>Add the (simple) implementation for <code>setSampleRate</code>:</p> <pre><code class="lang-cpp"><span class="keyword">void</span> EnvelopeGenerator::setSampleRate(<span class="keyword">double</span> newSampleRate) {
    sampleRate = newSampleRate;
}
</code></pre> <p>Add a <code>private</code> member to the <code>Synthesis</code> class (in <em>Synthesis.h</em>):</p> <pre><code class="lang-cpp">EnvelopeGenerator mEnvelopeGenerator;
</code></pre> <p>Make sure you also <code>#include &quot;EnvelopeGenerator.h&quot;</code> before the class declaration.<br><a name=envelope_looping></a> In <em>Synthesis.cpp</em>, replace the <code>leftOutput[i]</code> line in <code>ProcessDoubleReplacing</code> with the&nbsp;following:</p> <pre><code class="lang-cpp"><span class="comment">// leftOutput[i] = rightOutput[i] = mOscillator.nextSample() * velocity / 127.0;</span>
<span class="keyword">if</span> (mEnvelopeGenerator.getCurrentStage() == EnvelopeGenerator::ENVELOPE_STAGE_OFF) {
    mEnvelopeGenerator.enterStage(EnvelopeGenerator::ENVELOPE_STAGE_ATTACK);
}
<span class="keyword">if</span> (mEnvelopeGenerator.getCurrentStage() == EnvelopeGenerator::ENVELOPE_STAGE_SUSTAIN) {
    mEnvelopeGenerator.enterStage(EnvelopeGenerator::ENVELOPE_STAGE_RELEASE);
}
leftOutput[i] = rightOutput[i] = mOscillator.nextSample() * mEnvelopeGenerator.nextSample() * velocity / <span class="number">127.0</span>;
</code></pre> <p>The code is for testing purposes: The two <code>if</code> statements make the envelope generator go automatically from <span class=caps>OFF</span> to <span class=caps>ATTACK</span> stage and from <span class=caps>SUSTAIN</span> to <span class=caps>RELEASE</span> stage. This means that it will loop indefinitely. Every sample is multiplied with the current envelope generator value.<br>When the sample rate is set, <code>mEnvelopeGenerator</code> has to be notified. Add the following line to <code>Synthesis::Reset()</code>:</p> <pre><code class="lang-cpp">mEnvelopeGenerator.setSampleRate(GetSampleRate());
</code></pre> <p>We’re now ready to test this! Run your plugin and hold a note on the virtual keyboard. Keep the mouse button pressed and you’ll hear that the generator keeps looping through the stages. Great!</p> <h2 id=triggering-with-note-on-off>Triggering with Note&nbsp;On/Off</h2> <p>A looping envelope is nice (maybe we’ll need this later), but right now we want the behaviour we know from classic synthesizers: When we play a key, it should start the <span class=caps>ATTACK</span> stage. When we release the key, it should go into <span class=caps>RELEASE</span> and fade out. The <code>mMIDIReceiver</code> knows about note on/off, so we have to somehow connect it to <code>mEnvelopeGenerator</code>.</p> <p><a name=avoiding_coupling></a> A simple way to do this would be to <code>#include EnvelopeGenerator.h</code> in <em>MIDIReceiver.h</em>. We could then pass a reference to <code>mEnvelopeGenerator</code> from <em>Synthesis.h</em>, so <code>mMIDIReceiver</code> can access it. The <span class=caps>MIDI</span> receiver would then just call <code>enterStage</code> whenever it gets a note on/off message.<br>This is a bad idea because it makes <code>MIDIReceiver</code> depend on an <code>EnvelopeGenerator</code> instance. We want to have a clean separation between components: If we some day write a pure <span class=caps>MIDI</span> plugin without envelopes, we want to use the <code>MIDIReceiver</code> class without depending on <em>EnvelopeGenerator.h</em>.</p> <p><a name=signals_slots></a> A better approach is to use <a href="http://qt-project.org/doc/qt-5.0/qtcore/signalsandslots.html">Signals and Slots</a>. The pattern comes from the Qt framework. It can be used to connect a button to a text field, <em>without the two knowing each other</em>. When the button is clicked, it emits a <em>signal</em>. This signal can be connected to a <em>slot</em> on the text field, such as <code>setText()</code>. So when you click the button, the text changes. It’s important to know that the button’s signal doesn’t care if any (or how many) slots are connected. Whatever’s connected gets notified. We can use this pattern to connect the different components in our plugin (<code>Oscillator</code>, <code>EnvelopeGenerator</code>, <code>MIDIReceiver</code>). The connection will be done <em>from outside</em>, i.e. from the <code>Synthesis</code> class.</p> <p>We won’t use the Qt framework just to get this one feature. We’ll use Patrick Hogan’s <a href="https://github.com/pbhogan/Signals">Signals</a> library. Download and extract it. Now rename <em>Signal.h</em> to <em>GallantSignal.h</em> (this is to avoid name clashes). Drag the <em>Delegate.h</em> and <em>GallantSignal.h</em> into your project, making sure to <em>“Copy items into destination group’s folder”</em>, and add them to all&nbsp;targets.</p> <p>We want the <code>MIDIReceiver</code> to emit a signal whenever a note is pressed, and whenever it is released. Add the following above the class definition in <em>MIDIReceiver.h</em>:</p> <pre><code class="lang-cpp"><span class="preprocessor">#include "GallantSignal.h"</span>
<span class="keyword">using</span> Gallant::Signal2;
</code></pre> <p><code>Signal2</code> is a signal that passes two parameters. There’s <code>Signal0</code> through <code>Signal8</code>, so you can choose depending on how many parameters you need. Add the following to the <code>public</code> section:</p> <pre><code class="lang-cpp">Signal2&lt; <span class="keyword">int</span>, <span class="keyword">int</span> &gt; noteOn;
Signal2&lt; <span class="keyword">int</span>, <span class="keyword">int</span> &gt; noteOff;
</code></pre> <p>As you can see, both signals will pass two <code>int</code>s. Go into <em>MIDIReceiver.cpp</em> and modify the following parts of the <code>advance</code> function:</p> <pre><code class="lang-cpp"><span class="comment">// A key pressed later overrides any previously pressed key:</span>
<span class="keyword">if</span> (noteNumber != mLastNoteNumber) {
    mLastNoteNumber = noteNumber;
    mLastFrequency = noteNumberToFrequency(mLastNoteNumber);
    mLastVelocity = velocity;
    <span class="comment">// Emit a "note on" signal:</span>
    noteOn(noteNumber, velocity);
}
</code></pre> <p><a name=no_longer_resetting_velocity></a></p> <pre><code class="lang-cpp"><span class="comment">// If the last note was released, nothing should play:</span>
<span class="keyword">if</span> (noteNumber == mLastNoteNumber) {
    mLastNoteNumber = -<span class="number">1</span>;
    noteOff(noteNumber, mLastVelocity);
}
</code></pre> <p>As you can see, the first argument is the note number and the second one is the velocity. We’re no longer setting <code>mLastFrequency</code> to <code>-1</code> when a key is released: During the <span class=caps>RELEASE</span> stage we still need the frequency to fade out. The same goes for <code>mLastVelocity</code>: If we set it to zero, the sound will cut off immediately.<br>Note that the code still runs even though we haven’t connected any slot to the signals! The beauty of the signal/slot system is to keep components&nbsp;independent.</p> <p>The next step is to connect <code>mEnvelopeGenerator</code> to the two signals. We could add the member functions <code>onNoteOn</code> and <code>onNoteOff</code> to the <code>EnvelopeGenerator</code> class and connect them to the signals. Not a bad solution, but it clutters the <code>EnvelopeGenerator</code> with the concept of <em>notes</em>. In my opinion, it shouldn’t know about this. Also we can’t connect the signals directly to <code>enterStage</code> because the arguments don’t match. So let’s add the member functions to the <code>Synthesis</code> class (in the <code>private</code> section):</p> <pre><code class="lang-cpp"><span class="keyword">inline</span> <span class="keyword">void</span> onNoteOn(<span class="keyword">const</span> <span class="keyword">int</span> noteNumber, <span class="keyword">const</span> <span class="keyword">int</span> velocity) { mEnvelopeGenerator.enterStage(EnvelopeGenerator::ENVELOPE_STAGE_ATTACK); };
<span class="keyword">inline</span> <span class="keyword">void</span> onNoteOff(<span class="keyword">const</span> <span class="keyword">int</span> noteNumber, <span class="keyword">const</span> <span class="keyword">int</span> velocity) { mEnvelopeGenerator.enterStage(EnvelopeGenerator::ENVELOPE_STAGE_RELEASE); };
</code></pre> <p>Note that the arguments match <code>noteOn</code> and <code>noteOff</code>.<br>To connect to the signals, add the following at the end of the constructor (in <em>Synthesis.cpp</em>):</p> <pre><code class="lang-cpp">mMIDIReceiver.noteOn.Connect(<span class="keyword">this</span>, &amp;Synthesis::onNoteOn);
mMIDIReceiver.noteOff.Connect(<span class="keyword">this</span>, &amp;Synthesis::onNoteOff);
</code></pre> <p>The first argument is a pointer to the instance, the second one points to the member function.<br>We can now change <code>ProcessDoubleReplacing</code> and remove the envelope looping. Delete the two <code>if</code> statements we <a href="/blog/articles/audio-plugins-011-envelopes/#envelope_looping">added before</a> (but keep the line that generates the audio&nbsp;samples).</p> <h2 id=it-s-done->It’s&nbsp;done!</h2> <p>Run the plugin again. It should retrigger the envelope whenever you press a key. Also it should keep the sustain level as long as you hold the key. Try releasing a key during the <span class=caps>DECAY</span> stage: It should go into <span class=caps>RELEASE</span> and fade out from the current level. Try setting some different initial <code>stageValue</code>s inside <em>EnvelopeGenerator.h</em> to get different timbres.<br>Now if there was a way to change these values in realtime with some nice knobs, something like&nbsp;this:</p> <p><a href="/blog/articles/audio-plugins-012-envelopes-gui/gui.png"><img src="/blog/articles/audio-plugins-012-envelopes-gui/gui.png" alt=""></a></p> <p>Let’s <a href="/blog/articles/audio-plugins-012-envelopes-gui/">make it happen</a>!</p> <p>The source files for this part can be downloaded <a href="/blog/articles/audio-plugins-011-envelopes/source.zip">here</a>.</p> </section> </article> <div id=donation_prompt>If you found this useful, please feel free to <form action="https://www.paypal.com/cgi-bin/webscr" method=post target=_top class=donation-form> <input type=hidden name=cmd value=_s-xclick> <input type=hidden name=hosted_button_id value=JQDU8W5PJBWL6> <input type=hidden name=ref value="/blog/articles/audio-plugins-011-envelopes/"> <input type=image src="https://www.paypalobjects.com/en_US/i/btn/btn_donate_SM.gif" border=0 name=submit alt="PayPal - The safer, easier way to pay online!"><img alt="" border=0 src="https://www.paypalobjects.com/de_DE/i/scr/pixel.gif" width=1 height=1> </form>! </div> <iframe src="//www.facebook.com/plugins/like.php?href=http%3A%2F%2Fwww.martin-finke.de%2Fblog%2F&amp;width=450&amp;height=21&amp;colorscheme=light&amp;layout=button_count&amp;action=like&amp;show_faces=false&amp;send=false" scrolling=no frameborder=0 style="border: none; overflow: hidden; width: 200px; height: 21px;" allowtransparency=true></iframe> <div class=comments> <div id=disqus_thread></div> <script type="text/javascript">var disqus_shortname="martinfinke";(function(){var a=document.createElement("script");a.type="text/javascript";a.async=true;a.src="//"+disqus_shortname+".disqus.com/embed.js";(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(a)})();</script> <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript> <a href="http://disqus.com" class=dsq-brlink>comments powered by <span class=logo-disqus>| Disqus</span></a> </div> </div> </div> <footer> <div class=content-wrap> <div class=nav><a href="/blog/">« Index</a></div> <section class=copy> <p>&copy; 2015 Martin Finke – <a href="/blog/impressum.html" class=impressum-link>Impressum</a></p> </section> </div> </footer> <script src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script> <script>window.jQuery||document.write('<script src="/blog/js/vendor/jquery-1.10.2.min.js"><\/script>');</script> <script type="text/javascript">$(document).ready(function(){$('a:link[href^=http]:not([href*="martin-finke.de"])').attr("target","_blank")});</script> <script type="text/javascript">var _gaq=_gaq||[];_gaq.push(["_setAccount","UA-43375106-1"]);_gaq.push(["_trackPageview"]);(function(){var b=document.createElement("script");b.type="text/javascript";b.async=true;b.src=("https:"==document.location.protocol?"https://":"http://")+"stats.g.doubleclick.net/dc.js";var a=document.getElementsByTagName("script")[0];a.parentNode.insertBefore(b,a)})();</script> </body> </html>