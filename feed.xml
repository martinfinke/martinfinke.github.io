<?xml version="1.0" encoding="utf-8" ?>
<rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:wfw="http://wellformedweb.org/CommentAPI/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Martin Finke's Blog</title>
    <atom:link href="http://www.martin-finke.de/blog/feed.xml" rel="self" type="application/rss+xml"></atom:link>
    <link>http://www.martin-finke.de</link>
    <description>Music &amp; Programming</description>
    <pubDate>Sat, 26 Oct 2013 15:58:00 +0200</pubDate>
    <generator>Wintersmith - https://github.com/jnordberg/wintersmith</generator>
    <language>en</language>
    <item>
      <title>Making Audio Plugins Part 18: PolyBLEP Oscillator</title>
      <link>http://www.martin-finke.de/blog/articles/audio-plugins-018-polyblep-oscillator/</link>
      <pubDate>Sat, 26 Oct 2013 15:58:00 +0200</pubDate>
      <guid isPermaLink="true">http://www.martin-finke.de/blog/articles/audio-plugins-018-polyblep-oscillator/</guid>
      <author></author>
      <description>&lt;p&gt;Let’s create an oscillator with much less aliasing! &lt;span class=&quot;more&quot;&gt;&lt;/span&gt;
This is an &lt;em&gt;optional&lt;/em&gt; improvement, you don’t have to do it. Our &lt;em&gt;SpaceBass&lt;/em&gt; synth will work the same as before, but it will sound much better in higher octaves.&lt;/p&gt;
&lt;h2 id=&quot;analyzing-the-spectrum&quot;&gt;Analyzing the Spectrum&lt;/h2&gt;
&lt;p&gt;I’d like to introduce a very good free plugin: &lt;a href=&quot;http://www.voxengo.com/product/span/&quot;&gt;Voxengo SPAN&lt;/a&gt;. Basically you can insert it on a track, and it will show you the spectrum of the signal going through it. We’re not quite ready to write our own &lt;a href=&quot;http://en.wikipedia.org/wiki/Fast_Fourier_transform&quot;&gt;FFT&lt;/a&gt; testing routines, so this will be indispensable to compare different algorithms and see what’s going on.&lt;br&gt;Download and install it. Run the &lt;em&gt;SpaceBass&lt;/em&gt; plugin in REAPER, open its GUI and make sure that:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The oscillator &lt;em&gt;Mix&lt;/em&gt; knob is turned all the way to the left (so you only hear oscillator 1)&lt;/li&gt;
&lt;li&gt;Oscillator 1 is set to the &lt;em&gt;square&lt;/em&gt; waveform&lt;/li&gt;
&lt;li&gt;Filter cutoff is at max, resonance at min&lt;/li&gt;
&lt;li&gt;Filter LFO amount is at min, env amount is in central position&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;With these settings, you can hear the raw waveform of oscillator 1. Now insert the &lt;em&gt;SPAN&lt;/em&gt; plugin right after &lt;em&gt;SpaceBass&lt;/em&gt;. Play a fairly high note (I used A6), and you should see something like this:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/blog/articles/audio-plugins-018-polyblep-oscillator/square_aliased.png&quot;&gt;&lt;img src=&quot;/blog/articles/audio-plugins-018-polyblep-oscillator/square_aliased.png&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Here’s how to read this graph: The x axis is the frequency (in Hz), going from 66 Hz to 20 kHz here. The spacing is &lt;em&gt;logarithmic&lt;/em&gt;, which just means that the space between octaves is always the same: The gap between C1 and C2 is the same as the gap between C7 and C8. Octaves have a ratio of &lt;em&gt;times two&lt;/em&gt;, but harmonics are just &lt;em&gt;multiples&lt;/em&gt; of the fundamental frequency. This means that harmonics are &lt;em&gt;not&lt;/em&gt; spaced evenly in the graph. The y axis is the amplitude (in decibels). So you can see at a glance which frequencies are currently present in the signal.&lt;br&gt;Depending on your settings, it may look a little different, but it’s clear that there’s something wrong: For a square wave, you’d expect a series of peaks that decrease in volume (the higher the frequency), with &lt;em&gt;nothing in between&lt;/em&gt;. Especially not below the fundamental (i.e. in the left portion of the above image). As &lt;a href=&quot;http://www.martin-finke.de/articles/audio-plugins-008-synthesizing-waveforms/#aliasing&quot;&gt;described before&lt;/a&gt;, this is called &lt;em&gt;Aliasing&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;So what do we do about it? There are different solutions. You get the best results by synthesizing a &lt;a href=&quot;http://en.wikipedia.org/wiki/Fourier_series&quot;&gt;Fourier series&lt;/a&gt; to approximate the square waveform. This just means that you layer sine waves with the correct amplitudes (starting at the fundamental, and one for each harmonic), &lt;em&gt;but you stop when you reach the nyquist frequency&lt;/em&gt;. This additive approach would give a perfectly &lt;em&gt;bandlimited&lt;/em&gt; waveform (i.e. one that only has spectral content from the fundamental to the nyquist frequency).&lt;br&gt;Of course there’s a catch. This method may be good for high octaves (where the fundamental is so high that there aren’t many harmonics until the nyquist frequency). But for low octaves you have to layer &lt;em&gt;a lot&lt;/em&gt; of sine waves: If you’re working at a sample rate of 44.1 kHz, a saw wave with a fundamental of 100 Hz will have 219 harmonics until the nyquist, so you’d have to calculate a total of 220 &lt;code&gt;sin()&lt;/code&gt; values every sample. Of course, in a polyphonic synth, multiply this by the number of notes being played.&lt;br&gt;You could argue that you only have to do the layering once for every played note. This is true as long as you don’t have any pitch modulation. With pitch modulation, the frequency can change &lt;em&gt;every sample&lt;/em&gt;, so it’d be a lot of work to layer the sine waves again and again.&lt;/p&gt;
&lt;h2 id=&quot;blips-and-bleps&quot;&gt;BLIPs and BLEPs&lt;/h2&gt;
&lt;p&gt;There are other approaches, most notably:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://ccrma.stanford.edu/~stilti/papers/blit.pdf&quot;&gt;&lt;em&gt;Bandlimited Impulse Train (BLIT)&lt;/em&gt;&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cs.cmu.edu/~eli/papers/icmc01-hardsync.pdf&quot;&gt;&lt;em&gt;Minimum-Phase Bandlimited Step (MinBLEP)&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.kvraudio.com/forum/viewtopic.php?t=375517&quot;&gt;&lt;em&gt;Polynomial Bandlimited Step (PolyBLEP)&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The two &lt;em&gt;BLEP&lt;/em&gt; approaches are based on the fact that the aliasing is only caused by the sharp jumps in the waveform. With the waveforms we currently have, only the sharp edges are the problem. So can we just round them like a piece of wood? Just rounding the edges would be equivalent to gentle low-pass filtering, which is not what we want. We want no filtering up to the nyquist frequency, and nothing above that. We want the same result as if we had layered sine waves.&lt;br&gt;A square wave created from sine waves looks like this:
&lt;a href=&quot;/blog/articles/audio-plugins-018-polyblep-oscillator/Fourier_series_and_transform.gif&quot;&gt;&lt;img src=&quot;/blog/articles/audio-plugins-018-polyblep-oscillator/Fourier_series_and_transform.gif&quot; alt=&quot;&quot;&gt;&lt;/a&gt;
The blue parts are the sine waves that are layered, the red part is the resulting bandlimited square wave. As you can see, it’s not just a square with rounded edges. It has these characteristic &lt;em&gt;ripples&lt;/em&gt;.&lt;br&gt;In simple terms, the two &lt;em&gt;BLEP&lt;/em&gt; approaches first generate a waveform &lt;a href=&quot;http://www.martin-finke.de/articles/audio-plugins-008-synthesizing-waveforms/&quot;&gt;just like we did&lt;/a&gt;, and then layer the ripples on top. Doing that removes (or greatly reduces) the aliasing.&lt;/p&gt;
&lt;p&gt;If you’ve visited the links above, you’re maybe guessing that the PolyBLEP approach is the easiest to use. In that case, your intuition is spot-on, and that’s why we’re going to use PolyBLEPs!&lt;/p&gt;
&lt;h2 id=&quot;the-polybleposcillator-class&quot;&gt;The PolyBLEPOscillator Class&lt;/h2&gt;
&lt;p&gt;A &lt;code&gt;PolyBLEPOscillator&lt;/code&gt; &lt;a href=&quot;http://en.wikipedia.org/wiki/Is-a&quot;&gt;is a&lt;/a&gt;n &lt;code&gt;Oscillator&lt;/code&gt;, so we will use &lt;a href=&quot;http://www.learncpp.com/cpp-tutorial/115-inheritance-and-access-specifiers/&quot;&gt;public inheritance&lt;/a&gt;. &lt;code&gt;Oscillator&lt;/code&gt; will be the base class, and it’ll take care of:&lt;/p&gt;
&lt;p&gt;In the &lt;em&gt;SpaceBass&lt;/em&gt; project, create a new class called &lt;em&gt;PolyBLEPOscillator&lt;/em&gt; and add it to all targets. If you didn’t follow the previous posts or don’t have the project, feel free to &lt;a href=&quot;/blog/articles/audio-plugins-018-polyblep-oscillator/SpaceBass_before.zip&quot;&gt;download it&lt;/a&gt; and start from there.&lt;/p&gt;
&lt;p&gt;This is the class definition:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#include &quot;Oscillator.h&quot;&lt;/span&gt;

&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; PolyBLEPOscillator: &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; Oscillator {
&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:
    PolyBLEPOscillator() : lastOutput(&lt;span class=&quot;number&quot;&gt;0.0&lt;/span&gt;) { updateIncrement(); };
    &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; nextSample();
&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt;:
    &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; poly_blep(&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; t);
    &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; lastOutput;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We’re inheriting publicly from &lt;code&gt;Oscillator&lt;/code&gt;. To override how waveforms are calculated, we define a new &lt;code&gt;nextSample&lt;/code&gt; member function (more on that later). We add another &lt;code&gt;private&lt;/code&gt; function called &lt;code&gt;poly_blep&lt;/code&gt;, which will generate the ripples at the edges. The &lt;code&gt;lastOutput&lt;/code&gt; variable saves the last output value (this will only be needed for the triangle wave).&lt;br&gt;In &lt;em&gt;PolyBLEPOscillator.cpp&lt;/em&gt;, add the implementation for &lt;code&gt;poly_blep&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// PolyBLEP by Tale&lt;/span&gt;
&lt;span class=&quot;comment&quot;&gt;// (slightly modified)&lt;/span&gt;
&lt;span class=&quot;comment&quot;&gt;// http://www.kvraudio.com/forum/viewtopic.php?t=375517&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; PolyBLEPOscillator::poly_blep(&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; t)
{
    &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; dt = mPhaseIncrement / twoPI;
    &lt;span class=&quot;comment&quot;&gt;// 0 &amp;lt;= t &amp;lt; 1&lt;/span&gt;
    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (t &amp;lt; dt) {
        t /= dt;
        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; t+t - t*t - &lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;;
    }
    &lt;span class=&quot;comment&quot;&gt;// -1 &amp;lt; t &amp;lt; 0&lt;/span&gt;
    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (t &amp;gt; &lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt; - dt) {
        t = (t - &lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;) / dt;
        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; t*t + t+t + &lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;;
    }
    &lt;span class=&quot;comment&quot;&gt;// 0 otherwise&lt;/span&gt;
    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0.0&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The math may look complicated, but basically this function almost always &lt;code&gt;return&lt;/code&gt;s &lt;code&gt;0.0&lt;/code&gt;, except then we’re close to an edge. The first &lt;code&gt;if&lt;/code&gt; branch means that we’re at the beginning of a period, and the &lt;code&gt;else if&lt;/code&gt; means that we’re right before the end. This is the right behaviour for a saw wave, because in a saw wave there’s only one jump, which is between two periods.&lt;/p&gt;
&lt;p&gt;Before we can implement &lt;code&gt;nextSample&lt;/code&gt;, we have to make some changes to the &lt;code&gt;Oscillator&lt;/code&gt; class. In &lt;em&gt;Oscillator.h&lt;/em&gt;, make the &lt;code&gt;nextSample&lt;/code&gt; function &lt;code&gt;virtual&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; nextSample();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This means that we can override &lt;code&gt;nextSample&lt;/code&gt;‘s default behaviour in our subclass. Using &lt;code&gt;virtual&lt;/code&gt; in time-critical code isn’t the best solution performance-wise. You can avoid this by using templates (and still get away without duplicating code), but I want to keep things simple here and stick to the topic of synthesis.&lt;br&gt;Change the &lt;code&gt;private:&lt;/code&gt; to &lt;code&gt;protected:&lt;/code&gt;. This will allow access to things like &lt;code&gt;mPhase&lt;/code&gt; from &lt;code&gt;PolyBLEPOscillator&lt;/code&gt;s member functions.&lt;br&gt;As described above, we will reuse the (aliased) waveforms from &lt;code&gt;Oscillator&lt;/code&gt; as a starting point, and then layer &lt;code&gt;poly_blep&lt;/code&gt; on top. Right now, &lt;code&gt;nextSample&lt;/code&gt; calculates the waveform &lt;em&gt;and&lt;/em&gt; increments the &lt;code&gt;mPhase&lt;/code&gt;. We have to separate these two unrelated things. Add this &lt;code&gt;protected&lt;/code&gt; member function:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; naiveWaveformForMode(OscillatorMode mode);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This function will contain the (aliased) waveform generation code. &lt;em&gt;Naive&lt;/em&gt; in this case means that it generates the waveforms in a &lt;em&gt;naive&lt;/em&gt; and incorrect way, without caring about aliasing. Let’s go into &lt;em&gt;Oscillator.cpp&lt;/em&gt; and write it! (You don’t need to type this by hand, because it’s almost the same as &lt;code&gt;Oscillator::nextSample&lt;/code&gt;)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; Oscillator::naiveWaveformForMode(OscillatorMode mode) {
    &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; value;
    &lt;span class=&quot;keyword&quot;&gt;switch&lt;/span&gt; (mode) {
        &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; OSCILLATOR_MODE_SINE:
            value = &lt;span class=&quot;built_in&quot;&gt;sin&lt;/span&gt;(mPhase);
            &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;
        &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; OSCILLATOR_MODE_SAW:
            value = (&lt;span class=&quot;number&quot;&gt;2.0&lt;/span&gt; * mPhase / twoPI) - &lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;;
            &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;
        &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; OSCILLATOR_MODE_SQUARE:
            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (mPhase &amp;lt; mPI) {
                value = &lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;;
            } &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; {
                value = -&lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;;
            }
            &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;
        &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; OSCILLATOR_MODE_TRIANGLE:
            value = -&lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt; + (&lt;span class=&quot;number&quot;&gt;2.0&lt;/span&gt; * mPhase / twoPI);
            value = &lt;span class=&quot;number&quot;&gt;2.0&lt;/span&gt; * (&lt;span class=&quot;built_in&quot;&gt;fabs&lt;/span&gt;(value) - &lt;span class=&quot;number&quot;&gt;0.5&lt;/span&gt;);
            &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;
        &lt;span class=&quot;keyword&quot;&gt;default&lt;/span&gt;:
            &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;
    }
    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; value;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The two differences from &lt;code&gt;Oscillator::nextSample&lt;/code&gt; are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;We’re choosing the waveform based on the &lt;code&gt;mode&lt;/code&gt; parameter passed in from outside (instead of &lt;code&gt;mOscillatorMode&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;The saw wave is now upwards (instead of downwards)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Since this now contains all the code from &lt;code&gt;Oscillator::nextSample&lt;/code&gt;, we can replace &lt;code&gt;nextSample&lt;/code&gt; with this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; Oscillator::nextSample() {
    &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; value = naiveWaveformForMode(mOscillatorMode);
    mPhase += mPhaseIncrement;
    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (mPhase &amp;gt;= twoPI) {
        mPhase -= twoPI;
    }
    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; value;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It just calls &lt;code&gt;naiveWaveformForMode&lt;/code&gt; to calculate the waveform, and then increments the &lt;code&gt;mPhase&lt;/code&gt;.  &lt;/p&gt;
&lt;h2 id=&quot;generating-polyblep-waveforms&quot;&gt;Generating PolyBLEP Waveforms&lt;/h2&gt;
&lt;p&gt;Let’s go back to &lt;em&gt;PolyBLEPOscillator.cpp&lt;/em&gt; and implement &lt;code&gt;nextSample&lt;/code&gt;. Start with this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; PolyBLEPOscillator::nextSample() {
    &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; value = &lt;span class=&quot;number&quot;&gt;0.0&lt;/span&gt;;
    &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; t = mPhase / twoPI;

    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (mOscillatorMode == OSCILLATOR_MODE_SINE) {
        value = naiveWaveformForMode(OSCILLATOR_MODE_SINE);
    } &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (mOscillatorMode == OSCILLATOR_MODE_SAW) {
        value = naiveWaveformForMode(OSCILLATOR_MODE_SAW);
        value -= poly_blep(t);
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;t&lt;/code&gt; variable is needed for the way the &lt;code&gt;poly_blep&lt;/code&gt; function works. It’s the current phase divided by &lt;code&gt;twoPI&lt;/code&gt;, so it’s between &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;1&lt;/code&gt;. The &lt;code&gt;if&lt;/code&gt; statement distinguishes between the different waveforms. For the sine wave, we don’t have to worry about aliasing (because there are no harmonics), so we just use the naive waveform. For the saw wave, we first get the aliased waveform value from &lt;code&gt;Oscillator&lt;/code&gt;. We then layer the output of &lt;code&gt;poly_blep&lt;/code&gt; on top, and that’s it!&lt;br&gt;We will generate the triangle wave by first generating a square wave, and then &lt;em&gt;integrating it&lt;/em&gt;. We’re working with discrete samples, so &lt;em&gt;integrating&lt;/em&gt; just means &lt;em&gt;summing values&lt;/em&gt;. If you think about it, a square wave starts with all-one values, so summing these up gives a linear rise. After half a period, the square wave jumps to all-minus-one, so summing those means a linear decay. A triangle wave is just that: A linear rise followed by a linear decay, followed by a rise and so on.&lt;br&gt;With this in mind, we’ll make a square wave for both the square &lt;em&gt;and&lt;/em&gt; the triangle wave:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; {
        value = naiveWaveformForMode(OSCILLATOR_MODE_SQUARE);
        value += poly_blep(t);
        value -= poly_blep(&lt;span class=&quot;built_in&quot;&gt;fmod&lt;/span&gt;(t + &lt;span class=&quot;number&quot;&gt;0.5&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Again, we’re starting with the naive (aliased) waveform. This time, though, we’re adding &lt;em&gt;two&lt;/em&gt; PolyBLEPs! One at the start of a period, and the other offset by &lt;code&gt;0.5&lt;/code&gt; (i.e. half a period). If you picture a square wave, it’s clear why we need two: A square wave has two jumps per period, whereas a saw wave only has one.&lt;br&gt;The only one missing is the triangle! Add this (at the end of the &lt;code&gt;else&lt;/code&gt; block!):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (mOscillatorMode == OSCILLATOR_MODE_TRIANGLE) {
            &lt;span class=&quot;comment&quot;&gt;// Leaky integrator: y[n] = A * x[n] + (1 - A) * y[n-1]&lt;/span&gt;
            value = mPhaseIncrement * value + (&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; - mPhaseIncrement) * lastOutput;
            lastOutput = value;
        }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I wrote above that we just have to integrate the square wave. I &lt;strong&gt;don’t&lt;/strong&gt; encourage you to try that, because it will cause the waveform to become more and more offset into very large values (which could damage your speakers). Instead, we’re using a &lt;em&gt;leaky integrator&lt;/em&gt;. It adds the previous output, but multiplied by a value slightly below &lt;code&gt;1&lt;/code&gt;. This prevents the offset from accumulating.&lt;br&gt;Let’s round this off by adding the phase incrementation (this is the same as before):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;    }

    mPhase += mPhaseIncrement;
    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (mPhase &amp;gt;= twoPI) {
        mPhase -= twoPI;
    }
    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; value;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And just like that, the &lt;code&gt;PolyBLEPOscillator&lt;/code&gt; is finished!&lt;/p&gt;
&lt;h2 id=&quot;using-the-new-oscillator&quot;&gt;Using the new Oscillator&lt;/h2&gt;
&lt;p&gt;To use our shiny new &lt;code&gt;PolyBLEPOscillator&lt;/code&gt;, we just have to change a few lines in &lt;em&gt;Voice.h&lt;/em&gt;. Replace the &lt;code&gt;#include &amp;quot;Oscillator.h&amp;quot;&lt;/code&gt; with this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#include &quot;PolyBLEPOscillator.h&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the &lt;code&gt;private&lt;/code&gt; section, turn &lt;code&gt;mOscillatorOne&lt;/code&gt; and &lt;code&gt;mOscillatorTwo&lt;/code&gt; into &lt;code&gt;PolyBLEPOscillator&lt;/code&gt;s:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;PolyBLEPOscillator mOscillatorOne;
PolyBLEPOscillator mOscillatorTwo;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And that’s it! Run your plugin and have a look at the spectrum using SPAN. You’ll see that the aliasing is &lt;em&gt;greatly&lt;/em&gt; reduced. Here are some screenshots for comparison. You can click on them to toggle between the old &lt;code&gt;Oscillator&lt;/code&gt; and the new &lt;code&gt;PolyBLEPOscillator&lt;/code&gt;:&lt;/p&gt;
&lt;p&gt;&lt;a class=&quot;image-toggler&quot;&gt;&lt;span class=&quot;description&quot;&gt;&lt;code&gt;Oscillator&lt;/code&gt; Saw (aliased):&lt;/span&gt;
&lt;img src=&quot;/blog/articles/audio-plugins-018-polyblep-oscillator/saw_aliased.png&quot; alt=&quot;&quot;&gt;
&lt;span class=&quot;description&quot;&gt;&lt;code&gt;PolyBLEPOscillator&lt;/code&gt; Saw:&lt;/span&gt;
&lt;img src=&quot;/blog/articles/audio-plugins-018-polyblep-oscillator/saw_polyblep.png&quot; alt=&quot;&quot;&gt;
&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&quot;image-toggler&quot;&gt;&lt;span class=&quot;description&quot;&gt;&lt;code&gt;Oscillator&lt;/code&gt; Square (aliased):&lt;/span&gt;
&lt;img src=&quot;/blog/articles/audio-plugins-018-polyblep-oscillator/square_aliased.png&quot; alt=&quot;&quot;&gt;
&lt;span class=&quot;description&quot;&gt;&lt;code&gt;PolyBLEPOscillator&lt;/code&gt; Square:&lt;/span&gt;
&lt;img src=&quot;/blog/articles/audio-plugins-018-polyblep-oscillator/square_polyblep.png&quot; alt=&quot;&quot;&gt;
&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&quot;image-toggler&quot;&gt;&lt;span class=&quot;description&quot;&gt;&lt;code&gt;Oscillator&lt;/code&gt; Triangle (aliased):&lt;/span&gt;
&lt;img src=&quot;/blog/articles/audio-plugins-018-polyblep-oscillator/triangle_aliased.png&quot; alt=&quot;&quot;&gt;
&lt;span class=&quot;description&quot;&gt;&lt;code&gt;PolyBLEPOscillator&lt;/code&gt; Triangle:&lt;/span&gt;
&lt;img src=&quot;/blog/articles/audio-plugins-018-polyblep-oscillator/triangle_polyblep.png&quot; alt=&quot;&quot;&gt;
&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;so-what-about-the-lfo-&quot;&gt;So what about the LFO?&lt;/h2&gt;
&lt;p&gt;But we’re still using the old &lt;code&gt;Oscillator&lt;/code&gt; for the LFO! Should we use the &lt;code&gt;PolyBLEPOscillator&lt;/code&gt; instead? Well, in an LFO you actually &lt;em&gt;want&lt;/em&gt; the sharp edges, they can be handy for crazy sound effects. And the aliasing concern doesn’t really matter here because an LFO’s fundamental is usually very low (below 30 Hz). Each harmonic has a lower amplitude than the one below it, so the harmonics above the nyquist frequency have a &lt;em&gt;very&lt;/em&gt; low amplitude.&lt;/p&gt;
&lt;h2 id=&quot;summary&quot;&gt;Summary&lt;/h2&gt;
&lt;p&gt;We have generated anti-aliased saw and square waveforms from the aliasing counterparts by layering PolyBLEPs on top. We have generated the triangle wave by (leaky) integrating the anti-aliased square wave. We can now happily play our synth even at very high octaves without getting nasty unharmonic frequencies! You can download the source code &lt;a href=&quot;/blog/articles/audio-plugins-018-polyblep-oscillator/source.zip&quot;&gt;here&lt;/a&gt;. Thanks for joining in and see you next time!&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Making Audio Plugins Part 17: Polyphony Part II</title>
      <link>http://www.martin-finke.de/blog/articles/audio-plugins-017-polyphony-ii/</link>
      <pubDate>Sun, 13 Oct 2013 20:44:00 +0200</pubDate>
      <guid isPermaLink="true">http://www.martin-finke.de/blog/articles/audio-plugins-017-polyphony-ii/</guid>
      <author></author>
      <description>&lt;p&gt;In this post we’ll finish polyphony by cleaning up and making our knobs work again. &lt;span class=&quot;more&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;spring-cleaning&quot;&gt;Spring Cleaning&lt;/h2&gt;
&lt;p&gt;Let’s begin with the &lt;code&gt;MIDIReceiver&lt;/code&gt;. We’re now polyphonic, so there’s no need for the &lt;code&gt;mLast&lt;/code&gt; variables anymore. In &lt;em&gt;MIDIReceiver.h&lt;/em&gt;, remove &lt;code&gt;mLastNoteNumber&lt;/code&gt;, &lt;code&gt;mLastFrequency&lt;/code&gt; and &lt;code&gt;mLastVelocity&lt;/code&gt;, including their initializations and getter functions, i.e. &lt;code&gt;getLastNoteNumber&lt;/code&gt;, &lt;code&gt;getLastFrequency&lt;/code&gt; and &lt;code&gt;getLastVelocity&lt;/code&gt;. Also remove the &lt;code&gt;noteNumberToFrequency&lt;/code&gt; member function. Just for confirmation, the class now looks like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; MIDIReceiver {
&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt;:
    IMidiQueue mMidiQueue;
    &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; keyCount = &lt;span class=&quot;number&quot;&gt;128&lt;/span&gt;;
    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; mNumKeys; &lt;span class=&quot;comment&quot;&gt;// how many keys are being played at the moment (via midi)&lt;/span&gt;
    &lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt; mKeyStatus[keyCount]; &lt;span class=&quot;comment&quot;&gt;// array of on/off for each key (index is note number)&lt;/span&gt;
    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; mOffset;

&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:
    MIDIReceiver() :
    mNumKeys(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;),
    mOffset(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) {
        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; keyCount; i++) {
            mKeyStatus[i] = &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;;
        }
    };

    &lt;span class=&quot;comment&quot;&gt;// Returns true if the key with a given index is currently pressed&lt;/span&gt;
    &lt;span class=&quot;keyword&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt; getKeyStatus(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; keyIndex) &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; { &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; mKeyStatus[keyIndex]; }
    &lt;span class=&quot;comment&quot;&gt;// Returns the number of keys currently pressed&lt;/span&gt;
    &lt;span class=&quot;keyword&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; getNumKeys() &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; { &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; mNumKeys; }
    &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; advance();
    &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; onMessageReceived(IMidiMsg* midiMessage);
    &lt;span class=&quot;keyword&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; Flush(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; nFrames) { mMidiQueue.Flush(nFrames); mOffset = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; }
    &lt;span class=&quot;keyword&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; Resize(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; blockSize) { mMidiQueue.Resize(blockSize); }

    Signal2&amp;lt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &amp;gt; noteOn;
    Signal2&amp;lt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &amp;gt; noteOff;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In &lt;em&gt;MIDIReceiver.cpp&lt;/em&gt;, modify the &lt;code&gt;advance&lt;/code&gt; function:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; MIDIReceiver::advance() {
    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (!mMidiQueue.Empty()) {
        IMidiMsg* midiMessage = mMidiQueue.Peek();
        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (midiMessage-&amp;gt;mOffset &amp;gt; mOffset) &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;

        IMidiMsg::EStatusMsg status = midiMessage-&amp;gt;StatusMsg();
        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; noteNumber = midiMessage-&amp;gt;NoteNumber();
        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; velocity = midiMessage-&amp;gt;Velocity();
        &lt;span class=&quot;comment&quot;&gt;// There are only note on/off messages in the queue, see ::OnMessageReceived&lt;/span&gt;
        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (status == IMidiMsg::kNoteOn &amp;amp;&amp;amp; velocity) {
            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(mKeyStatus[noteNumber] == &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;) {
                mKeyStatus[noteNumber] = &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;;
                mNumKeys += &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;
                noteOn(noteNumber, velocity);
            }
        } &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; {
            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(mKeyStatus[noteNumber] == &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;) {
                mKeyStatus[noteNumber] = &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;;
                mNumKeys -= &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;
                noteOff(noteNumber, velocity);
            }
        }
        mMidiQueue.Remove();
    }
    mOffset++;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Three things have changed here:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The &lt;code&gt;mLast&lt;/code&gt; members were removed&lt;/li&gt;
&lt;li&gt;&lt;code&gt;noteOn&lt;/code&gt; is emitted when &lt;em&gt;any&lt;/em&gt; note is pressed (doesn’t have to be different from &lt;code&gt;mLastNoteNumber&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;noteOff&lt;/code&gt; is emitted when &lt;em&gt;any&lt;/em&gt; note is released (doesn’t have to be equal to &lt;code&gt;mLastNoteNumber&lt;/code&gt;)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Moving on to &lt;em&gt;SpaceBass.h&lt;/em&gt;, remove the following things:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;#include&lt;/code&gt;s for &lt;em&gt;Oscillator.h&lt;/em&gt;, &lt;em&gt;EnvelopeGenerator.h&lt;/em&gt; and &lt;em&gt;Filter.h&lt;/em&gt;, and &lt;code&gt;#include &amp;quot;VoiceManager.h&amp;quot;&lt;/code&gt; instead.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mOscillator&lt;/code&gt;, &lt;code&gt;mEnvelopeGenerator&lt;/code&gt;, &lt;code&gt;mFilter&lt;/code&gt;, &lt;code&gt;mFilterEnvelopeGenerator&lt;/code&gt; and &lt;code&gt;mLFO&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;filterEnvelopeAmount&lt;/code&gt; and &lt;code&gt;lfoFilterModAmount&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;the member functions &lt;code&gt;onNoteOn&lt;/code&gt;, &lt;code&gt;onNoteOff&lt;/code&gt;, &lt;code&gt;onBeganEnvelopeCycle&lt;/code&gt;, &lt;code&gt;onFinishedEnvelopeCycle&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Feels much cleaner, right? The plugin class doesn’t interact with the components directly anymore, only with the &lt;code&gt;VoiceManager&lt;/code&gt;.&lt;br&gt;Add the following to the &lt;code&gt;private&lt;/code&gt; section:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;VoiceManager voiceManager;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In &lt;em&gt;SpaceBass.cpp&lt;/em&gt;, replace the constructor with this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;SpaceBass::SpaceBass(IPlugInstanceInfo instanceInfo) : IPLUG_CTOR(kNumParams, kNumPrograms, instanceInfo), lastVirtualKeyboardNoteNumber(virtualKeyboardMinimumNoteNumber - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) {
    TRACE;

    CreateParams();
    CreateGraphics();
    CreatePresets();

    mMIDIReceiver.noteOn.Connect(&amp;amp;voiceManager, &amp;amp;VoiceManager::onNoteOn);
    mMIDIReceiver.noteOff.Connect(&amp;amp;voiceManager, &amp;amp;VoiceManager::onNoteOff);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;mMIDIReceiver&lt;/code&gt; now gets connected to the &lt;code&gt;VoiceManager&lt;/code&gt; (instead of the plugin class). The &lt;code&gt;EnvelopeGenerator&lt;/code&gt;s are now handled by the &lt;code&gt;VoiceManager&lt;/code&gt; and &lt;code&gt;Voice&lt;/code&gt; classes, so we don’t &lt;code&gt;Connect()&lt;/code&gt; them here anymore.&lt;br&gt;Our &lt;code&gt;ProcessDoubleReplacing&lt;/code&gt; function shows a lot of compiler errors, because it tries to access things that we just deleted. In fact, the new implementation is very simple: It’s mainly a call to &lt;code&gt;VoiceManager::nextSample&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; SpaceBass::ProcessDoubleReplacing(
    &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt;** inputs,
    &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt;** outputs,
    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; nFrames)
{
    &lt;span class=&quot;comment&quot;&gt;// Mutex is already locked for us.&lt;/span&gt;

    &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; *leftOutput = outputs[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;];
    &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; *rightOutput = outputs[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;];
    processVirtualKeyboard();
    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; nFrames; ++i) {
        mMIDIReceiver.advance();
        leftOutput[i] = rightOutput[i] = voiceManager.nextSample();
    }

    mMIDIReceiver.Flush(nFrames);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note that all the code about the interaction between &lt;code&gt;Oscillator&lt;/code&gt;s, &lt;code&gt;EnvelopeGenerator&lt;/code&gt;s and the filter is gone.&lt;br&gt;Inside &lt;code&gt;Reset()&lt;/code&gt;, we have no access to the components anymore. So we have to tell the &lt;code&gt;VoiceManager&lt;/code&gt; to change the sampleRate for all components:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; SpaceBass::Reset()
{
    TRACE;
    IMutexLock lock(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;);
    &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; sampleRate = GetSampleRate();
    voiceManager.setSampleRate(sampleRate);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We haven’t implemented this function yet. Add the following to &lt;code&gt;VoiceManager&lt;/code&gt;‘s &lt;code&gt;public&lt;/code&gt; section (in &lt;em&gt;VoiceManager.h&lt;/em&gt;):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; setSampleRate(&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; sampleRate) {
    EnvelopeGenerator::setSampleRate(sampleRate);
    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; NumberOfVoices; i++) {
        Voice&amp;amp; voice = voices[i];
        voice.mOscillatorOne.setSampleRate(sampleRate);
        voice.mOscillatorTwo.setSampleRate(sampleRate);
    }
    mLFO.setSampleRate(sampleRate);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Basically this just calls &lt;code&gt;setSampleRate&lt;/code&gt; on every voice and for each component. We could set &lt;code&gt;Oscillator::mSampleRate&lt;/code&gt; statically, but we’d still have to call &lt;code&gt;updateIncrement&lt;/code&gt; for each &lt;code&gt;Oscillator&lt;/code&gt; on each &lt;code&gt;Voice&lt;/code&gt;. I find it more clear to do it like this.&lt;/p&gt;
&lt;p&gt;Our plugin is now polyphonic, with the exception that it doesn’t react to our knobs yet. But before we fix that, let’s add pitch modulation to our &lt;code&gt;Oscillator&lt;/code&gt;s.&lt;/p&gt;
&lt;h2 id=&quot;pitch-modulation&quot;&gt;Pitch Modulation&lt;/h2&gt;
&lt;p&gt;So far we’ve mainly done &lt;em&gt;structural&lt;/em&gt; refactoring changes. We’ve moved code from one part to another and deleted code that’s not needed anymore. I’ve delayed pitch modulation until this point because it has nothing to do with polyphony and it would be confusing to just mix it in here and there.&lt;/p&gt;
&lt;p&gt;In &lt;em&gt;Voice.cpp&lt;/em&gt;, add this to &lt;code&gt;Voice::nextSample&lt;/code&gt; (right above the &lt;code&gt;return&lt;/code&gt; statement):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;mOscillatorOne.setPitchMod(mLFOValue * mOscillatorOnePitchAmount);
mOscillatorTwo.setPitchMod(mLFOValue * mOscillatorTwoPitchAmount);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As you can see, the pitch modulation is determined by the LFO value multiplied with the knob value from the GUI.&lt;br&gt;In &lt;em&gt;Oscillator.h&lt;/em&gt;, add a new &lt;code&gt;private&lt;/code&gt; member:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; mPitchMod;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Initialize it in the constructor’s initializer list:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;mPitchMod(&lt;span class=&quot;number&quot;&gt;0.0&lt;/span&gt;),
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And add a &lt;code&gt;public&lt;/code&gt; setter function:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; setPitchMod(&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; amount);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let’s implement it (in &lt;em&gt;Oscillator.cpp&lt;/em&gt;):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; Oscillator::setPitchMod(&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; amount) {
    mPitchMod = amount;
    updateIncrement();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Setting the pitch mod value influences the actual frequency that should be played. So we have to call &lt;code&gt;updateIncrement&lt;/code&gt;. Inside &lt;code&gt;updateIncrement&lt;/code&gt;, we somehow have to take &lt;code&gt;mPitchMod&lt;/code&gt; into account. Let’s write a new &lt;code&gt;updateIncrement&lt;/code&gt; step by step (replace the old one in &lt;em&gt;Oscillator.cpp&lt;/em&gt;):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; Oscillator::updateIncrement() {
    &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; pitchModAsFrequency = &lt;span class=&quot;built_in&quot;&gt;pow&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;2.0&lt;/span&gt;, &lt;span class=&quot;built_in&quot;&gt;fabs&lt;/span&gt;(mPitchMod) * &lt;span class=&quot;number&quot;&gt;14.0&lt;/span&gt;) - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;
    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (mPitchMod &amp;lt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) {
        pitchModAsFrequency = -pitchModAsFrequency;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Okay, what’s going on here? &lt;code&gt;mPitchMod&lt;/code&gt; is between &lt;code&gt;-1&lt;/code&gt; and &lt;code&gt;1&lt;/code&gt;, but we want it in terms of frequency, something like &lt;em&gt;“plus 491.3 Hz”&lt;/em&gt;. The &lt;code&gt;pow&lt;/code&gt; term gives us that, but we have to bypass the fact that values are negative. We do that by calling &lt;code&gt;fabs&lt;/code&gt; (absolute value), and the following &lt;code&gt;if&lt;/code&gt; statement gets us the negativity back. Why the &lt;code&gt;-1&lt;/code&gt; at the end? If &lt;code&gt;mPitchMod&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;pow(2.0, 0)&lt;/code&gt; would give us &lt;code&gt;1&lt;/code&gt;, so we would have a pitch modulation of 1 Hz (which is wrong). To prevent this, we subtract &lt;code&gt;-1&lt;/code&gt;.&lt;br&gt;Next, we make a &lt;code&gt;calculatedFrequency&lt;/code&gt; out of the base &lt;code&gt;mFrequency&lt;/code&gt; and the Hz value we just calculated:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; calculatedFrequency = fmin(fmax(mFrequency + pitchModAsFrequency, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;), mSampleRate/&lt;span class=&quot;number&quot;&gt;2.0&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;First, we’re adding the base frequency and the mod frequency together. The &lt;code&gt;fmin&lt;/code&gt; call ensures that we’re not going higher than &lt;em&gt;half the sample rate&lt;/em&gt;. We can’t go higher than this &lt;a href=&quot;http://en.wikipedia.org/wiki/Nyquist_frequency&quot;&gt;Nyquist frequency&lt;/a&gt;, or else we’ll get aliasing. Similarly, we can’t have a frequency below zero, so &lt;code&gt;fmax&lt;/code&gt; ensures this won’t happen.&lt;br&gt;Let’s finish the function by setting the phase increment:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;    mPhaseIncrement = calculatedFrequency * &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; * mPI / mSampleRate;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is just like before, except that we’re of course using the &lt;code&gt;calculatedFrequency&lt;/code&gt; value.&lt;/p&gt;
&lt;h2 id=&quot;making-the-gui-knobs-work&quot;&gt;Making the GUI Knobs work&lt;/h2&gt;
&lt;p&gt;This is the last piece of the puzzle! After this section, our synthesizer will be finished!&lt;/p&gt;
&lt;p&gt;Let’s begin with the LFO knobs. They don’t affect voices, so they need a different treatment than the other parameters.In &lt;em&gt;SpaceBass.cpp&lt;/em&gt;, delete the existing &lt;code&gt;OnParamChange&lt;/code&gt; implementation and add this instead:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; SpaceBass::OnParamChange(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; paramIdx)
{
    IMutexLock lock(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;);
    IParam* param = GetParam(paramIdx);
    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(paramIdx == mLFOWaveform) {
        voiceManager.setLFOMode(&lt;span class=&quot;keyword&quot;&gt;static_cast&lt;/span&gt;&amp;lt;Oscillator::OscillatorMode&amp;gt;(param-&amp;gt;Int()));
    } &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(paramIdx == mLFOFrequency) {
        voiceManager.setLFOFrequency(param-&amp;gt;Value());
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We’re getting the &lt;code&gt;VoiceManager&lt;/code&gt; instance, check which parameter was modified, and call either &lt;code&gt;setLFOMode&lt;/code&gt; or &lt;code&gt;setLFOFrequency&lt;/code&gt;. We haven’t implemented these two yet, so let’s do that next. Open &lt;em&gt;VoiceManager.h&lt;/em&gt; and add the two &lt;code&gt;public&lt;/code&gt; member functions:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; setLFOMode(Oscillator::OscillatorMode mode) { mLFO.setMode(mode); };
&lt;span class=&quot;keyword&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; setLFOFrequency(&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; frequency) { mLFO.setFrequency(frequency); };
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As you can see, these two simply forward to &lt;code&gt;mLFO&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;For all the other parameters, we’ll use C++ &lt;em&gt;functional&lt;/em&gt; mechanisms. They are very nice and powerful, but rarely covered in C++ tutorials. I think you’ll agree that they’re really worth knowing! But what’s the problem we’re trying to solve?&lt;/p&gt;
&lt;p&gt;When you turn a knob, &lt;code&gt;OnParamChange&lt;/code&gt; is called with a parameter index and value. Let’s say &lt;code&gt;mFilterCutoff&lt;/code&gt; with a value of &lt;code&gt;0.3&lt;/code&gt;. Now we have to tell the &lt;code&gt;VoiceManager&lt;/code&gt;: &lt;em&gt;“For each &lt;code&gt;Voice&lt;/code&gt;, set the filter cutoff to &lt;code&gt;0.3&lt;/code&gt;“&lt;/em&gt;. We would probably call a function &lt;code&gt;setFilterCutoffForEachVoice&lt;/code&gt; that could look like this (just for demonstration):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;VoiceManager::setFilterCutoffForEachVoice(&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; newCutoff) {
    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; NumberOfVoices; i++) {
        voice[i].mFilter.setCutoff(newCutoff);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This doesn’t look too bad, but we’d need about ten of these functions for all the different parameters. Each of them would be a little different, but the &lt;code&gt;for&lt;/code&gt; loop would be duplicated. If only there was a way of saying: &lt;em&gt;“Here’s a change. Do this change to all voices”&lt;/em&gt;. Of course, there is a way. C++ allows you to take a function, pre-fill it with some input values, pass it around and call it on different things. This is similar to JavaScript’s &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind&quot;&gt;Function.prototype.bind&lt;/a&gt;, but in C++ it’s also type-safe.&lt;br&gt;Let’s try this out! In &lt;em&gt;VoiceManager.h&lt;/em&gt;, add this &lt;code&gt;#include&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#include &amp;lt;tr1/functional&amp;gt;&lt;/span&gt;
&lt;span class=&quot;comment&quot;&gt;// #include &amp;lt;functional&amp;gt; if that doesn't work&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the public section, add this line:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::tr1::function&amp;lt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; (Voice&amp;amp;)&amp;gt; VoiceChangerFunction;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This means: A &lt;code&gt;VoiceChangerFunction&lt;/code&gt; is a function that takes a &lt;code&gt;Voice&amp;amp;&lt;/code&gt; as first parameter and returns &lt;code&gt;void&lt;/code&gt;. (In fact, it doesn’t have to be a function, as long as it’s something you can call with &lt;code&gt;()&lt;/code&gt;.)&lt;br&gt;Below that, add this function:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; changeAllVoices(VoiceChangerFunction changer) {
    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; NumberOfVoices; i++) {
        changer(voices[i]);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note how it takes a &lt;code&gt;VoiceChangerFunction&lt;/code&gt;, iterates through all &lt;code&gt;voices&lt;/code&gt;, and applies the &lt;code&gt;changer&lt;/code&gt; to each of them.&lt;br&gt;Below that, add the actual functions. They all look kind of similar: Each takes a &lt;code&gt;Voice&amp;amp;&lt;/code&gt; and some other parameters, and modifies that one &lt;code&gt;Voice&lt;/code&gt;.
&lt;a name=&quot;single_voice_changing_functions&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Functions to change a single voice:&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; setVolumeEnvelopeStageValue(Voice&amp;amp; voice, EnvelopeGenerator::EnvelopeStage stage, &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; value) {
    voice.mVolumeEnvelope.setStageValue(stage, value);
}
&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; setFilterEnvelopeStageValue(Voice&amp;amp; voice, EnvelopeGenerator::EnvelopeStage stage, &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; value) {
    voice.mFilterEnvelope.setStageValue(stage, value);
}
&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; setOscillatorMode(Voice&amp;amp; voice, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; oscillatorNumber, Oscillator::OscillatorMode mode) {
    &lt;span class=&quot;keyword&quot;&gt;switch&lt;/span&gt; (oscillatorNumber) {
        &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;:
            voice.mOscillatorOne.setMode(mode);
            &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;
        &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;:
            voice.mOscillatorTwo.setMode(mode);
            &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;
    }
}
&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; setOscillatorPitchMod(Voice&amp;amp; voice, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; oscillatorNumber, &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; amount) {
    &lt;span class=&quot;keyword&quot;&gt;switch&lt;/span&gt; (oscillatorNumber) {
        &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;:
            voice.setOscillatorOnePitchAmount(amount);
            &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;
        &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;:
            voice.setOscillatorTwoPitchAmount(amount);
            &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;
    }
}
&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; setOscillatorMix(Voice&amp;amp; voice, &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; value) {
    voice.setOscillatorMix(value);
}
&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; setFilterCutoff(Voice&amp;amp; voice, &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; cutoff) {
    voice.mFilter.setCutoff(cutoff);
}
&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; setFilterResonance(Voice&amp;amp; voice, &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; resonance) {
    voice.mFilter.setResonance(resonance);
}
&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; setFilterMode(Voice&amp;amp; voice, Filter::FilterMode mode) {
    voice.mFilter.setFilterMode(mode);
}
&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; setFilterEnvAmount(Voice&amp;amp; voice, &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; amount) {
    voice.setFilterEnvelopeAmount(amount);
}
&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; setFilterLFOAmount(Voice&amp;amp; voice, &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; amount) {
    voice.setFilterLFOAmount(amount);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But we can’t pass these to &lt;code&gt;changeAllVoices&lt;/code&gt;: They aren’t &lt;code&gt;VoiceChangerFunction&lt;/code&gt;s because all of them take more arguments. We will pre-fill all arguments except for the first one (&lt;code&gt;Voice&amp;amp;&lt;/code&gt;), which will turn them into &lt;code&gt;VoiceChangerFunction&lt;/code&gt;s.&lt;br&gt;In &lt;em&gt;SpaceBass.cpp&lt;/em&gt;, &lt;code&gt;#include &amp;lt;tr1/functional&amp;gt;&lt;/code&gt; (or &lt;code&gt;#include &amp;lt;functional&amp;gt;&lt;/code&gt;). Inside &lt;code&gt;OnParamChange&lt;/code&gt;, add an &lt;code&gt;else&lt;/code&gt; case at the end, so it looks like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;
    } &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; {
        &lt;span class=&quot;keyword&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::tr1::placeholders::_1;
        &lt;span class=&quot;keyword&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::tr1::bind;
        VoiceManager::VoiceChangerFunction changer;
        &lt;span class=&quot;keyword&quot;&gt;switch&lt;/span&gt;(paramIdx) {
            &lt;span class=&quot;comment&quot;&gt;// We'll add this part in a moment&lt;/span&gt;
        }
        voiceManager.changeAllVoices(changer);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here we just say that we don’t want to type &lt;code&gt;std::tr1::&lt;/code&gt; all the time. Now we can just type &lt;code&gt;_1&lt;/code&gt; and &lt;code&gt;bind&lt;/code&gt; (more on these two in a moment). We also declare a &lt;code&gt;VoiceChangerFunction&lt;/code&gt;. Then there’s a &lt;code&gt;switch&lt;/code&gt; that makes &lt;code&gt;changer&lt;/code&gt; different for every parameter. And finally, we call &lt;code&gt;changeAllVoices&lt;/code&gt;, passing the &lt;code&gt;changer&lt;/code&gt; we just created.&lt;/p&gt;
&lt;p&gt;So how do we create such a &lt;code&gt;changer&lt;/code&gt;?&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;We take one of the &lt;a href=&quot;http://www.martin-finke.de/articles/audio-plugins-017-polyphony-ii/#single_voice_changing_functions&quot;&gt;functions defined earlier&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;Using &lt;code&gt;std::tr1::bind&lt;/code&gt;, we pre-fill all the arguments except for the first one (&lt;code&gt;Voice&amp;amp;&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;This gives us a true &lt;code&gt;VoiceChangerFunction&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;This may sound a little complicated, so let’s just see it in practice. Add the following &lt;code&gt;case&lt;/code&gt; inside the &lt;code&gt;switch(paramIdx)&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; mOsc1Waveform:
    changer = bind(&amp;amp;VoiceManager::setOscillatorMode,
                   _1,
                   &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,
                   &lt;span class=&quot;keyword&quot;&gt;static_cast&lt;/span&gt;&amp;lt;Oscillator::OscillatorMode&amp;gt;(param-&amp;gt;Int()));
    &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The first parameter to &lt;code&gt;bind&lt;/code&gt; is the function we want to pre-fill. In this case &lt;code&gt;setOscillatorMode&lt;/code&gt;. All the following parameters are things that will be pre-filled. The &lt;code&gt;_1&lt;/code&gt; is the placeholder, and it means: I’m not pre-filling this parameter, I’ll pass it in when &lt;code&gt;changer&lt;/code&gt; gets called. In our case this means that &lt;code&gt;changer&lt;/code&gt; expects a &lt;code&gt;Voice&amp;amp;&lt;/code&gt; as its first argument, which makes it a valid &lt;code&gt;VoiceChangerFunction&lt;/code&gt;. After the placeholder, we pre-fill the function with the input that’s needed: Oscillator &lt;code&gt;1&lt;/code&gt;‘s waveform should be set to the parameter value. We have to cast the integer to a &lt;code&gt;OscillatorMode&lt;/code&gt; &lt;code&gt;enum&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Let’s create the &lt;code&gt;changer&lt;/code&gt; for every other parameter. They all follow the same idea, except the number and type of the pre-fill parameters are different. If you have understood the principe, you don’t really have to type these in by hand:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; mOsc1PitchMod:
    changer = bind(&amp;amp;VoiceManager::setOscillatorPitchMod, _1, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, param-&amp;gt;Value());
    &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;
&lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; mOsc2Waveform:
    changer = bind(&amp;amp;VoiceManager::setOscillatorMode, _1, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;static_cast&lt;/span&gt;&amp;lt;Oscillator::OscillatorMode&amp;gt;(param-&amp;gt;Int()));
    &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;
&lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; mOsc2PitchMod:
    changer = bind(&amp;amp;VoiceManager::setOscillatorPitchMod, _1, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, param-&amp;gt;Value());
    &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;
&lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; mOscMix:
    changer = bind(&amp;amp;VoiceManager::setOscillatorMix, _1, param-&amp;gt;Value());
    &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;
    &lt;span class=&quot;comment&quot;&gt;// Filter Section:&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; mFilterMode:
    changer = bind(&amp;amp;VoiceManager::setFilterMode, _1, &lt;span class=&quot;keyword&quot;&gt;static_cast&lt;/span&gt;&amp;lt;Filter::FilterMode&amp;gt;(param-&amp;gt;Int()));
    &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;
&lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; mFilterCutoff:
    changer = bind(&amp;amp;VoiceManager::setFilterCutoff, _1, param-&amp;gt;Value());
    &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;
&lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; mFilterResonance:
    changer = bind(&amp;amp;VoiceManager::setFilterResonance, _1, param-&amp;gt;Value());
    &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;
&lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; mFilterLfoAmount:
    changer = bind(&amp;amp;VoiceManager::setFilterLFOAmount, _1, param-&amp;gt;Value());
    &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;
&lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; mFilterEnvAmount:
    changer = bind(&amp;amp;VoiceManager::setFilterEnvAmount, _1, param-&amp;gt;Value());
    &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;
    &lt;span class=&quot;comment&quot;&gt;// Volume Envelope:&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; mVolumeEnvAttack:
    changer = bind(&amp;amp;VoiceManager::setVolumeEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_ATTACK, param-&amp;gt;Value());
    &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;
&lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; mVolumeEnvDecay:
    changer = bind(&amp;amp;VoiceManager::setVolumeEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_DECAY, param-&amp;gt;Value());
    &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;
&lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; mVolumeEnvSustain:
    changer = bind(&amp;amp;VoiceManager::setVolumeEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_SUSTAIN, param-&amp;gt;Value());
    &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;
&lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; mVolumeEnvRelease:
    changer = bind(&amp;amp;VoiceManager::setVolumeEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_RELEASE, param-&amp;gt;Value());
    &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;
    &lt;span class=&quot;comment&quot;&gt;// Filter Envelope:&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; mFilterEnvAttack:
    changer = bind(&amp;amp;VoiceManager::setFilterEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_ATTACK, param-&amp;gt;Value());
    &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;
&lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; mFilterEnvDecay:
    changer = bind(&amp;amp;VoiceManager::setFilterEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_DECAY, param-&amp;gt;Value());
    &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;
&lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; mFilterEnvSustain:
    changer = bind(&amp;amp;VoiceManager::setFilterEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_SUSTAIN, param-&amp;gt;Value());
    &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;
&lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; mFilterEnvRelease:
    changer = bind(&amp;amp;VoiceManager::setFilterEnvelopeStageValue, _1, EnvelopeGenerator::ENVELOPE_STAGE_RELEASE, param-&amp;gt;Value());
    &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note that all of this is type-safe: You can’t, for example, make a &lt;code&gt;changer&lt;/code&gt; to change the filter cutoff and pre-fill it with an &lt;code&gt;enum&lt;/code&gt; value or with the wrong number of parameters.&lt;br&gt;If at some point you decide to handle your &lt;code&gt;VoiceManager&lt;/code&gt;‘s &lt;code&gt;voices&lt;/code&gt; as a linked list with dynamic memory allocation, you just have to change &lt;code&gt;changeAllVoices&lt;/code&gt;. All other parts of the code can stay the same.&lt;/p&gt;
&lt;h2 id=&quot;finished-&quot;&gt;Finished!&lt;/h2&gt;
&lt;p&gt;Congratulations, you have built a polyphonic synthesizer! I know this was &lt;em&gt;a lot&lt;/em&gt; of work, and I hope it wasn’t too difficult. If you have read this far and something still doesn’t work, please leave a comment and I’ll help you out. For reference, you can download the source code with all the images &lt;a href=&quot;/blog/articles/audio-plugins-017-polyphony-ii/source.zip&quot;&gt;here&lt;/a&gt;. The next projects will be a smaller scale.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.martin-finke.de/articles/audio-plugins-018-polyblep-oscillator/&quot;&gt;Click here&lt;/a&gt; to go to the next post, where we get rid of the Oscillator aliasing.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/blog/articles/audio-plugins-017-polyphony-ii/finished.png&quot;&gt;&lt;img src=&quot;/blog/articles/audio-plugins-017-polyphony-ii/finished.png&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Making Audio Plugins Part 16: Polyphony Part I</title>
      <link>http://www.martin-finke.de/blog/articles/audio-plugins-016-polyphony/</link>
      <pubDate>Sun, 13 Oct 2013 20:43:00 +0200</pubDate>
      <guid isPermaLink="true">http://www.martin-finke.de/blog/articles/audio-plugins-016-polyphony/</guid>
      <author></author>
      <description>&lt;p&gt;Let’s create a polyphonic synthesizer from the components we already have! &lt;span class=&quot;more&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;In the &lt;a href=&quot;http://www.martin-finke.de/articles/audio-plugins-015-redesign/&quot;&gt;last post&lt;/a&gt; we have created our plugin’s parameters and the UI. Now we’ll build the underlying audio processing, but in a &lt;a href=&quot;http://en.wikipedia.org/wiki/Polyphony_and_monophony_in_instruments&quot;&gt;polyphonic&lt;/a&gt; way! That means that we’ll be able to play up to 64 notes at the same time! This will change our plugin’s structure fundamentally, but we’ll be able to reuse the &lt;code&gt;Oscillator&lt;/code&gt;, &lt;code&gt;EnvelopeGenerator&lt;/code&gt;, &lt;code&gt;MIDIReceiver&lt;/code&gt; and &lt;code&gt;Filter&lt;/code&gt; classes we already have.&lt;/p&gt;
&lt;p&gt;In this post, we’ll create a &lt;code&gt;Voice&lt;/code&gt; class that represents one playing note. We’ll then create a &lt;code&gt;VoiceManager&lt;/code&gt; class that will make sure &lt;code&gt;Voice&lt;/code&gt;s are being started whenever a note is pressed.&lt;br&gt;In the &lt;a href=&quot;http://www.martin-finke.de/articles/audio-plugins-017-polyphony-ii/&quot;&gt;following post&lt;/a&gt;, we’ll clean up code that’s not needed anymore, add pitch modulation, and make the GUI controls work. It sounds like quite a bit of work, but we’ve already got most of the components we need, and in the end we’ll have a polyphonic subtractive synthesizer!&lt;/p&gt;
&lt;h2 id=&quot;what-goes-where-&quot;&gt;What goes where?&lt;/h2&gt;
&lt;p&gt;Let’s think for a brief moment about which parts of our plugin are global, and which parts are separate for each played note. Imagine you’re playing a few notes on your keyboard. Whenever you hit a note, you hear a tone that decays and maybe changes its filter cutoff over time using a filter envelope. When you hit another note while the last note is still playing, you hear another tone with decay and changing filter cutoff, but the previous tone is not affected! It keeps going &lt;em&gt;as if it is alone&lt;/em&gt;. So each voice is independent with its own volume &amp;amp; filter envelopes.&lt;br&gt;The LFO is global to our plugin. There’s just one that keeps running on and on, and it can’t be re-triggered at the start of a note.&lt;br&gt;So what about the filter? Obviously the filter’s &lt;code&gt;cutoff&lt;/code&gt; and &lt;code&gt;resonance&lt;/code&gt; are both global, because all voices listen to the same cutoff/resonance knob in our GUI. But the filter’s cutoff frequency is modulated by the filter envelope, so at any given time the &lt;em&gt;calculated cutoff&lt;/em&gt; is different for each voice. If you have a brief look at the &lt;code&gt;Filter::cutoff&lt;/code&gt; member function, you can see that it calls &lt;code&gt;getCalculatedCutoff&lt;/code&gt;. So we need one &lt;code&gt;Filter&lt;/code&gt; per &lt;code&gt;Voice&lt;/code&gt;.&lt;br&gt;But can we create two global &lt;code&gt;Oscillator&lt;/code&gt;s and share them across all voices? Each &lt;code&gt;Voice&lt;/code&gt; can play a different note, i.e. a different frequency. So these have to be independent as well.&lt;/p&gt;
&lt;p&gt;In short, this will be our hierarchy:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Our plugin has one &lt;code&gt;MIDIReceiver&lt;/code&gt; and one &lt;code&gt;VoiceManager&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;VoiceManager&lt;/code&gt; has one LFO (which is an &lt;code&gt;Oscillator&lt;/code&gt;) and many &lt;code&gt;Voice&lt;/code&gt;s.&lt;/li&gt;
&lt;li&gt;A &lt;code&gt;Voice&lt;/code&gt; has two &lt;code&gt;Oscillator&lt;/code&gt;s, &lt;em&gt;two&lt;/em&gt; &lt;code&gt;EnvelopeGenerator&lt;/code&gt;s (for volume and filter) and one &lt;code&gt;Filter&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;the-voice-class&quot;&gt;The &lt;code&gt;Voice&lt;/code&gt; class&lt;/h2&gt;
&lt;p&gt;In the &lt;em&gt;SpaceBass&lt;/em&gt; Xcode project, create a new C++ class and name it &lt;em&gt;Voice&lt;/em&gt;. As always, make sure you add it to all targets. Open &lt;em&gt;Voice.h&lt;/em&gt; and include our components:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#include &quot;Oscillator.h&quot;&lt;/span&gt;
&lt;span class=&quot;preprocessor&quot;&gt;#include &quot;EnvelopeGenerator.h&quot;&lt;/span&gt;
&lt;span class=&quot;preprocessor&quot;&gt;#include &quot;Filter.h&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Inside the &lt;code&gt;class&lt;/code&gt;, let’s begin with the &lt;code&gt;private&lt;/code&gt; section:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt;:
    Oscillator mOscillatorOne;
    Oscillator mOscillatorTwo;
    EnvelopeGenerator mVolumeEnvelope;
    EnvelopeGenerator mFilterEnvelope;
    Filter mFilter;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That’s pretty straightforward, right? Each voice has two oscillators, a volume envelope, a filter envelope and a filter.&lt;br&gt;Each voice is triggered with a certain MIDI note number and a velocity. Add these two (to &lt;code&gt;private&lt;/code&gt;):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; mNoteNumber;
    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; mVelocity;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Each of the following variables describes how much a parameter is modulated:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; mFilterEnvelopeAmount;
    &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; mOscillatorMix;
    &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; mFilterLFOAmount;
    &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; mOscillatorOnePitchAmount;
    &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; mOscillatorTwoPitchAmount;
    &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; mLFOValue;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;All of these properties except for &lt;code&gt;mLFOValue&lt;/code&gt; represent the knob values in our GUI. Actually they are always the same for all voices, but we’re not putting them globally in our plugin class. The reason is that each voice needs access to them on every sample, and the &lt;code&gt;Voice&lt;/code&gt; class doesn’t even know our plugin class (there’s no &lt;code&gt;#include &amp;quot;SpaceBass.h&amp;quot;&lt;/code&gt;). So it would be quite tedious to give this kind of access.&lt;br&gt;There’s one more value. Do you remember how &lt;a href=&quot;http://www.martin-finke.de/articles/audio-plugins-009-receiving-midi/#adding_isMuted_property&quot;&gt;we added a &lt;code&gt;isMuted&lt;/code&gt; property&lt;/a&gt; to the &lt;code&gt;Oscillator&lt;/code&gt; class? We’ll move this to &lt;code&gt;Voice&lt;/code&gt; level, so whenever a voice isn’t active, it’s not processing anything (this includes its envelopes and filter). Add this line:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt; isActive;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now let’s add the &lt;code&gt;public&lt;/code&gt; section &lt;em&gt;above&lt;/em&gt; the &lt;code&gt;private&lt;/code&gt; section. We’ll start with the constructor:
&lt;a name=&quot;connect_set_free&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:
    Voice()
    : mNoteNumber(-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;),
    mVelocity(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;),
    mFilterEnvelopeAmount(&lt;span class=&quot;number&quot;&gt;0.0&lt;/span&gt;),
    mFilterLFOAmount(&lt;span class=&quot;number&quot;&gt;0.0&lt;/span&gt;),
    mOscillatorOnePitchAmount(&lt;span class=&quot;number&quot;&gt;0.0&lt;/span&gt;),
    mOscillatorTwoPitchAmount(&lt;span class=&quot;number&quot;&gt;0.0&lt;/span&gt;),
    mOscillatorMix(&lt;span class=&quot;number&quot;&gt;0.5&lt;/span&gt;),
    mLFOValue(&lt;span class=&quot;number&quot;&gt;0.0&lt;/span&gt;),
    isActive(&lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;) {
        &lt;span class=&quot;comment&quot;&gt;// Set myself free everytime my volume envelope has fully faded out of RELEASE stage:&lt;/span&gt;
        mVolumeEnvelope.finishedEnvelopeCycle.Connect(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, &amp;amp;Voice::setFree);
    };
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This initializes the member variables to sensible defaults. Note that a &lt;code&gt;Voice&lt;/code&gt; is not active by default. Also, by using the &lt;code&gt;EnvelopeGenerator&lt;/code&gt;‘s &lt;a href=&quot;http://www.martin-finke.de/articles/audio-plugins-011-envelopes/#signals_slots&quot;&gt;Signal &amp;amp; Slot&lt;/a&gt; mechanism, we set a voice &lt;em&gt;free&lt;/em&gt; whenever the volume envelope goes out of release stage.&lt;br&gt;Let’s add setters for the members. Add the following to the &lt;code&gt;public&lt;/code&gt; section:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; setFilterEnvelopeAmount(&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; amount) { mFilterEnvelopeAmount = amount; }
    &lt;span class=&quot;keyword&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; setFilterLFOAmount(&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; amount) { mFilterLFOAmount = amount; }
    &lt;span class=&quot;keyword&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; setOscillatorOnePitchAmount(&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; amount) { mOscillatorOnePitchAmount = amount; }
    &lt;span class=&quot;keyword&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; setOscillatorTwoPitchAmount(&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; amount) { mOscillatorTwoPitchAmount = amount; }
    &lt;span class=&quot;keyword&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; setOscillatorMix(&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; mix) { mOscillatorMix = mix; }
    &lt;span class=&quot;keyword&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; setLFOValue(&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; value) { mLFOValue = value; }

    &lt;span class=&quot;keyword&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; setNoteNumber(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; noteNumber) {
        mNoteNumber = noteNumber;
        &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; frequency = &lt;span class=&quot;number&quot;&gt;440.0&lt;/span&gt; * &lt;span class=&quot;built_in&quot;&gt;pow&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;2.0&lt;/span&gt;, (mNoteNumber - &lt;span class=&quot;number&quot;&gt;69.0&lt;/span&gt;) / &lt;span class=&quot;number&quot;&gt;12.0&lt;/span&gt;);
        mOscillatorOne.setFrequency(frequency);
        mOscillatorTwo.setFrequency(frequency);
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The only interesting part here is &lt;code&gt;setNoteNumber&lt;/code&gt;. It calculates the frequency for the given note (it’s the same formula we used before) and passes it to both oscillators. Below that, add this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; nextSample();
    &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; setFree();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Just like &lt;code&gt;Oscillator::nextSample&lt;/code&gt; gives us the output of an &lt;code&gt;Oscillator&lt;/code&gt;, &lt;code&gt;Voice::nextSample&lt;/code&gt; gives us &lt;em&gt;the total output of a voice&lt;/em&gt;, after volume envelope and filtering. Let’s implement it (in &lt;em&gt;Voice.cpp&lt;/em&gt;):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; Voice::nextSample() {
    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!isActive) &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0.0&lt;/span&gt;;

    &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; oscillatorOneOutput = mOscillatorOne.nextSample();
    &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; oscillatorTwoOutput = mOscillatorTwo.nextSample();
    &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; oscillatorSum = ((&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; - mOscillatorMix) * oscillatorOneOutput) + (mOscillatorMix * oscillatorTwoOutput);

    &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; volumeEnvelopeValue = mVolumeEnvelope.nextSample();
    &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; filterEnvelopeValue = mFilterEnvelope.nextSample();

    mFilter.setCutoffMod(filterEnvelopeValue * mFilterEnvelopeAmount + mLFOValue * mFilterLFOAmount);

    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; mFilter.process(oscillatorSum * volumeEnvelopeValue * mVelocity / &lt;span class=&quot;number&quot;&gt;127.0&lt;/span&gt;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The first line ensures that a voice doesn’t calculate anything while it’s not active. It just returns a muted output. The following three lines get the &lt;code&gt;nextSample&lt;/code&gt; from both oscillators and sum them together according to &lt;code&gt;mOscillatorMix&lt;/code&gt;. When &lt;code&gt;mOscillatorMix&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;, only &lt;code&gt;oscillatorOneOutput&lt;/code&gt; can be heard. When it’s &lt;code&gt;1&lt;/code&gt;, we only hear &lt;code&gt;oscillatorTwoOutput&lt;/code&gt;. At &lt;code&gt;0.5&lt;/code&gt;, both oscillators are equally loud.&lt;br&gt;After that, we get the &lt;code&gt;nextSample&lt;/code&gt; from both envelopes. We then apply the &lt;code&gt;filterEnvelopeValue&lt;/code&gt; to the filter cutoff, but we also take the current LFO value into account. So the cutoff modulation is the sum of the filter envelope output and the LFO output.&lt;br&gt;The pitch modulation for both oscillators is just the LFO output multiplied by the pitch modulation amount. We’ll implement that in a bit.&lt;br&gt;The last line is quite interesting, let’s start inside the parentheses: We take the sum of our two oscillators, apply the volume envelope and velocity, and send the result through &lt;code&gt;mFilter.process&lt;/code&gt;. This gets us the filtered output, which we return.&lt;/p&gt;
&lt;p&gt;The implementation of &lt;code&gt;setFree&lt;/code&gt; is pretty simple:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; Voice::setFree() {
    isActive = &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As you can see, this is just used to return a voice to inactive state. As described &lt;a href=&quot;http://www.martin-finke.de/articles/audio-plugins-016-polyphony/#connect_set_free&quot;&gt;above&lt;/a&gt;, this will be called whenever a voice’s &lt;code&gt;mVolumeEnvelope&lt;/code&gt; has fully faded out.&lt;/p&gt;
&lt;h2 id=&quot;the-voicemanager-&quot;&gt;The &lt;code&gt;VoiceManager&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;Let’s implement a class for managing voices! Create a new class named &lt;em&gt;VoiceManager&lt;/em&gt;. In the header, start with this code:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#include &quot;Voice.h&quot;&lt;/span&gt;

&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; VoiceManager {
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Add the following &lt;code&gt;private&lt;/code&gt; members:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; NumberOfVoices = &lt;span class=&quot;number&quot;&gt;64&lt;/span&gt;;
Voice voices[NumberOfVoices];
Oscillator mLFO;
Voice* findFreeVoice();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The constant &lt;code&gt;NumberOfVoices&lt;/code&gt; indicates how many voices can play at the same time. In the next line, we create an array of &lt;code&gt;Voice&lt;/code&gt;s. This uses memory for 64 voices, so you could think about using &lt;a href=&quot;http://www.cplusplus.com/doc/tutorial/dynamic/&quot;&gt;dynamic memory&lt;/a&gt; for this. However, our plugin class is allocated dynamically (search for &lt;code&gt;&amp;quot;new PLUG_CLASS_NAME&amp;quot;&lt;/code&gt; in &lt;em&gt;IPlug_include_in_plug_src.h&lt;/em&gt;).&lt;br&gt;So all members of our plugin class go on the heap as well.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mLFO&lt;/code&gt; is the global LFO for our plugin. It never gets retriggered, it just runs freely. You could argue that this should be inside the plugin class (a &lt;code&gt;VoiceManager&lt;/code&gt; doesn’t have to know about an LFO). But this introduces another layer of separation between the &lt;code&gt;Voice&lt;/code&gt;s and the LFO, which means that we would need more &lt;a href=&quot;http://en.wikipedia.org/wiki/Glue_code&quot;&gt;Glue Code&lt;/a&gt;.&lt;br&gt;&lt;code&gt;findFreeVoice&lt;/code&gt; is a utility function that we can use to get a voice that’s not currently playing. Add the implementation to &lt;em&gt;VoiceManager.cpp&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;Voice* VoiceManager::findFreeVoice() {
    Voice* freeVoice = NULL;
    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; NumberOfVoices; i++) {
        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!voices[i].isActive) {
            freeVoice = &amp;amp;(voices[i]);
            &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;
        }
    }
    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; freeVoice;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This just iterates over all voices and finds the first one that isn’t currently playing. We’re &lt;code&gt;return&lt;/code&gt;ing a pointer (instead of a &lt;code&gt;&amp;amp;&lt;/code&gt; reference) here because as you can see, it’s possible to return &lt;code&gt;NULL&lt;/code&gt;. This wouldn’t be allowed when we return a reference. In this case, &lt;code&gt;NULL&lt;/code&gt; means that all voices are currently playing.&lt;/p&gt;
&lt;p&gt;Now add the following &lt;code&gt;public&lt;/code&gt; function prototypes:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; onNoteOn(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; noteNumber, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; velocity);
&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; onNoteOff(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; noteNumber, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; velocity);
&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; nextSample();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As the name implies, &lt;code&gt;onNoteOn&lt;/code&gt; will be called whenever our plugin receives a MIDI note on message. &lt;code&gt;onNoteOff&lt;/code&gt; will be called on every note off message. Let’s implement these (in &lt;em&gt;VoiceManager.cpp&lt;/em&gt;):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; VoiceManager::onNoteOn(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; noteNumber, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; velocity) {
    Voice* voice = findFreeVoice();
    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!voice) {
        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;
    }
    voice-&amp;gt;reset();
    voice-&amp;gt;setNoteNumber(noteNumber);
    voice-&amp;gt;mVelocity = velocity;
    voice-&amp;gt;isActive = &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;;
    voice-&amp;gt;mVolumeEnvelope.enterStage(EnvelopeGenerator::ENVELOPE_STAGE_ATTACK);
    voice-&amp;gt;mFilterEnvelope.enterStage(EnvelopeGenerator::ENVELOPE_STAGE_ATTACK);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;First, we’re finding a free voice using the &lt;code&gt;findFreeVoice&lt;/code&gt; function we created above. If there’s no free voice, we just &lt;code&gt;return&lt;/code&gt;. This means that when all voices are in use, pressing a note will do nothing. Implementing &lt;a href=&quot;http://electronicmusic.wikia.com/wiki/Voice_stealing&quot;&gt;voice stealing&lt;/a&gt; will be the topic of a later post. If we get a free voice, we have to somehow &lt;code&gt;reset&lt;/code&gt; it to a blank state (we’ll implement that in a moment). We then &lt;code&gt;setNoteNumber&lt;/code&gt; and &lt;code&gt;mVelocity&lt;/code&gt; to the right values. We mark the voice as active and make both envelopes go into attack stage.&lt;br&gt;When you try to build this, you’ll get an error for trying to access &lt;code&gt;Voice&lt;/code&gt;‘s &lt;code&gt;private&lt;/code&gt; members from outside. In my opinion, the best solution here is to use the &lt;a href=&quot;http://en.wikipedia.org/wiki/Friend_class&quot;&gt;&lt;code&gt;friend&lt;/code&gt;&lt;/a&gt; keyword. Add the following line at the beginning of &lt;code&gt;public&lt;/code&gt; in &lt;em&gt;Voice.h&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;friend&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; VoiceManager;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With this line, &lt;code&gt;Voice&lt;/code&gt; gives &lt;code&gt;VoiceManager&lt;/code&gt; access to all its &lt;code&gt;private&lt;/code&gt; members. I’m no advocate of overusing this feature, but when you have a &lt;code&gt;class Foo&lt;/code&gt; and a &lt;code&gt;class FooManager&lt;/code&gt;, it’s a good way to avoid writing a lot of setters.&lt;/p&gt;
&lt;p&gt;Let’s implement &lt;code&gt;onNoteOff&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; VoiceManager::onNoteOff(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; noteNumber, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; velocity) {
    &lt;span class=&quot;comment&quot;&gt;// Find the voice(s) with the given noteNumber:&lt;/span&gt;
    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; NumberOfVoices; i++) {
        Voice&amp;amp; voice = voices[i];
        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (voice.isActive &amp;amp;&amp;amp; voice.mNoteNumber == noteNumber) {
            voice.mVolumeEnvelope.enterStage(EnvelopeGenerator::ENVELOPE_STAGE_RELEASE);
            voice.mFilterEnvelope.enterStage(EnvelopeGenerator::ENVELOPE_STAGE_RELEASE);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We’re finding all voice&lt;strong&gt;s&lt;/strong&gt; (!) with the note number that was released, and put both of their envelopes in the release stage. Why the plural? Can there be more than one active voice for a given note number?&lt;br&gt;Imagine you have a long decay on the volume envelope. You press a key on the keyboard and release it. While it’s fading out, you quickly hit that key again. Of course you don’t want to cut the old note off, and you also want to hear the new note. So you need two voices. If you have a long release time and keep hammering one key quickly, you may have a lot of active voices for a given note number.&lt;br&gt;So what happens if you have 5 active voices for the middle C and you release the key? &lt;code&gt;onNoteOff&lt;/code&gt; gets called and puts &lt;em&gt;all 5 voices&lt;/em&gt; into release stage. 4 of them were already in that stage, so let’s have a look at the first line of &lt;code&gt;EnvelopeGenerator::enterStage&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (currentStage == newStage) &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As you can see, it won’t have any effect on the 4 voices that already entered release stage. So it’s not a problem.&lt;/p&gt;
&lt;p&gt;Now let’s implement the &lt;code&gt;VoiceManager&lt;/code&gt;‘s &lt;code&gt;nextSample&lt;/code&gt; member function. It should give the summed output of all active voices.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; VoiceManager::nextSample() {
    &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; output = &lt;span class=&quot;number&quot;&gt;0.0&lt;/span&gt;;
    &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; lfoValue = mLFO.nextSample();
    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; NumberOfVoices; i++) {
        Voice&amp;amp; voice = voices[i];
        voice.setLFOValue(lfoValue);
        output += voice.nextSample();
    }
    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; output;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As you can see, we’re starting with silence (&lt;code&gt;0.0&lt;/code&gt;). We then iterate over all voices, set the current LFO value, and add the voice’s output to the sum. Remember, if the voice isn’t active, &lt;code&gt;Voice::nextSample&lt;/code&gt; will return immediately without calculating.&lt;/p&gt;
&lt;h2 id=&quot;reusable-components&quot;&gt;Reusable Components&lt;/h2&gt;
&lt;p&gt;Until now, we have created an &lt;code&gt;Oscillator&lt;/code&gt; and &lt;code&gt;Filter&lt;/code&gt; instance and have used it for the whole time our plugin is running. But our &lt;code&gt;VoiceManager&lt;/code&gt; re-uses free voices. So we need a way to reset a voice completely to its initial state. Let’s start in &lt;em&gt;Voice.h&lt;/em&gt; by adding a &lt;code&gt;public&lt;/code&gt; member function:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; reset();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Put the implementation in &lt;em&gt;Voice.cpp&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; Voice::reset() {
    mNoteNumber = -&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;
    mVelocity = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;
    mOscillatorOne.reset();
    mOscillatorTwo.reset();
    mVolumeEnvelope.reset();
    mFilterEnvelope.reset();
    mFilter.reset();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As you can see, we’re resetting &lt;code&gt;mNoteNumber&lt;/code&gt; and &lt;code&gt;mVelocity&lt;/code&gt;. We then reset the oscillators, envelopes and the filter. Let’s create these member functions! Starting in &lt;em&gt;Oscillator.h&lt;/em&gt;, add the &lt;code&gt;public&lt;/code&gt; member function:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; reset() { mPhase = &lt;span class=&quot;number&quot;&gt;0.0&lt;/span&gt;; }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This lets the waveform start from the beginning everytime a voice starts to play.&lt;br&gt;While you’re there, remove the &lt;code&gt;private&lt;/code&gt; &lt;code&gt;isMuted&lt;/code&gt; property. Also remove it from the constructor’s initializer list and remove the &lt;code&gt;public&lt;/code&gt; member function &lt;code&gt;setMuted&lt;/code&gt;. We’re now handling the active/inactive state on the &lt;code&gt;Voice&lt;/code&gt; level, so the &lt;code&gt;Oscillator&lt;/code&gt; doesn’t need it anymore. In &lt;em&gt;Oscillator.cpp&lt;/em&gt;, edit &lt;code&gt;Oscillator::nextSample&lt;/code&gt; and remove this line:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// remove this line:&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(isMuted) &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; value;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;reset&lt;/code&gt; function for the &lt;code&gt;EnvelopeGenerator&lt;/code&gt; is a little longer. Put this in &lt;code&gt;EnvelopeGenerator&lt;/code&gt;‘s &lt;code&gt;public&lt;/code&gt; section (in &lt;em&gt;EnvelopeGenerator.h&lt;/em&gt;):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; reset() {
    currentStage = ENVELOPE_STAGE_OFF;
    currentLevel = minimumLevel;
    multiplier = &lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;;
    currentSampleIndex = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;
    nextStageSampleIndex = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As you can see, we have more values to reset here, but it’s still pretty straightforward. Finally, add the function for the &lt;code&gt;Filter&lt;/code&gt; class (again, in &lt;code&gt;public&lt;/code&gt;):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; reset() {
    buf0 = buf1 = buf2 = buf3 = &lt;span class=&quot;number&quot;&gt;0.0&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As you can see from the &lt;a href=&quot;http://www.martin-finke.de/articles/audio-plugins-013-filter/#filter_algorithm&quot;&gt;filter algorithm&lt;/a&gt;, these values are the filter’s &lt;em&gt;previous output&lt;/em&gt; samples. When we re-use a voice, we want these to be clean.&lt;/p&gt;
&lt;p&gt;To summarize, whenever the &lt;code&gt;VoiceManager&lt;/code&gt; reuses a &lt;code&gt;Voice&lt;/code&gt;, it calls &lt;code&gt;reset&lt;/code&gt; on it. This, in turn, calls &lt;code&gt;reset&lt;/code&gt; on the voice’s &lt;code&gt;Oscillator&lt;/code&gt;s, the &lt;code&gt;EnvelopeGenerator&lt;/code&gt;s and the &lt;code&gt;Filter&lt;/code&gt;.  &lt;/p&gt;
&lt;h2 id=&quot;-static-or-not-static-&quot;&gt;&lt;code&gt;static&lt;/code&gt; or not &lt;code&gt;static&lt;/code&gt;?&lt;/h2&gt;
&lt;p&gt;These member variables are the same for all voices:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Oscillator&lt;/code&gt;: &lt;code&gt;mOscillatorMode&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Filter&lt;/code&gt;: &lt;code&gt;cutoff&lt;/code&gt;, &lt;code&gt;resonance&lt;/code&gt;, &lt;code&gt;mode&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;EnvelopeGenerator&lt;/code&gt;: the &lt;code&gt;stageValue&lt;/code&gt;s&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;At first I thought that this kind of duplication is evil and these things should be &lt;code&gt;static&lt;/code&gt; members. Let’s imagine that &lt;code&gt;mOscillatorMode&lt;/code&gt; was static. That would mean that our LFO always has the same waveform as our regular oscillators, which is not what we want. Also, making the &lt;code&gt;EnvelopeGenerator&lt;/code&gt;‘s &lt;code&gt;stageValue&lt;/code&gt;s &lt;code&gt;static&lt;/code&gt; would mean that the volume and filter envelope are always the same.&lt;br&gt;This could be solved through inheritance: We could make a &lt;code&gt;VolumeEnvelope&lt;/code&gt; and &lt;code&gt;FilterEnvelope&lt;/code&gt; &lt;code&gt;class&lt;/code&gt;, and have both inherit from &lt;code&gt;EnvelopeGenerator&lt;/code&gt;. &lt;code&gt;stageValue&lt;/code&gt; could be &lt;code&gt;static&lt;/code&gt;, and both &lt;code&gt;VolumeEnvelope&lt;/code&gt; and &lt;code&gt;FilterEnvelope&lt;/code&gt; could override it. That would give a clean separation between the two, and all voices would be able to share the &lt;code&gt;static&lt;/code&gt; members. But we’re not talking about a significant amount of memory here. The &lt;em&gt;overhead&lt;/em&gt; (if any) is to keep these variables in sync across all voices’ volume/filter envelopes.&lt;/p&gt;
&lt;p&gt;There’s one thing that should be &lt;code&gt;static&lt;/code&gt;, though: The &lt;code&gt;sampleRate&lt;/code&gt;. There’s no point in having different components run at different sample rates. In &lt;em&gt;Oscillator.h&lt;/em&gt;, make the &lt;code&gt;mSampleRate&lt;/code&gt; &lt;code&gt;static&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; mSampleRate;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This means that we shouldn’t initialize it through the initializer list anymore. Remove the &lt;code&gt;mSampleRate(44100.0)&lt;/code&gt;. Go into &lt;em&gt;Oscillator.cpp&lt;/em&gt; and add this line right after the &lt;code&gt;#include&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; Oscillator::mSampleRate = &lt;span class=&quot;number&quot;&gt;44100.0&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The sample rate is now &lt;code&gt;static&lt;/code&gt;, so all &lt;code&gt;Oscillator&lt;/code&gt;s use the same one.&lt;/p&gt;
&lt;p&gt;Let’s do the same for the &lt;code&gt;EnvelopeGenerator&lt;/code&gt;! Make the &lt;code&gt;private&lt;/code&gt; member &lt;code&gt;sampleRate&lt;/code&gt; &lt;code&gt;static&lt;/code&gt;, remove it from the constructor’s initializer list and add the initialization to &lt;em&gt;EnvelopeGenerator.cpp&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; EnvelopeGenerator::sampleRate = &lt;span class=&quot;number&quot;&gt;44100.0&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Back in &lt;em&gt;EnvelopeGenerator.h&lt;/em&gt;, make the setter &lt;code&gt;static&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; setSampleRate(&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; newSampleRate);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We’ve added a lot of new functionality! In the &lt;a href=&quot;http://www.martin-finke.de/articles/audio-plugins-017-polyphony-ii/&quot;&gt;next post&lt;/a&gt;, we’ll clean up and make our plugin’s knobs work again. You can download the source files &lt;a href=&quot;/blog/articles/audio-plugins-016-polyphony/source.zip&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Making Audio Plugins Part 15: Redesign</title>
      <link>http://www.martin-finke.de/blog/articles/audio-plugins-015-redesign/</link>
      <pubDate>Sun, 13 Oct 2013 20:42:00 +0200</pubDate>
      <guid isPermaLink="true">http://www.martin-finke.de/blog/articles/audio-plugins-015-redesign/</guid>
      <author></author>
      <description>&lt;p&gt;We have created the components needed for a classic subtractive synth. We will now redesign the plugin with a clear concept in mind. &lt;span class=&quot;more&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Our plugin will be a polyphonic subtractive synth called &lt;em&gt;SpaceBass&lt;/em&gt;:&lt;/p&gt;
&lt;div class=&quot;youtube-video&quot;&gt;&lt;iframe width=&quot;100%&quot; height=&quot;100%&quot; src=&quot;//www.youtube.com/embed/8cjuburLVgc?rel=0&quot; frameborder=&quot;0&quot; allowfullscreen&gt;&lt;/iframe&gt;&lt;/div&gt;

&lt;p&gt;The plugin will have two oscillators that can be mixed using the “mix” knob. All the way to the left you’ll only hear oscillator one, all the way to the right only oscillator two. At the twelve o’clock position they’ll be mixed fifty-fifty. The “pitch mod” knobs control how much the oscillator’s pitch is affected by the LFO.
The volume and filter envelope are just the ones we’ve already implemented and used.
The filter section has an added knob labelled “LFO amount”. This knob controls how much the LFO will affect the filter’s cutoff frequency.
We’re leaving a little space right of the LFO for the future.&lt;/p&gt;
&lt;p&gt;Pretty nice, right? These are the plugin’s features we have already finished:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MIDI Receiver&lt;/li&gt;
&lt;li&gt;Virtual MIDI Keyboard&lt;/li&gt;
&lt;li&gt;Oscillator&lt;/li&gt;
&lt;li&gt;Volume Envelope&lt;/li&gt;
&lt;li&gt;Multimode Filter&lt;/li&gt;
&lt;li&gt;Filter Envelope&lt;/li&gt;
&lt;li&gt;LFO&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;And this is our To-Do List for the next three posts:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;New Design&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Polyphony_and_monophony_in_instruments&quot;&gt;Polyphony&lt;/a&gt; (i.e. playing multiple notes at one time)&lt;/li&gt;
&lt;li&gt;Oscillator Mix (this is easy)&lt;/li&gt;
&lt;li&gt;Oscillator Pitch Modulation&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;As you can see, the majority of features are already done! It’s a good example of how a fresh user interface can turn things around.&lt;br&gt;First we’ll look at the Design and how it’s done in Photoshop. The main part will be polyphony, because it’ll change the structure quite a bit. Finally, we’ll add pitch modulation.&lt;/p&gt;
&lt;p&gt;This tutorial is split into three parts: This post about design, &lt;a href=&quot;http://www.martin-finke.de/articles/audio-plugins-016-polyphony/&quot;&gt;Polyphony Part I&lt;/a&gt; and &lt;a href=&quot;http://www.martin-finke.de/articles/audio-plugins-017-polyphony-ii/&quot;&gt;Polyphony Part II&lt;/a&gt;. The polyphony part is split into two posts because it’ll take some work. I hope what I’ve written is clear and easy to follow. If you get stuck somewhere, please don’t hesitate to write a comment, and I’ll help you out.&lt;/p&gt;
&lt;h2 id=&quot;a-new-design&quot;&gt;A New Design&lt;/h2&gt;
&lt;p&gt;The knob is a slightly modified version of &lt;a href=&quot;http://www.lesliesanford.com/KnobManStuff/Knobs.shtml&quot;&gt;Leslie Sanford’s Boss-like Knob&lt;/a&gt;. I’ve just made it smaller, the line is longer and the shadow is slightly different. You can download the modified version &lt;a href=&quot;/blog/articles/audio-plugins-015-redesign/BossLikeKnob.knob&quot;&gt;here&lt;/a&gt;. The keyboard at the bottom was done using &lt;a href=&quot;http://naldzgraphics.net/tutorials/piano-app-ui-in-photoshop/&quot;&gt;this tutorial&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;I will not explain every step about how to create the GUI in Photoshop, but we’ll have a look at the various layers and how things are done. &lt;a href=&quot;/blog/articles/audio-plugins-015-redesign/gui.tif.zip&quot;&gt;Download the zipped TIF file&lt;/a&gt;, unpack it and open the TIF file in Photoshop (or GIMP). I’ve tried to leave everything intact and non-destructive so you can go into the layers and see how everything’s done. If you want to change text. you’ll need two fonts: &lt;a href=&quot;http://www.formfett.net/tusj-one-handwritten-font/&quot;&gt;Tusj&lt;/a&gt; for the logo and &lt;a href=&quot;http://best-font.com/font/Avenir85Heavy8532.html&quot;&gt;Avenir 85 Heavy&lt;/a&gt; for the labels.&lt;br&gt;&lt;em&gt;EDIT: Unfortunately, Avenir is not free anymore, but you can use Helvetica as a replacement&lt;/em&gt;.&lt;br&gt;Download the Tusj font and put it in &lt;em&gt;~/Library/Fonts/&lt;/em&gt; (&lt;a href=&quot;http://support.microsoft.com/kb/314960/en-us&quot;&gt;click here&lt;/a&gt; if you’re using Windows).&lt;/p&gt;
&lt;h2 id=&quot;smart-objects-and-vector-shapes&quot;&gt;Smart Objects and Vector Shapes&lt;/h2&gt;
&lt;p&gt;If you browse through the layers in Photohop, you’ll notice that most things are based on vectors and &lt;a href=&quot;http://help.adobe.com/en_US/photoshop/cs/using/WS41A5B796-6846-4e95-8459-95243441E126.html&quot;&gt;smart objects&lt;/a&gt;. I highly recommend using smart objects whenever:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;You need the same component (e.g. the knob) in more than one place&lt;/li&gt;
&lt;li&gt;You want to apply effects to a group (and you’re using a Photoshop version prior to CS6)&lt;/li&gt;
&lt;li&gt;You want to rotate something non-destructively, i.e. when you rotate it back, there’ll be no quality loss.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The first point is true for the knob and the waveform switch. Both appear in several places and look exactly the same. Select the &lt;em&gt;Move&lt;/em&gt; tool (by pressing &lt;em&gt;V&lt;/em&gt;). Now click on a waveform switch while holding the Cmd key. In the layer palette a layer named &lt;em&gt;Shapes&lt;/em&gt; will be highlighted. Double-click its preview icon to open the smart object. As you can see, the waveforms are vector shapes:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/blog/articles/audio-plugins-015-redesign/shapes.png&quot;&gt;&lt;img src=&quot;/blog/articles/audio-plugins-015-redesign/shapes.png&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The advantage of vector shapes is that you can scale, rotate and otherwise modify them as much as you want &lt;em&gt;without loss&lt;/em&gt;. So if at some point we need a GUI for &lt;a href=&quot;http://en.wikipedia.org/wiki/Retina_Display&quot;&gt;retina displays&lt;/a&gt;, we can just scale the image! Of course we would have to export the knob again from JKnobMan, but since all knobs in the TIF are the same smart object, it would be very easy to replace them.&lt;/p&gt;
&lt;p&gt;Let’s investigate the &lt;em&gt;Keyboard&lt;/em&gt; layer group. You can see that there are four octaves. An octave is a smart object, so if we make a change to one octave, it will be reflected in all of them. Open &lt;em&gt;Octave 4&lt;/em&gt; (by double-clicking the layer icon). Look at the layer palette:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/blog/articles/audio-plugins-015-redesign/key-layers.png&quot;&gt;&lt;img src=&quot;/blog/articles/audio-plugins-015-redesign/key-layers.png&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Here, all black keys point to the same smart object; and all white keys point to one smart object. Double-click any of the icons to open a black key. Now look at the layer palette: You can see that the black key consists of three vector shapes:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/blog/articles/audio-plugins-015-redesign/black-key-layers.png&quot;&gt;&lt;img src=&quot;/blog/articles/audio-plugins-015-redesign/black-key-layers.png&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Imagine we want the black keys to have slightly more rounded edges. If we had just used &lt;em&gt;duplicate layer&lt;/em&gt; to get all the black keys, we’d be in trouble! But with this &lt;a href=&quot;http://en.wikipedia.org/wiki/Inception&quot;&gt;Inception&lt;/a&gt;-style use of smart objects, it’s just a matter of modifying the black key &lt;em&gt;once&lt;/em&gt; and it’ll be applied to all black keys.&lt;/p&gt;
&lt;p&gt;Keep the following points in mind when using Photoshop:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Work &lt;em&gt;non-destructively&lt;/em&gt; whenever possible.
Use &lt;a href=&quot;http://bigstockblog.squarespace.com/blog/what-are-smart-filters-and-why-should-i-use-them&quot;&gt;smart filters&lt;/a&gt;,  don’t scale bitmap content, and avoid rasterizing layers. If you rasterize something, be aware that &lt;em&gt;you lose all information about how that thing was done&lt;/em&gt;. If you absolutely have to, make sure you leave a backup copy in case you have to go back.&lt;/li&gt;
&lt;li&gt;Avoid duplication by using smart objects.
Whenever you duplicate something, ask yourself whether you’re going to modify the copy. If you just need a duplicate copy, you should probably convert it to a smart object first.&lt;/li&gt;
&lt;li&gt;Use the &lt;a href=&quot;http://psd.tutsplus.com/tutorials/tools-tips/photoshops-pen-tool-the-comprehensive-guide/&quot;&gt;pen tool&lt;/a&gt; to resize things like rounded rectangles (and other vector shapes). That way, you’ll leave the rounded edges intact.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;When you design your own virtual keyboard, here are a few hints:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;When you design the normal (non-pressed) keys, keep in mind that you’ll need &lt;em&gt;darker&lt;/em&gt; versions for the pressed state. If your black keys look like a solid black bar in the normal state, it’ll be difficult to make them look “more pressed” than that.&lt;/li&gt;
&lt;li&gt;Make sure all white keys have the same width and all black keys have the same width.&lt;/li&gt;
&lt;li&gt;For pressed keys, C &amp;amp; F and E and B will have the same graphic. Make sure C♯ &amp;amp; F♯ and E♭ &amp;amp; B♭ have the same offset, otherwise you’ll get overlaps or gaps.&lt;/li&gt;
&lt;li&gt;When you design the pressed keys, avoid semi-transparent overlap. Use layer masks to make sure that each pressed key only affects its own area. If it has drop shadow or outer glow, they won’t be visible when using &lt;code&gt;IKeyboardControl&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;IKeyboardControl&lt;/code&gt; expects the highest key to be a C, so you’ll need a white key without a black key on top. If you’re working non-destructively, this shouldn’t be a problem.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Here’s another small hint: The letter “S” appears three times in the “SPACE BASS” logo text. With a grungy font like this, it’s unnatural if all S’s have the exact same dirt around them. So I used a layer mask to hide little bits of dirt here and there. Now each of them looks slightly different, which is more realistic.&lt;/p&gt;
&lt;h2 id=&quot;exporting-graphics&quot;&gt;Exporting Graphics&lt;/h2&gt;
&lt;p&gt;We have to export the GUI components as separate PNG files, so we can reference them from our plugin code. You can do the export by hand, or you can just download the following six files.&lt;br&gt;The background image contains all the static parts and the virtual keyboard with all keys in unpressed state:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/blog/articles/audio-plugins-015-redesign/bg.png&quot;&gt;&lt;img src=&quot;/blog/articles/audio-plugins-015-redesign/bg.png&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Here are the switches for waveform and filter mode:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/blog/articles/audio-plugins-015-redesign/waveform.png&quot;&gt;&lt;img src=&quot;/blog/articles/audio-plugins-015-redesign/waveform.png&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/blog/articles/audio-plugins-015-redesign/filtermode.png&quot;&gt;&lt;img src=&quot;/blog/articles/audio-plugins-015-redesign/filtermode.png&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;And the knob. I’m hiding the other knob turn states here, but they’re contained in the image file:&lt;/p&gt;
&lt;div class=&quot;mask height-64&quot;&gt;&lt;a href=&quot;/blog/articles/audio-plugins-015-redesign/knob.png&quot;&gt;&lt;img src=&quot;/blog/articles/audio-plugins-015-redesign/knob.png&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/div&gt;

&lt;p&gt;Recall that &lt;a href=&quot;http://www.martin-finke.de/articles/audio-plugins-010-virtual-keyboard/#virtual_keyboard_white_key_frames&quot;&gt;the &lt;code&gt;IKeyboardControl&lt;/code&gt; needs &lt;em&gt;six&lt;/em&gt; pressed white keys&lt;/a&gt;: C/F, D, E/B, G, A and high C. Here’s the PNG with all of them below one another:&lt;/p&gt;
&lt;div class=&quot;key-sprite-wrapper&quot;&gt;
&lt;a href=&quot;/blog/articles/audio-plugins-015-redesign/whitekey.png&quot;&gt;&lt;img src=&quot;/blog/articles/audio-plugins-015-redesign/whitekey.png&quot; alt=&quot;&quot;&gt;&lt;/a&gt;
&lt;div class=&quot;key-description number-1&quot;&gt;C/F&lt;/div&gt;
&lt;div class=&quot;key-description number-2&quot;&gt;D&lt;/div&gt;
&lt;div class=&quot;key-description number-3&quot;&gt;E/B&lt;/div&gt;
&lt;div class=&quot;key-description number-4&quot;&gt;G&lt;/div&gt;
&lt;div class=&quot;key-description number-5&quot;&gt;A&lt;/div&gt;
&lt;div class=&quot;key-description number-6&quot;&gt;high C&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;The black keys are simpler. There’s just one pressed image for all of them:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/blog/articles/audio-plugins-015-redesign/blackkey.png&quot;&gt;&lt;img src=&quot;/blog/articles/audio-plugins-015-redesign/blackkey.png&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;implementing-the-gui-in-code&quot;&gt;Implementing the GUI in Code&lt;/h2&gt;
&lt;p&gt;Instead of starting from scratch, let’s clone our &lt;em&gt;Synthesis&lt;/em&gt; project. Open &lt;em&gt;Terminal.app&lt;/em&gt;, &lt;code&gt;cd&lt;/code&gt; into the &lt;em&gt;IPlugExamples&lt;/em&gt; folder and run the &lt;code&gt;duplicate&lt;/code&gt; script:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cd ~/plugin-development/wdl-ol/IPlugExamples/
./duplicate.py Synthesis/ SpaceBass YourName
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If you haven’t followed the previous posts, you can download the &lt;em&gt;Synthesis&lt;/em&gt; project from &lt;a href=&quot;/blog/articles/audio-plugins-015-redesign/Synthesis_finished.zip&quot;&gt;here&lt;/a&gt;. Unzip that and run the &lt;code&gt;duplicate&lt;/code&gt; script.&lt;/p&gt;
&lt;p&gt;Copy all six image files you downloaded (or exported) above to the newly created &lt;em&gt;SpaceBass&lt;/em&gt; folder and overwrite the existing files. Now open &lt;em&gt;SpaceBass.xcodeproj&lt;/em&gt;. We don’t need the &lt;em&gt;knob_small.png&lt;/em&gt; anymore. In the project navigator, go to &lt;em&gt;Resources&lt;/em&gt; → &lt;em&gt;img&lt;/em&gt;, right-click &lt;em&gt;knob_small.png&lt;/em&gt; and choose &lt;em&gt;Delete&lt;/em&gt;. From the popup, choose &lt;em&gt;Move to Trash&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Since we’re using the same filenames as before, we only have to make two minor changes to &lt;em&gt;resource.h&lt;/em&gt;. Remove the &lt;code&gt;KNOB_SMALL_ID&lt;/code&gt; and &lt;code&gt;KNOB_SMALL_FN&lt;/code&gt;, so the code looks like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Unique IDs for each image resource.&lt;/span&gt;
&lt;span class=&quot;preprocessor&quot;&gt;#define BG_ID         101&lt;/span&gt;
&lt;span class=&quot;preprocessor&quot;&gt;#define WHITE_KEY_ID  102&lt;/span&gt;
&lt;span class=&quot;preprocessor&quot;&gt;#define BLACK_KEY_ID  103&lt;/span&gt;
&lt;span class=&quot;preprocessor&quot;&gt;#define WAVEFORM_ID   104&lt;/span&gt;
&lt;span class=&quot;preprocessor&quot;&gt;#define KNOB_ID       105&lt;/span&gt;
&lt;span class=&quot;preprocessor&quot;&gt;#define FILTERMODE_ID 106&lt;/span&gt;

&lt;span class=&quot;comment&quot;&gt;// Image resource locations for this plug.&lt;/span&gt;
&lt;span class=&quot;preprocessor&quot;&gt;#define BG_FN         &quot;resources/img/bg.png&quot;&lt;/span&gt;
&lt;span class=&quot;preprocessor&quot;&gt;#define WHITE_KEY_FN  &quot;resources/img/whitekey.png&quot;&lt;/span&gt;
&lt;span class=&quot;preprocessor&quot;&gt;#define BLACK_KEY_FN  &quot;resources/img/blackkey.png&quot;&lt;/span&gt;
&lt;span class=&quot;preprocessor&quot;&gt;#define WAVEFORM_FN   &quot;resources/img/waveform.png&quot;&lt;/span&gt;
&lt;span class=&quot;preprocessor&quot;&gt;#define KNOB_FN       &quot;resources/img/knob.png&quot;&lt;/span&gt;
&lt;span class=&quot;preprocessor&quot;&gt;#define FILTERMODE_FN &quot;resources/img/filtermode.png&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Also, our GUI has become a little larger. Change the dimensions to match those of &lt;em&gt;bg.png&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// GUI default dimensions&lt;/span&gt;
&lt;span class=&quot;preprocessor&quot;&gt;#define GUI_WIDTH 571&lt;/span&gt;
&lt;span class=&quot;preprocessor&quot;&gt;#define GUI_HEIGHT 500&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Modify the top of &lt;em&gt;SpaceBass.rc&lt;/em&gt; to contain the new graphics:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#include &quot;resource.h&quot;&lt;/span&gt;

BG_ID       PNG BG_FN
WHITE_KEY_ID       PNG WHITE_KEY_FN
BLACK_KEY_ID       PNG BLACK_KEY_FN
WAVEFORM_ID       PNG WAVEFORM_FN
KNOB_ID       PNG KNOB_FN
FILTERMODE_ID       PNG FILTERMODE_FN
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now let’s make a small change to our &lt;code&gt;Oscillator&lt;/code&gt; class: We’re going to move the &lt;code&gt;enum OscillatorMode&lt;/code&gt; inside the class, so it’s accessed as &lt;code&gt;Oscillator::OscillatorMode&lt;/code&gt; from outside. We’ve done it like this in the &lt;code&gt;Filter&lt;/code&gt; and &lt;code&gt;EnvelopeGenerator&lt;/code&gt; classes, so it’s a good idea to change it here, too.&lt;br&gt;First, swap the &lt;code&gt;public&lt;/code&gt; and &lt;code&gt;private&lt;/code&gt; sections, so &lt;code&gt;public&lt;/code&gt; is before &lt;code&gt;private&lt;/code&gt;. Then, move the &lt;code&gt;enum OscillatorMode&lt;/code&gt; from outside the class to the top of the &lt;code&gt;public&lt;/code&gt; section. It should now look like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; Oscillator {
&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:
    &lt;span class=&quot;keyword&quot;&gt;enum&lt;/span&gt; OscillatorMode {
        OSCILLATOR_MODE_SINE = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,
        OSCILLATOR_MODE_SAW,
        OSCILLATOR_MODE_SQUARE,
        OSCILLATOR_MODE_TRIANGLE,
        kNumOscillatorModes
    };
    &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; setMode(OscillatorMode mode);
    &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; setFrequency(&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; frequency);
    &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; setSampleRate(&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; sampleRate);
    &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; generate(&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt;* buffer, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; nFrames);
    &lt;span class=&quot;keyword&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; setMuted(&lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt; muted) { isMuted = muted; }
    &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; nextSample();
    Oscillator() :
        mOscillatorMode(OSCILLATOR_MODE_SINE),
        mPI(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;*&lt;span class=&quot;built_in&quot;&gt;acos&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;0.0&lt;/span&gt;)),
        twoPI(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; * mPI),
        isMuted(&lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;),
        mFrequency(&lt;span class=&quot;number&quot;&gt;440.0&lt;/span&gt;),
        mPhase(&lt;span class=&quot;number&quot;&gt;0.0&lt;/span&gt;),
    mSampleRate(&lt;span class=&quot;number&quot;&gt;44100.0&lt;/span&gt;) { updateIncrement(); };
&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt;:
    OscillatorMode mOscillatorMode;
    &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; mPI;
    &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; twoPI;
    &lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt; isMuted;
    &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; mFrequency;
    &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; mPhase;
    &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; mSampleRate;
    &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; mPhaseIncrement;
    &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; updateIncrement();
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let’s get busy with the actual GUI code! Starting in &lt;em&gt;SpaceBass.h&lt;/em&gt;, add the following &lt;code&gt;private&lt;/code&gt; member functions:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; CreateParams();
&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; CreateGraphics();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;These are just to remove all the GUI code from the constructor. While you’re there, remove the &lt;code&gt;double mFrequency&lt;/code&gt; if you like. We don’t need it anymore. Now let’s move on to &lt;em&gt;SpaceBass.cpp&lt;/em&gt;. Right above &lt;code&gt;enum EParams&lt;/code&gt;, add the following constant:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; parameterStep = &lt;span class=&quot;number&quot;&gt;0.001&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is the “precision” at which the user can move a knob in the GUI. It’s used for every knob, so it’s a good idea to create a constant instead of hardcoding it all over the place.&lt;br&gt;Our plugin has more parameters than before. Change &lt;code&gt;EParams&lt;/code&gt; to this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;enum&lt;/span&gt; EParams
{
    &lt;span class=&quot;comment&quot;&gt;// Oscillator Section:&lt;/span&gt;
    mOsc1Waveform = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,
    mOsc1PitchMod,
    mOsc2Waveform,
    mOsc2PitchMod,
    mOscMix,
    &lt;span class=&quot;comment&quot;&gt;// Filter Section:&lt;/span&gt;
    mFilterMode,
    mFilterCutoff,
    mFilterResonance,
    mFilterLfoAmount,
    mFilterEnvAmount,
    &lt;span class=&quot;comment&quot;&gt;// LFO:&lt;/span&gt;
    mLFOWaveform,
    mLFOFrequency,
    &lt;span class=&quot;comment&quot;&gt;// Volume Envelope:&lt;/span&gt;
    mVolumeEnvAttack,
    mVolumeEnvDecay,
    mVolumeEnvSustain,
    mVolumeEnvRelease,
    &lt;span class=&quot;comment&quot;&gt;// Filter Envelope:&lt;/span&gt;
    mFilterEnvAttack,
    mFilterEnvDecay,
    mFilterEnvSustain,
    mFilterEnvRelease,
    kNumParams
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The location of the virtual keyboard has changed, too. Change &lt;code&gt;ELayout&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;enum&lt;/span&gt; ELayout
{
    kWidth = GUI_WIDTH,
    kHeight = GUI_HEIGHT,
    kKeybX = &lt;span class=&quot;number&quot;&gt;62&lt;/span&gt;,
    kKeybY = &lt;span class=&quot;number&quot;&gt;425&lt;/span&gt;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;all-parameters-in-one-place&quot;&gt;All Parameters in One Place&lt;/h2&gt;
&lt;p&gt;Instead of having a lot of &lt;code&gt;InitDouble()&lt;/code&gt; and &lt;code&gt;new IKnobMultiControl&lt;/code&gt; calls like before, let’s move all information about our GUI to its own data structure. Add this &lt;code&gt;struct&lt;/code&gt; below &lt;code&gt;EParams&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; {
    &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt;* name;
    &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; x;
    &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; y;
    &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; defaultVal;
    &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; minVal;
    &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; maxVal;
} parameterProperties_struct;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So this contains the parameter &lt;code&gt;name&lt;/code&gt;, the gui coordinates of the knob (or switch), and default/min/max values (if the parameter is a &lt;code&gt;double&lt;/code&gt;). For the three switches, we’re not going to use &lt;code&gt;default&lt;/code&gt;/&lt;code&gt;min&lt;/code&gt;/&lt;code&gt;maxVal&lt;/code&gt;. Because of the static typing, that would make things overly complicated.&lt;br&gt;Below that, we’ll create a data structure that holds (almost) our parameter data. We need one &lt;code&gt;parameterProperties_struct&lt;/code&gt; for every parameter, so it’ll be an array of length &lt;code&gt;kNumParams&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; parameterProperties_struct parameterProperties[kNumParams] =
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Below that, add the actual values. Note that we’re leaving the &lt;code&gt;default&lt;/code&gt;/&lt;code&gt;min&lt;/code&gt;/&lt;code&gt;maxVal&lt;/code&gt;s uninitialized for the &lt;code&gt;enum&lt;/code&gt; type parameters like &lt;em&gt;Filter Mode&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;{
    {.name=&lt;span class=&quot;string&quot;&gt;&quot;Osc 1 Waveform&quot;&lt;/span&gt;, .x=&lt;span class=&quot;number&quot;&gt;30&lt;/span&gt;, .y=&lt;span class=&quot;number&quot;&gt;75&lt;/span&gt;},
    {.name=&lt;span class=&quot;string&quot;&gt;&quot;Osc 1 Pitch Mod&quot;&lt;/span&gt;, .x=&lt;span class=&quot;number&quot;&gt;69&lt;/span&gt;, .y=&lt;span class=&quot;number&quot;&gt;61&lt;/span&gt;, .defaultVal=&lt;span class=&quot;number&quot;&gt;0.0&lt;/span&gt;, .minVal=&lt;span class=&quot;number&quot;&gt;0.0&lt;/span&gt;, .maxVal=&lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;},
    {.name=&lt;span class=&quot;string&quot;&gt;&quot;Osc 2 Waveform&quot;&lt;/span&gt;, .x=&lt;span class=&quot;number&quot;&gt;203&lt;/span&gt;, .y=&lt;span class=&quot;number&quot;&gt;75&lt;/span&gt;},
    {.name=&lt;span class=&quot;string&quot;&gt;&quot;Osc 2 Pitch Mod&quot;&lt;/span&gt;, .x=&lt;span class=&quot;number&quot;&gt;242&lt;/span&gt;, .y=&lt;span class=&quot;number&quot;&gt;61&lt;/span&gt;, .defaultVal=&lt;span class=&quot;number&quot;&gt;0.0&lt;/span&gt;, .minVal=&lt;span class=&quot;number&quot;&gt;0.0&lt;/span&gt;, .maxVal=&lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;},
    {.name=&lt;span class=&quot;string&quot;&gt;&quot;Osc Mix&quot;&lt;/span&gt;, .x=&lt;span class=&quot;number&quot;&gt;130&lt;/span&gt;, .y=&lt;span class=&quot;number&quot;&gt;61&lt;/span&gt;, .defaultVal=&lt;span class=&quot;number&quot;&gt;0.5&lt;/span&gt;, .minVal=&lt;span class=&quot;number&quot;&gt;0.0&lt;/span&gt;, .maxVal=&lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;},
    {.name=&lt;span class=&quot;string&quot;&gt;&quot;Filter Mode&quot;&lt;/span&gt;, .x=&lt;span class=&quot;number&quot;&gt;30&lt;/span&gt;, .y=&lt;span class=&quot;number&quot;&gt;188&lt;/span&gt;},
    {.name=&lt;span class=&quot;string&quot;&gt;&quot;Filter Cutoff&quot;&lt;/span&gt;, .x=&lt;span class=&quot;number&quot;&gt;69&lt;/span&gt;, .y=&lt;span class=&quot;number&quot;&gt;174&lt;/span&gt;, .defaultVal=&lt;span class=&quot;number&quot;&gt;0.99&lt;/span&gt;, .minVal=&lt;span class=&quot;number&quot;&gt;0.0&lt;/span&gt;, .maxVal=&lt;span class=&quot;number&quot;&gt;0.99&lt;/span&gt;},
    {.name=&lt;span class=&quot;string&quot;&gt;&quot;Filter Resonance&quot;&lt;/span&gt;, .x=&lt;span class=&quot;number&quot;&gt;124&lt;/span&gt;, .y=&lt;span class=&quot;number&quot;&gt;174&lt;/span&gt;, .defaultVal=&lt;span class=&quot;number&quot;&gt;0.0&lt;/span&gt;, .minVal=&lt;span class=&quot;number&quot;&gt;0.0&lt;/span&gt;, .maxVal=&lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;},
    {.name=&lt;span class=&quot;string&quot;&gt;&quot;Filter LFO Amount&quot;&lt;/span&gt;, .x=&lt;span class=&quot;number&quot;&gt;179&lt;/span&gt;, .y=&lt;span class=&quot;number&quot;&gt;174&lt;/span&gt;, .defaultVal=&lt;span class=&quot;number&quot;&gt;0.0&lt;/span&gt;, .minVal=&lt;span class=&quot;number&quot;&gt;0.0&lt;/span&gt;, .maxVal=&lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;},
    {.name=&lt;span class=&quot;string&quot;&gt;&quot;Filter Envelope Amount&quot;&lt;/span&gt;, .x=&lt;span class=&quot;number&quot;&gt;234&lt;/span&gt;, .y=&lt;span class=&quot;number&quot;&gt;174&lt;/span&gt;, .defaultVal=&lt;span class=&quot;number&quot;&gt;0.0&lt;/span&gt;, .minVal=-&lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;, .maxVal=&lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;},
    {.name=&lt;span class=&quot;string&quot;&gt;&quot;LFO Waveform&quot;&lt;/span&gt;, .x=&lt;span class=&quot;number&quot;&gt;30&lt;/span&gt;, .y=&lt;span class=&quot;number&quot;&gt;298&lt;/span&gt;},
    {.name=&lt;span class=&quot;string&quot;&gt;&quot;LFO Frequency&quot;&lt;/span&gt;, .x=&lt;span class=&quot;number&quot;&gt;69&lt;/span&gt;, .y=&lt;span class=&quot;number&quot;&gt;284&lt;/span&gt;, .defaultVal=&lt;span class=&quot;number&quot;&gt;6.0&lt;/span&gt;, .minVal=&lt;span class=&quot;number&quot;&gt;0.01&lt;/span&gt;, .maxVal=&lt;span class=&quot;number&quot;&gt;30.0&lt;/span&gt;},
    {.name=&lt;span class=&quot;string&quot;&gt;&quot;Volume Env Attack&quot;&lt;/span&gt;, .x=&lt;span class=&quot;number&quot;&gt;323&lt;/span&gt;, .y=&lt;span class=&quot;number&quot;&gt;61&lt;/span&gt;, .defaultVal=&lt;span class=&quot;number&quot;&gt;0.01&lt;/span&gt;, .minVal=&lt;span class=&quot;number&quot;&gt;0.01&lt;/span&gt;, .maxVal=&lt;span class=&quot;number&quot;&gt;10.0&lt;/span&gt;},
    {.name=&lt;span class=&quot;string&quot;&gt;&quot;Volume Env Decay&quot;&lt;/span&gt;, .x=&lt;span class=&quot;number&quot;&gt;378&lt;/span&gt;, .y=&lt;span class=&quot;number&quot;&gt;61&lt;/span&gt;, .defaultVal=&lt;span class=&quot;number&quot;&gt;0.5&lt;/span&gt;, .minVal=&lt;span class=&quot;number&quot;&gt;0.01&lt;/span&gt;, .maxVal=&lt;span class=&quot;number&quot;&gt;15.0&lt;/span&gt;},
    {.name=&lt;span class=&quot;string&quot;&gt;&quot;Volume Env Sustain&quot;&lt;/span&gt;, .x=&lt;span class=&quot;number&quot;&gt;433&lt;/span&gt;, .y=&lt;span class=&quot;number&quot;&gt;61&lt;/span&gt;, .defaultVal=&lt;span class=&quot;number&quot;&gt;0.1&lt;/span&gt;, .minVal=&lt;span class=&quot;number&quot;&gt;0.001&lt;/span&gt;, .maxVal=&lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;},
    {.name=&lt;span class=&quot;string&quot;&gt;&quot;Volume Env Release&quot;&lt;/span&gt;, .x=&lt;span class=&quot;number&quot;&gt;488&lt;/span&gt;, .y=&lt;span class=&quot;number&quot;&gt;61&lt;/span&gt;, .defaultVal=&lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;, .minVal=&lt;span class=&quot;number&quot;&gt;0.01&lt;/span&gt;, .maxVal=&lt;span class=&quot;number&quot;&gt;15.0&lt;/span&gt;},
    {.name=&lt;span class=&quot;string&quot;&gt;&quot;Filter Env Attack&quot;&lt;/span&gt;, .x=&lt;span class=&quot;number&quot;&gt;323&lt;/span&gt;, .y=&lt;span class=&quot;number&quot;&gt;174&lt;/span&gt;, .defaultVal=&lt;span class=&quot;number&quot;&gt;0.01&lt;/span&gt;, .minVal=&lt;span class=&quot;number&quot;&gt;0.01&lt;/span&gt;, .maxVal=&lt;span class=&quot;number&quot;&gt;10.0&lt;/span&gt;},
    {.name=&lt;span class=&quot;string&quot;&gt;&quot;Filter Env Decay&quot;&lt;/span&gt;, .x=&lt;span class=&quot;number&quot;&gt;378&lt;/span&gt;, .y=&lt;span class=&quot;number&quot;&gt;174&lt;/span&gt;, .defaultVal=&lt;span class=&quot;number&quot;&gt;0.5&lt;/span&gt;, .minVal=&lt;span class=&quot;number&quot;&gt;0.01&lt;/span&gt;, .maxVal=&lt;span class=&quot;number&quot;&gt;15.0&lt;/span&gt;},
    {.name=&lt;span class=&quot;string&quot;&gt;&quot;Filter Env Sustain&quot;&lt;/span&gt;, .x=&lt;span class=&quot;number&quot;&gt;433&lt;/span&gt;, .y=&lt;span class=&quot;number&quot;&gt;174&lt;/span&gt;, .defaultVal=&lt;span class=&quot;number&quot;&gt;0.1&lt;/span&gt;, .minVal=&lt;span class=&quot;number&quot;&gt;0.001&lt;/span&gt;, .maxVal=&lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;},
    {.name=&lt;span class=&quot;string&quot;&gt;&quot;Filter Env Release&quot;&lt;/span&gt;, .x=&lt;span class=&quot;number&quot;&gt;488&lt;/span&gt;, .y=&lt;span class=&quot;number&quot;&gt;174&lt;/span&gt;, .defaultVal=&lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;, .minVal=&lt;span class=&quot;number&quot;&gt;0.01&lt;/span&gt;, .maxVal=&lt;span class=&quot;number&quot;&gt;15.0&lt;/span&gt;}
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;What a monster! The &lt;code&gt;{}&lt;/code&gt; brace syntax is (relatively) newschool C/C++ and is called a &lt;a href=&quot;http://www.drdobbs.com/the-new-c-compound-literals/184401404&quot;&gt;compound literal&lt;/a&gt;. Basically you can initialize &lt;code&gt;struct&lt;/code&gt;s and C arrays like this. So the outer braces initialize the &lt;code&gt;parameterProperties[]&lt;/code&gt; array. They contain a comma-separated list of compound literals. Each of these initializes one &lt;code&gt;parameterProperties_struct&lt;/code&gt;. Let’s look at the first of them:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;{.name=&lt;span class=&quot;string&quot;&gt;&quot;Osc 1 Waveform&quot;&lt;/span&gt;, .x=&lt;span class=&quot;number&quot;&gt;30&lt;/span&gt;, .y=&lt;span class=&quot;number&quot;&gt;75&lt;/span&gt;}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In oldschool C, we’d have to write this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;parameterProperties_struct* osc1Waveform_prop = parameterProperties[mOsc1Waveform];
osc1Waveform_prop-&amp;gt;name = &lt;span class=&quot;string&quot;&gt;&quot;Osc 1 Waveform&quot;&lt;/span&gt;;
osc1Waveform_prop-&amp;gt;x = &lt;span class=&quot;number&quot;&gt;30&lt;/span&gt;;
osc1Waveform_prop-&amp;gt;y = &lt;span class=&quot;number&quot;&gt;75&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And we’d have to do that for each parameter!&lt;br&gt;The “classic” way to use compound literals for &lt;code&gt;struct&lt;/code&gt;s is:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;{&lt;span class=&quot;string&quot;&gt;&quot;Osc 1 Waveform&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;30&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;75&lt;/span&gt;}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Okay, this is nice and short, but also error-prone. If we add something to the beginning of &lt;code&gt;struct&lt;/code&gt; or change the order of members, we’ll be in trouble. A better way (though it’s more code to type) is to use &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/gcc/Designated-Inits.html&quot;&gt;designated initializers&lt;/a&gt;. This just means accessing &lt;code&gt;struct&lt;/code&gt; members with the &lt;code&gt;.membername=&lt;/code&gt; notation. It gives us the final form, which looks a little like &lt;a href=&quot;http://en.wikipedia.org/wiki/JSON#Data_types.2C_syntax_and_example&quot;&gt;JSON&lt;/a&gt; or &lt;a href=&quot;http://www.ruby-doc.org/core-2.0.0/Hash.html&quot;&gt;Ruby Hashes&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;{.name=&lt;span class=&quot;string&quot;&gt;&quot;Osc 1 Waveform&quot;&lt;/span&gt;, .x=&lt;span class=&quot;number&quot;&gt;30&lt;/span&gt;, .y=&lt;span class=&quot;number&quot;&gt;75&lt;/span&gt;}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;creating-the-parameters&quot;&gt;Creating the Parameters&lt;/h2&gt;
&lt;p&gt;We have added the two member functions &lt;code&gt;CreateParams&lt;/code&gt; and &lt;code&gt;CreateGraphics&lt;/code&gt;. Our constructor now becomes very simple:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;SpaceBass::SpaceBass(IPlugInstanceInfo instanceInfo) :
    IPLUG_CTOR(kNumParams, kNumPrograms, instanceInfo),
    lastVirtualKeyboardNoteNumber(virtualKeyboardMinimumNoteNumber - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)
{
    TRACE;

    CreateParams();
    CreateGraphics();
    CreatePresets();

    mMIDIReceiver.noteOn.Connect(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, &amp;amp;SpaceBass::onNoteOn);
    mMIDIReceiver.noteOff.Connect(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, &amp;amp;SpaceBass::onNoteOff);
    mEnvelopeGenerator.beganEnvelopeCycle.Connect(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, &amp;amp;SpaceBass::onBeganEnvelopeCycle);
    mEnvelopeGenerator.finishedEnvelopeCycle.Connect(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, &amp;amp;SpaceBass::onFinishedEnvelopeCycle);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Pretty straightforward, isn’t it? Instead of doing the &lt;code&gt;GetParam()&lt;/code&gt; and &lt;code&gt;pGraphics&lt;/code&gt; stuff here, we’re moving it out.&lt;br&gt;Let’s implement &lt;code&gt;CreateParams&lt;/code&gt;!&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; SpaceBass::CreateParams() {
    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; kNumParams; i++) {
        IParam* param = GetParam(i);
        &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; parameterProperties_struct&amp;amp; properties = parameterProperties[i];
        &lt;span class=&quot;keyword&quot;&gt;switch&lt;/span&gt; (i) {
            &lt;span class=&quot;comment&quot;&gt;// Enum Parameters:&lt;/span&gt;
            &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; mOsc1Waveform:
            &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; mOsc2Waveform:
                param-&amp;gt;InitEnum(properties.name,
                    Oscillator::OSCILLATOR_MODE_SAW,
                    Oscillator::kNumOscillatorModes);
                &lt;span class=&quot;comment&quot;&gt;// For VST3:&lt;/span&gt;
                param-&amp;gt;SetDisplayText(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, properties.name);
                &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;
            &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; mLFOWaveform:
                param-&amp;gt;InitEnum(properties.name,
                    Oscillator::OSCILLATOR_MODE_TRIANGLE,
                    Oscillator::kNumOscillatorModes);
                &lt;span class=&quot;comment&quot;&gt;// For VST3:&lt;/span&gt;
                param-&amp;gt;SetDisplayText(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, properties.name);
                &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;
            &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; mFilterMode:
                param-&amp;gt;InitEnum(properties.name,
                    Filter::FILTER_MODE_LOWPASS,
                    Filter::kNumFilterModes);
                &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;
            &lt;span class=&quot;comment&quot;&gt;// Double Parameters:&lt;/span&gt;
            &lt;span class=&quot;keyword&quot;&gt;default&lt;/span&gt;:
                param-&amp;gt;InitDouble(properties.name,
                    properties.defaultVal,
                    properties.minVal,
                    properties.maxVal,
                    parameterStep);
                &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So we’re iterating over all parameters. First we get the right properties from the data structure we just created. Then we use a &lt;code&gt;switch&lt;/code&gt; to initialize the &lt;code&gt;enum&lt;/code&gt; parameters differently. We decide that the LFO should default to the triangle waveform because that’s what LFOs use most of the time. Note how the default case is just one statement for all 16 knobs!&lt;br&gt;Some of the knobs need a non-linear behaviour. For example, the filter cutoff has a logarithmic behaviour due to how octaves and frequencies work. Let’s add the appropriate &lt;code&gt;SetShape&lt;/code&gt; calls at the bottom of &lt;code&gt;CreateParams&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;    GetParam(mFilterCutoff)-&amp;gt;SetShape(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);
    GetParam(mVolumeEnvAttack)-&amp;gt;SetShape(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;);
    GetParam(mFilterEnvAttack)-&amp;gt;SetShape(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;);
    GetParam(mVolumeEnvDecay)-&amp;gt;SetShape(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;);
    GetParam(mFilterEnvDecay)-&amp;gt;SetShape(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;);
    GetParam(mVolumeEnvSustain)-&amp;gt;SetShape(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);
    GetParam(mFilterEnvSustain)-&amp;gt;SetShape(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);
    GetParam(mVolumeEnvRelease)-&amp;gt;SetShape(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;);
    GetParam(mFilterEnvRelease)-&amp;gt;SetShape(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And finally, we’re going to call &lt;code&gt;OnParamChange&lt;/code&gt; for every parameter once, so the plugin has the right internal values when it’s first loaded:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; kNumParams; i++) {
        OnParamChange(i);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We’re now done creating the internal parameters. Let’s add GUI controls for each of them. This is done in &lt;code&gt;CreateGraphics&lt;/code&gt;. First, we’re going to add the background image:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; SpaceBass::CreateGraphics() {
    IGraphics* pGraphics = MakeGraphics(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, kWidth, kHeight);
    pGraphics-&amp;gt;AttachBackground(BG_ID, BG_FN);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then the virtual keyboard:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;    IBitmap whiteKeyImage = pGraphics-&amp;gt;LoadIBitmap(WHITE_KEY_ID, WHITE_KEY_FN, &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;);
    IBitmap blackKeyImage = pGraphics-&amp;gt;LoadIBitmap(BLACK_KEY_ID, BLACK_KEY_FN);
    &lt;span class=&quot;comment&quot;&gt;//                            C#     D#          F#      G#      A#&lt;/span&gt;
    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; keyCoordinates[&lt;span class=&quot;number&quot;&gt;12&lt;/span&gt;] = { &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;17&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;30&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;35&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;52&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;61&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;68&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;79&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;85&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;97&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;102&lt;/span&gt; };
    mVirtualKeyboard = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; IKeyboardControl(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, kKeybX, kKeybY, virtualKeyboardMinimumNoteNumber, &lt;span class=&quot;comment&quot;&gt;/* octaves: */&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &amp;amp;whiteKeyImage, &amp;amp;blackKeyImage, keyCoordinates);
    pGraphics-&amp;gt;AttachControl(mVirtualKeyboard);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The only thing that has changed about the virtual keyboard is the number of octaves (now only four) and the &lt;code&gt;keyCoordinates&lt;/code&gt;. Our keys are wider than before, so we have to adjust the spacing to make the keys appear at the right coordinates.&lt;br&gt;Below that, load the knob and switch graphics:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;    IBitmap waveformBitmap = pGraphics-&amp;gt;LoadIBitmap(WAVEFORM_ID, WAVEFORM_FN, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;);
    IBitmap filterModeBitmap = pGraphics-&amp;gt;LoadIBitmap(FILTERMODE_ID, FILTERMODE_FN, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;);
    IBitmap knobBitmap = pGraphics-&amp;gt;LoadIBitmap(KNOB_ID, KNOB_FN, &lt;span class=&quot;number&quot;&gt;64&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here we’re just loading the &lt;em&gt;.png&lt;/em&gt; files, and we tell the system how many frames each of them has.&lt;br&gt;The main part is to iterate over all parameters and to create the appropriate GUI control:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; kNumParams; i++) {
        &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; parameterProperties_struct&amp;amp; properties = parameterProperties[i];
        IControl* control;
        IBitmap* graphic;
        &lt;span class=&quot;keyword&quot;&gt;switch&lt;/span&gt; (i) {
            &lt;span class=&quot;comment&quot;&gt;// Switches:&lt;/span&gt;
            &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; mOsc1Waveform:
            &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; mOsc2Waveform:
            &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; mLFOWaveform:
                graphic = &amp;amp;waveformBitmap;
                control = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ISwitchControl(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, properties.x, properties.y, i, graphic);
                &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;
            &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; mFilterMode:
                graphic = &amp;amp;filterModeBitmap;
                control = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ISwitchControl(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, properties.x, properties.y, i, graphic);
                &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;
            &lt;span class=&quot;comment&quot;&gt;// Knobs:&lt;/span&gt;
            &lt;span class=&quot;keyword&quot;&gt;default&lt;/span&gt;:
                graphic = &amp;amp;knobBitmap;
                control = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; IKnobMultiControl(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, properties.x, properties.y, i, graphic);
                &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;
        }
        pGraphics-&amp;gt;AttachControl(control);
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Just as above, we’re first getting the properties for the current parameter. In the &lt;code&gt;switch&lt;/code&gt;, we treat our &lt;code&gt;ISwitchControl&lt;/code&gt; parameters differently. We also have to use a different bitmap for our &lt;code&gt;mFilterMode&lt;/code&gt; GUI control (so it uses &lt;em&gt;filtermode.png&lt;/em&gt; instead of &lt;em&gt;waveform.png&lt;/em&gt;. Again, the &lt;code&gt;default&lt;/code&gt; case is a normal knob (because most of our GUI controls are knobs).&lt;br&gt;Let’s finish the function body by calling &lt;code&gt;AttachGraphics&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;    AttachGraphics(pGraphics);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Finally, delete the &lt;code&gt;switch&lt;/code&gt; statement from &lt;code&gt;OnParamChange()&lt;/code&gt; (in &lt;em&gt;SpaceBass.cpp&lt;/em&gt;). We’re going to replace it in the next part.&lt;/p&gt;
&lt;h2 id=&quot;finished-&quot;&gt;Finished!&lt;/h2&gt;
&lt;p&gt;Run the plugin, and you should see our new GUI in all its glory! The audio portion doesn’t work correctly at this point, because we’re going to remake it in the &lt;a href=&quot;http://www.martin-finke.de/articles/audio-plugins-016-polyphony/&quot;&gt;next post&lt;/a&gt;. We’re going to make the plugin polyphonic!&lt;/p&gt;
&lt;p&gt;You can download what we’ve done in this part &lt;a href=&quot;/blog/articles/audio-plugins-015-redesign/source.zip&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Making Audio Plugins Part 14: LFO</title>
      <link>http://www.martin-finke.de/blog/articles/audio-plugins-014-lfo/</link>
      <pubDate>Sat, 05 Oct 2013 19:51:00 +0200</pubDate>
      <guid isPermaLink="true">http://www.martin-finke.de/blog/articles/audio-plugins-014-lfo/</guid>
      <author></author>
      <description>&lt;p&gt;The Low Frequency Oscillator (LFO) is an important part of any classic synthesizer. We’re going to add one to our plugin. &lt;span class=&quot;more&quot;&gt;&lt;/span&gt; As the name implies, an LFO ist just a regular Oscillator! We already have an &lt;code&gt;Oscillator&lt;/code&gt; class, so it’s very easy to add another instance with a low frequency. Let’s start in &lt;em&gt;Synthesis.h&lt;/em&gt;: Add the following members to the &lt;code&gt;private&lt;/code&gt; section:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;Oscillator mLFO;
&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; lfoFilterModAmount;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As you can see, &lt;code&gt;mLFO&lt;/code&gt; is just another &lt;code&gt;Oscillator&lt;/code&gt; instance. &lt;code&gt;lfoFilterModAmount&lt;/code&gt; indicates how much the LFO will modulate the filter’s cutoff frequency.
Of course we have to intialize lfoFilterModAmount. In &lt;em&gt;Synthesis.cpp&lt;/em&gt;, add the following entry to the constructor’s initializer list:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;lfoFilterModAmount(&lt;span class=&quot;number&quot;&gt;0.1&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Why &lt;code&gt;0.1&lt;/code&gt;? In this post we’re just going to prove the point that it’s very easy to add an LFO. We want to hear that it’s working, so we’re hardcoding a modulation amount here. We will add GUI controls later as part of a nice redesign.
At the very end of the constructor, add the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;mLFO.setMode(OSCILLATOR_MODE_TRIANGLE);
mLFO.setFrequency(&lt;span class=&quot;number&quot;&gt;6.0&lt;/span&gt;);
mLFO.setMuted(&lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This just selects the triangle waveform, sets the oscillator to a frequency of 6 Hz and unmutes it. If we were to add GUI constrols, the first two would probably be set inside &lt;code&gt;OnParamChange&lt;/code&gt; according to user input. Muting and unmuting the oscillator would depend on whether &lt;code&gt;lfoFilterModAmount&lt;/code&gt; is equal to zero.&lt;/p&gt;
&lt;p&gt;Since it’s an &lt;code&gt;Oscillator&lt;/code&gt;, we have to inform the LFO about sample rate changes. Add this line to &lt;code&gt;Synthesis::Reset&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;mLFO.setSampleRate(GetSampleRate());
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now let’s get the LFO values. We’re doing this in &lt;code&gt;ProcessDoubleReplacing&lt;/code&gt;. Change the &lt;code&gt;for&lt;/code&gt; loop to the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; nFrames; ++i) {
    mMIDIReceiver.advance();
    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; velocity = mMIDIReceiver.getLastVelocity();
    &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; lfoFilterModulation = mLFO.nextSample() * lfoFilterModAmount;
    mOscillator.setFrequency(mMIDIReceiver.getLastFrequency());
    mFilter.setCutoffMod((mFilterEnvelopeGenerator.nextSample() * filterEnvelopeAmount) + lfoFilterModulation);
    leftOutput[i] = rightOutput[i] = mFilter.process(mOscillator.nextSample() * mEnvelopeGenerator.nextSample() * velocity / &lt;span class=&quot;number&quot;&gt;127.0&lt;/span&gt;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;First, we’re calculating &lt;code&gt;lfoFilterModulation&lt;/code&gt;: It’s a value between &lt;code&gt;-1&lt;/code&gt; and &lt;code&gt;+1&lt;/code&gt;. When we call &lt;code&gt;setCutoffMod&lt;/code&gt;, we add the filter envelope &lt;em&gt;and&lt;/em&gt; the &lt;code&gt;lfoFilterModulation&lt;/code&gt; and pass it to &lt;code&gt;setCutoffMod&lt;/code&gt;. This means that our filter`s cutoff will be modulated by both the filter envelope and the LFO.&lt;/p&gt;
&lt;p&gt;And that’s it! Run the plugin and play around with the filter (you probably want to set the waveform to something different than sine). You should hear the typical pulsating wobbly sound.&lt;/p&gt;
&lt;p&gt;If you are using a real MIDI keyboard to test the plugin, you can still play just one note at the time. You can download the source files for this part &lt;a href=&quot;/blog/articles/audio-plugins-014-lfo/source.zip&quot;&gt;here&lt;/a&gt;. Next, we’re going to &lt;a href=&quot;http://www.martin-finke.de/articles/audio-plugins-015-redesign/&quot;&gt;redesign our plugin&lt;/a&gt; to make it more beautiful:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/blog/articles/audio-plugins-014-lfo/redesign.png&quot;&gt;&lt;img src=&quot;/blog/articles/audio-plugins-014-lfo/redesign.png&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Making Audio Plugins Part 13: Filter</title>
      <link>http://www.martin-finke.de/blog/articles/audio-plugins-013-filter/</link>
      <pubDate>Sat, 05 Oct 2013 19:50:00 +0200</pubDate>
      <guid isPermaLink="true">http://www.martin-finke.de/blog/articles/audio-plugins-013-filter/</guid>
      <author></author>
      <description>&lt;p&gt;Today we’ll create a resonant filter. &lt;span class=&quot;more&quot;&gt;&lt;/span&gt; Filter design is a complex topic that keeps DSP engineers’ brains busy worldwide, and for now we won’t get too far into that. For not let’s just add a simple resonant &lt;em&gt;Low-Pass&lt;/em&gt;, &lt;em&gt;Band-Pass&lt;/em&gt; and &lt;em&gt;High-Pass&lt;/em&gt; filter to our plugin. We will use an &lt;a href=&quot;http://www.musicdsp.org/showone.php?id=29&quot;&gt;algorithm&lt;/a&gt; by Paul Kellett.&lt;/p&gt;
&lt;h2 id=&quot;creating-the-filter&quot;&gt;Creating the Filter&lt;/h2&gt;
&lt;p&gt;Let’s start by creating a new C++ class named &lt;code&gt;Filter&lt;/code&gt;. Make sure you add it to all targets. In &lt;em&gt;Filter.h&lt;/em&gt;, remove the &lt;code&gt;#include &amp;lt;iostream&amp;gt;&lt;/code&gt; and add the following class:
&lt;a name=&quot;calculateFeedbackAmount_implementation&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; Filter {
&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:
    &lt;span class=&quot;keyword&quot;&gt;enum&lt;/span&gt; FilterMode {
        FILTER_MODE_LOWPASS = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,
        FILTER_MODE_HIGHPASS,
        FILTER_MODE_BANDPASS,
        kNumFilterModes
    };
    Filter() :
    cutoff(&lt;span class=&quot;number&quot;&gt;0.99&lt;/span&gt;),
    resonance(&lt;span class=&quot;number&quot;&gt;0.0&lt;/span&gt;),
    mode(FILTER_MODE_LOWPASS),
    buf0(&lt;span class=&quot;number&quot;&gt;0.0&lt;/span&gt;),
    buf1(&lt;span class=&quot;number&quot;&gt;0.0&lt;/span&gt;)
    {
        calculateFeedbackAmount();
    };
    &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; process(&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; inputValue);
    &lt;span class=&quot;keyword&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; setCutoff(&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; newCutoff) { cutoff = newCutoff; calculateFeedbackAmount(); };
    &lt;span class=&quot;keyword&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; setResonance(&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; newResonance) { resonance = newResonance; calculateFeedbackAmount(); };
    &lt;span class=&quot;keyword&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; setFilterMode(FilterMode newMode) { mode = newMode; }
&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt;:
    &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; cutoff;
    &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; resonance;
    FilterMode mode;
    &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; feedbackAmount;
    &lt;span class=&quot;keyword&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; calculateFeedbackAmount() { feedbackAmount = resonance + resonance/(&lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt; - cutoff); }
    &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; buf0;
    &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; buf1;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the &lt;code&gt;private&lt;/code&gt; section we of course have the values for filter cutoff and resonance. &lt;code&gt;mode&lt;/code&gt; indicates what mode (Lowpass, Highpass, Bandpass) the filter is currently in. &lt;code&gt;feedbackAmount&lt;/code&gt;, &lt;code&gt;buf0&lt;/code&gt; and &lt;code&gt;buf1&lt;/code&gt; are values used by the filter algorithm (more on this later).
The constructor just initializes the members to sensible values and calculates the feedback amount. The &lt;code&gt;process&lt;/code&gt; function will be called every sample to filter the incoming signal. Because &lt;code&gt;feedbackAmount&lt;/code&gt; depends on both &lt;code&gt;cutoff&lt;/code&gt; and &lt;code&gt;resonance&lt;/code&gt;, the setters for &lt;code&gt;cutoff&lt;/code&gt; and &lt;code&gt;resonance&lt;/code&gt; have to call &lt;code&gt;calculateFeedbackAmount&lt;/code&gt; after updating the member.&lt;/p&gt;
&lt;p&gt;&lt;a name=&quot;filter_algorithm&quot;&gt;&lt;/a&gt;
Add the filter algorithm to &lt;em&gt;Filter.cpp&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// By Paul Kellett&lt;/span&gt;
&lt;span class=&quot;comment&quot;&gt;// http://www.musicdsp.org/showone.php?id=29&lt;/span&gt;

&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; Filter::process(&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; inputValue) {
    buf0 += cutoff * (inputValue - buf0);
    buf1 += cutoff * (buf0 - buf1);
    &lt;span class=&quot;keyword&quot;&gt;switch&lt;/span&gt; (mode) {
        &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; FILTER_MODE_LOWPASS:
            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; buf1;
        &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; FILTER_MODE_HIGHPASS:
            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; inputValue - buf0;
        &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; FILTER_MODE_BANDPASS:
            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; buf0 - buf1;
        &lt;span class=&quot;keyword&quot;&gt;default&lt;/span&gt;:
            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0.0&lt;/span&gt;;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Pretty short, isn’t it? The algorithm is basically two &lt;em&gt;first-order&lt;/em&gt; lowpass filters in series. &lt;em&gt;First-order&lt;/em&gt; means that for every octave above the cutoff frequency, the amplitude is halved (i.e. the volume is reduced by 6dB). The two lines that calculate &lt;code&gt;buf0&lt;/code&gt; and &lt;code&gt;buf1&lt;/code&gt; are quite similar: Each of them is a first-order lowpass filter. The first line takes in &lt;code&gt;inputValue&lt;/code&gt;, whereas the second line takes &lt;code&gt;buf0&lt;/code&gt; (the output of the first filter) instead. So the two filters are in series. Two -6dB/octave filters them in series means a reduction of -12dB per octave. This will become clearer in a moment.
You can see in the &lt;code&gt;switch&lt;/code&gt; statement that &lt;code&gt;buf1&lt;/code&gt; is the lowpass output. Try &lt;code&gt;return&lt;/code&gt;ing &lt;code&gt;buf0&lt;/code&gt; instead: You’ll get an attenuation of -6dB per octave (instead of -12dB), so the sound has more highs.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;case FILTER_MODE_HIGHPASS&lt;/code&gt; is actually quite intuitive. &lt;code&gt;buf0&lt;/code&gt; is &lt;em&gt;just the low frequencies&lt;/em&gt; (of a first-order filter). So if we take the &lt;code&gt;inputValue&lt;/code&gt; and subtract the low frequencies, we just keep the high ones. You could also use &lt;code&gt;buf1&lt;/code&gt; here for a steeper cut.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;case FILTER_MODE_BANDPASS&lt;/code&gt; shows that the bandpass output is &lt;code&gt;buf0 - buf1&lt;/code&gt;. As already stated, &lt;code&gt;buf0&lt;/code&gt; has slightly more content right above the cutoff frequency than &lt;code&gt;buf1&lt;/code&gt;. If we subtract &lt;code&gt;buf1&lt;/code&gt; from &lt;code&gt;buf0&lt;/code&gt;, &lt;em&gt;we keep just that content&lt;/em&gt;. So: &lt;em&gt;Subtracting a lowpass output from a lower-order lowpass gives a bandpass output&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Calculating &lt;code&gt;buf1&lt;/code&gt; depends on &lt;em&gt;the previous value of &lt;code&gt;buf1&lt;/code&gt;&lt;/em&gt;. This kind of feedback means that it’s an &lt;em&gt;Infinite Impulse Response (IIR)&lt;/em&gt; Filter. Read &lt;a href=&quot;http://www.dspguide.com/ch14/1.htm&quot;&gt;this&lt;/a&gt; for more information on filter types. We’re not going deeper into filter design here, because I think at this point the math would be a little too much.&lt;/p&gt;
&lt;h2 id=&quot;using-the-filter&quot;&gt;Using the Filter&lt;/h2&gt;
&lt;p&gt;Let’s use our new filter class! We’ll begin with the GUI. Remove &lt;em&gt;bg.png&lt;/em&gt; from your project (answer “Move to trash”). Then download the following graphics and add them to the project:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/blog/articles/audio-plugins-013-filter/filtermode.png&quot;&gt;filtermode.png&lt;/a&gt; (&lt;a href=&quot;/blog/articles/audio-plugins-013-filter/filtermode.tif&quot;&gt;Here&lt;/a&gt;‘s the TIF)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/blog/articles/audio-plugins-013-filter/knob_small.png&quot;&gt;knob_small.png&lt;/a&gt; (Basically the same knob resized to 50x50 pixels)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/blog/articles/audio-plugins-013-filter/bg.png&quot;&gt;bg.png&lt;/a&gt; (A new GUI background with space for the filter controls)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Add the references and IDs to &lt;em&gt;resource.h&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Unique IDs for each image resource.&lt;/span&gt;
&lt;span class=&quot;preprocessor&quot;&gt;#define BG_ID         101&lt;/span&gt;
&lt;span class=&quot;preprocessor&quot;&gt;#define WHITE_KEY_ID  102&lt;/span&gt;
&lt;span class=&quot;preprocessor&quot;&gt;#define BLACK_KEY_ID  103&lt;/span&gt;
&lt;span class=&quot;preprocessor&quot;&gt;#define WAVEFORM_ID   104&lt;/span&gt;
&lt;span class=&quot;preprocessor&quot;&gt;#define KNOB_ID       105&lt;/span&gt;
&lt;span class=&quot;preprocessor&quot;&gt;#define KNOB_SMALL_ID 106&lt;/span&gt;
&lt;span class=&quot;preprocessor&quot;&gt;#define FILTERMODE_ID 107&lt;/span&gt;

&lt;span class=&quot;comment&quot;&gt;// Image resource locations for this plug.&lt;/span&gt;
&lt;span class=&quot;preprocessor&quot;&gt;#define BG_FN         &quot;resources/img/bg.png&quot;&lt;/span&gt;
&lt;span class=&quot;preprocessor&quot;&gt;#define WHITE_KEY_FN  &quot;resources/img/whitekey.png&quot;&lt;/span&gt;
&lt;span class=&quot;preprocessor&quot;&gt;#define BLACK_KEY_FN  &quot;resources/img/blackkey.png&quot;&lt;/span&gt;
&lt;span class=&quot;preprocessor&quot;&gt;#define WAVEFORM_FN   &quot;resources/img/waveform.png&quot;&lt;/span&gt;
&lt;span class=&quot;preprocessor&quot;&gt;#define KNOB_FN       &quot;resources/img/knob.png&quot;&lt;/span&gt;
&lt;span class=&quot;preprocessor&quot;&gt;#define KNOB_SMALL_FN &quot;resources/img/knob_small.png&quot;&lt;/span&gt;
&lt;span class=&quot;preprocessor&quot;&gt;#define FILTERMODE_FN &quot;resources/img/filtermode.png&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Edit the top of &lt;em&gt;Synthesis.rc&lt;/em&gt; to this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#include &quot;resource.h&quot;&lt;/span&gt;

BG_ID       PNG BG_FN
WHITE_KEY_ID       PNG WHITE_KEY_FN
BLACK_KEY_ID       PNG BLACK_KEY_FN
WAVEFORM_ID       PNG WAVEFORM_FN
KNOB_ID       PNG KNOB_FN
KNOB_SMALL_ID       PNG KNOB_SMALL_FN
FILTERMODE_ID       PNG FILTERMODE_FN
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In &lt;em&gt;Synthesis.h&lt;/em&gt;, &lt;code&gt;#include &amp;quot;Filter.h&amp;quot;&lt;/code&gt; and add a &lt;code&gt;private&lt;/code&gt; member:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;Filter mFilter;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In &lt;em&gt;Synthesis.cpp&lt;/em&gt;, update &lt;code&gt;EParams&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;enum&lt;/span&gt; EParams
{
    mWaveform = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,
    mAttack,
    mDecay,
    mSustain,
    mRelease,
    mFilterMode,
    mFilterCutoff,
    mFilterResonance,
    mFilterAttack,
    mFilterDecay,
    mFilterSustain,
    mFilterRelease,
    mFilterEnvelopeAmount,
    kNumParams
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Change the y coordinate for the waveform switch (it’s in the constructor):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;pGraphics-&amp;gt;AttachControl(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ISwitchControl(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;24&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;38&lt;/span&gt;, mWaveform, &amp;amp;waveformBitmap));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The volume envelope knobs can stay where they are.
Let’s add the switch to change filter mode (Lowpass, Highpass, Bandpass). Right above &lt;code&gt;AttachGraphics(pGraphics)&lt;/code&gt;, add this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;GetParam(mFilterMode)-&amp;gt;InitEnum(&lt;span class=&quot;string&quot;&gt;&quot;Filter Mode&quot;&lt;/span&gt;, Filter::FILTER_MODE_LOWPASS, Filter::kNumFilterModes);
IBitmap filtermodeBitmap = pGraphics-&amp;gt;LoadIBitmap(FILTERMODE_ID, FILTERMODE_FN, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;);
pGraphics-&amp;gt;AttachControl(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ISwitchControl(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;24&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;123&lt;/span&gt;, mFilterMode, &amp;amp;filtermodeBitmap));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We also need a knob to change the cutoff frequency and one for the resonance. We’ll use our new &lt;em&gt;knob_small.png&lt;/em&gt;. Add the following code right before the &lt;code&gt;AttachGraphics&lt;/code&gt; call:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Knobs for filter cutoff and resonance&lt;/span&gt;
IBitmap smallKnobBitmap = pGraphics-&amp;gt;LoadIBitmap(KNOB_SMALL_ID, KNOB_SMALL_FN, &lt;span class=&quot;number&quot;&gt;64&lt;/span&gt;);
&lt;span class=&quot;comment&quot;&gt;// Cutoff knob:&lt;/span&gt;
GetParam(mFilterCutoff)-&amp;gt;InitDouble(&lt;span class=&quot;string&quot;&gt;&quot;Cutoff&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0.99&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0.01&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0.99&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0.001&lt;/span&gt;);
GetParam(mFilterCutoff)-&amp;gt;SetShape(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);
pGraphics-&amp;gt;AttachControl(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; IKnobMultiControl(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;177&lt;/span&gt;, mFilterCutoff, &amp;amp;smallKnobBitmap));
&lt;span class=&quot;comment&quot;&gt;// Resonance knob:&lt;/span&gt;
GetParam(mFilterResonance)-&amp;gt;InitDouble(&lt;span class=&quot;string&quot;&gt;&quot;Resonance&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0.01&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0.01&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0.001&lt;/span&gt;);
pGraphics-&amp;gt;AttachControl(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; IKnobMultiControl(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;61&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;177&lt;/span&gt;, mFilterResonance, &amp;amp;smallKnobBitmap));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Be aware that the value for cutoff should never be &lt;code&gt;1.0&lt;/code&gt;! It will lead to a division by zero inside &lt;code&gt;calculateFeedbackAmount&lt;/code&gt;.
In &lt;code&gt;ProcessDoubleReplacing&lt;/code&gt;, surround the sample generation code with a call to &lt;code&gt;mFilter.process&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;leftOutput[i] = rightOutput[i] = mFilter.process(mOscillator.nextSample() * mEnvelopeGenerator.nextSample() * velocity / &lt;span class=&quot;number&quot;&gt;127.0&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Finally, we have to react to parameter changes. Add the following &lt;code&gt;case&lt;/code&gt;s to the &lt;code&gt;switch&lt;/code&gt; statement in &lt;code&gt;Synthesis::OnParamChange&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; mFilterCutoff:
    mFilter.setCutoff(GetParam(paramIdx)-&amp;gt;Value());
    &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;
&lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; mFilterResonance:
    mFilter.setResonance(GetParam(paramIdx)-&amp;gt;Value());
    &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;
&lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; mFilterMode:
    mFilter.setFilterMode(&lt;span class=&quot;keyword&quot;&gt;static_cast&lt;/span&gt;&amp;lt;Filter::FilterMode&amp;gt;(GetParam(paramIdx)-&amp;gt;Int()));
    &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We’re ready to try the filter! Run the plugin, play a few notes and tweak the cutoff.&lt;/p&gt;
&lt;h2 id=&quot;resonance&quot;&gt;Resonance&lt;/h2&gt;
&lt;p&gt;Resonance is basically just a peak at the cutoff frequency. We can realize this by taking a bandpass output, multiplying it by a certain amount and adding it to the signal. Modify the filter’s first line so it looks like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;buf0 += cutoff * (inputValue - buf0 + feedbackAmount * (buf0 - buf1));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The left part is the same. To the right, we’re just adding &lt;code&gt;(buf0 - buf1)&lt;/code&gt; (which is a bandpass output) multiplied by &lt;code&gt;feedbackAmount&lt;/code&gt;. You can see from &lt;a href=&quot;http://www.martin-finke.de/articles/audio-plugins-013-filter/#calculateFeedbackAmount_implementation&quot;&gt;the implementation of &lt;code&gt;calculateFeedbackAmount&lt;/code&gt;&lt;/a&gt; that &lt;code&gt;feedbackAmount&lt;/code&gt; is proportional to &lt;code&gt;resonance&lt;/code&gt;. So the peak will be louder if &lt;code&gt;resonance&lt;/code&gt; is high.&lt;/p&gt;
&lt;p&gt;Run the plugin again. Try tweaking the cutoff knob while holding a note, especially with high resonance. When you turn the resonance all the way up, you’ll get self-oscillation, which can be used to create &lt;a href=&quot;http://www.youtube.com/watch?v=JWyMj6KxGHM&quot;&gt;some interesting sounds&lt;/a&gt;. We can get a great variety of sounds with the few parameters we have, especially when we change the filter mode to bandpass or highpass.&lt;/p&gt;
&lt;h2 id=&quot;from-12db-to-24db&quot;&gt;From -12dB to -24dB&lt;/h2&gt;
&lt;p&gt;Instead of just two filters, let’s try putting &lt;em&gt;four&lt;/em&gt; of them in series! This will give us an attenuation of -24dB per octave. Add the following two lines right above the &lt;code&gt;switch&lt;/code&gt; statement in &lt;code&gt;Filter::process&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;buf2 += cutoff * (buf1 - buf2);
buf3 += cutoff * (buf2 - buf3);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is the same pattern as the &lt;code&gt;buf1&lt;/code&gt; line: Take the output from the previous filter, subtract &lt;em&gt;the last output&lt;/em&gt; of this filter, multiply by &lt;code&gt;cutoff&lt;/code&gt; and add it to the last output value. You could keep adding lines like this, but it makes the filter more expensive to calculate, and possibly &lt;a href=&quot;https://ccrma.stanford.edu/~Jos/filters/Filter_Stability.html&quot;&gt;unstable&lt;/a&gt; (more on this in a later post).
Make sure you modify the &lt;code&gt;switch&lt;/code&gt; statement, too:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;switch&lt;/span&gt; (mode) {
    &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; FILTER_MODE_LOWPASS:
        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; buf3;
    &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; FILTER_MODE_HIGHPASS:
        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; inputValue - buf3;
    &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; FILTER_MODE_BANDPASS:
        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; buf0 - buf3;
    &lt;span class=&quot;keyword&quot;&gt;default&lt;/span&gt;:
        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0.0&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We’re using &lt;code&gt;buf3&lt;/code&gt; instead of &lt;code&gt;buf1&lt;/code&gt;. &lt;code&gt;buf3&lt;/code&gt; is the the output of &lt;em&gt;four&lt;/em&gt; first-oder filters in series, i.e. it has an attenuation of -24dB per octave.
We haven’t declared (or initialized) &lt;code&gt;buf2&lt;/code&gt; and &lt;code&gt;buf3&lt;/code&gt; yet, so let’s go into &lt;em&gt;Filter.h&lt;/em&gt;. Add the &lt;code&gt;private&lt;/code&gt; members:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; buf2;
&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; buf3;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And initialize them to zero (just like &lt;code&gt;buf0&lt;/code&gt; and &lt;code&gt;buf1&lt;/code&gt;):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;Filter() :
    &lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;
    buf0(&lt;span class=&quot;number&quot;&gt;0.0&lt;/span&gt;),
    buf1(&lt;span class=&quot;number&quot;&gt;0.0&lt;/span&gt;),
    buf2(&lt;span class=&quot;number&quot;&gt;0.0&lt;/span&gt;),
    buf3(&lt;span class=&quot;number&quot;&gt;0.0&lt;/span&gt;)
    &lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you run the plugin again, you’ll hear that the filter has become &lt;em&gt;steeper&lt;/em&gt;: Frequencies above the cutoff get attenuated more strongly. This is what you often find in classic analogue synths.&lt;/p&gt;
&lt;p&gt;Now what if we could change the filter cutoff over time?&lt;/p&gt;
&lt;h2 id=&quot;filter-envelope&quot;&gt;Filter Envelope&lt;/h2&gt;
&lt;p&gt;The fun has just begun! Thanks to how we built the &lt;code&gt;EnvelopeGenerator&lt;/code&gt; class, it’s very easy to add a second envelope which will modulate the filter cutoff. Actually, we shouldn’t let the envelope change our filter’s &lt;code&gt;cutoff&lt;/code&gt; variable directly. That variable is linked to the knob in our GUI. Instead, we’ll add another variable &lt;code&gt;cutoffMod&lt;/code&gt;, that will be modified by the envelope. It will be added to the &lt;code&gt;cutoff&lt;/code&gt; variable to yield the &lt;em&gt;calculated cutoff&lt;/em&gt;.
In &lt;em&gt;Filter.h&lt;/em&gt;, &lt;code&gt;#include &amp;lt;cmath&amp;gt;&lt;/code&gt; and add a &lt;code&gt;private&lt;/code&gt; member variable:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; cutoffMod;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Initialize it:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;Filter() :
    cutoff(&lt;span class=&quot;number&quot;&gt;0.99&lt;/span&gt;),
    resonance(&lt;span class=&quot;number&quot;&gt;0.01&lt;/span&gt;),
    cutoffMod(&lt;span class=&quot;number&quot;&gt;0.0&lt;/span&gt;),
    &lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;em&gt;calculated cutoff&lt;/em&gt; is the sum of &lt;code&gt;cutoff&lt;/code&gt; and &lt;code&gt;cutoffMod&lt;/code&gt;. But we have to make sure it doesn’t go out of the allowed range. Add the following to the &lt;code&gt;private&lt;/code&gt; section:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; getCalculatedCutoff() &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; {
    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; fmax(fmin(cutoff + cutoffMod, &lt;span class=&quot;number&quot;&gt;0.99&lt;/span&gt;), &lt;span class=&quot;number&quot;&gt;0.01&lt;/span&gt;);
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let’s make &lt;code&gt;calculateFeedbackAmount&lt;/code&gt; use the calculated cutoff:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; calculateFeedbackAmount() {
    feedbackAmount = resonance + resonance/(&lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt; - getCalculatedCutoff());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Finally, let’s add the &lt;code&gt;public&lt;/code&gt; setter function for &lt;code&gt;cutoffMod&lt;/code&gt;. Since &lt;code&gt;feedbackAmount&lt;/code&gt; now depends on the calculated cutoff, the setter has to update it as well:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; setCutoffMod(&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; newCutoffMod) {
    cutoffMod = newCutoffMod;
    calculateFeedbackAmount();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Of course we have to change the algorithm as well. Open &lt;em&gt;Filter.cpp&lt;/em&gt; and change replace the first four lines of &lt;code&gt;Filter::process&lt;/code&gt; (where the &lt;code&gt;buf&lt;/code&gt; variables are calculated) with the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (inputValue == &lt;span class=&quot;number&quot;&gt;0.0&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; inputValue;
&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; calculatedCutoff = getCalculatedCutoff();
buf0 += calculatedCutoff * (inputValue - buf0 + feedbackAmount * (buf0 - buf1));
buf1 += calculatedCutoff * (buf0 - buf1);
buf2 += calculatedCutoff * (buf1 - buf2);
buf3 += calculatedCutoff * (buf2 - buf3);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The first line ensures the filter won’t be busy when the input is silent. Of course, such a check only makes sense when the code that follows it is notably more expensive than the comparison itself. That seems to be the case here.
Apart from that, we have just changed the algorithm so it uses the calculated cutoff instead of just &lt;code&gt;cutoff&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Now that our filter is ready to be modulated from outside (by calling &lt;code&gt;setCutoffMod&lt;/code&gt;), we’ll make some changes to the &lt;code&gt;Synthesis&lt;/code&gt; class: We’ll add a second envelope that will be triggered just like our existing volume envelope. The user will be able to decide &lt;em&gt;how much&lt;/em&gt; the filter’s &lt;code&gt;cutoffMod&lt;/code&gt; is affected by the envelope: We’ll add a new parameter called &lt;code&gt;filterEnvelopeAmount&lt;/code&gt; with values between &lt;code&gt;-1&lt;/code&gt; and &lt;code&gt;+1&lt;/code&gt;. Finally, we’ll add GUI controls for everything.&lt;/p&gt;
&lt;p&gt;In &lt;em&gt;Synthesis.h&lt;/em&gt;, add the following &lt;code&gt;private&lt;/code&gt; members:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;EnvelopeGenerator mFilterEnvelopeGenerator;
&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; filterEnvelopeAmount;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We want &lt;em&gt;both&lt;/em&gt; envelopes to be triggered according to MIDI note on/off messages. Replace the implementations for &lt;code&gt;onNoteOn&lt;/code&gt; and &lt;code&gt;onNoteOff&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; onNoteOn(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; noteNumber, &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; velocity) {
    mEnvelopeGenerator.enterStage(EnvelopeGenerator::ENVELOPE_STAGE_ATTACK);
    mFilterEnvelopeGenerator.enterStage(EnvelopeGenerator::ENVELOPE_STAGE_ATTACK);
};
&lt;span class=&quot;keyword&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; onNoteOff(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; noteNumber, &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; velocity) {
    mEnvelopeGenerator.enterStage(EnvelopeGenerator::ENVELOPE_STAGE_RELEASE);
    mFilterEnvelopeGenerator.enterStage(EnvelopeGenerator::ENVELOPE_STAGE_RELEASE);
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is just like before, except that &lt;code&gt;enterStage&lt;/code&gt; is called on both envelopes.
In &lt;em&gt;Synthesis.cpp&lt;/em&gt;, insert the following line inside &lt;code&gt;ProcessDoubleReplacing&lt;/code&gt;, right before the &lt;code&gt;leftOutput[i]&lt;/code&gt; line:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;mFilter.setCutoffMod(mFilterEnvelopeGenerator.nextSample() * filterEnvelopeAmount);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As you can see, we’re getting the &lt;code&gt;nextSample&lt;/code&gt; from the filter envelope, multiply it by the filterEnvelopeAmount and set the filter’s &lt;code&gt;cutoffMod&lt;/code&gt; with the result.
We shouldn’t forget to initialize &lt;code&gt;filterEnvelopeAmount&lt;/code&gt;. Add the initializer to the constructor:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;Synthesis::Synthesis(IPlugInstanceInfo instanceInfo) : IPLUG_CTOR(kNumParams, kNumPrograms, instanceInfo),
    lastVirtualKeyboardNoteNumber(virtualKeyboardMinimumNoteNumber - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;),
    filterEnvelopeAmount(&lt;span class=&quot;number&quot;&gt;0.0&lt;/span&gt;) {
    &lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And let’s not forget to set the filter envelope’s sample rate when it’s changed in our plugin. Add this to &lt;code&gt;Synthesis::Reset&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;mFilterEnvelopeGenerator.setSampleRate(GetSampleRate());
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We have already added the parameters to &lt;code&gt;EParams&lt;/code&gt;, so we just have to initialize them and add knobs. Inside the constructor, just above the &lt;code&gt;AttachGraphics&lt;/code&gt; call, add the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Knobs for filter envelope&lt;/span&gt;
&lt;span class=&quot;comment&quot;&gt;// Attack knob&lt;/span&gt;
GetParam(mFilterAttack)-&amp;gt;InitDouble(&lt;span class=&quot;string&quot;&gt;&quot;Filter Env Attack&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0.01&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0.01&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;10.0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0.001&lt;/span&gt;);
GetParam(mFilterAttack)-&amp;gt;SetShape(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;);
pGraphics-&amp;gt;AttachControl(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; IKnobMultiControl(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;139&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;178&lt;/span&gt;, mFilterAttack, &amp;amp;smallKnobBitmap));
&lt;span class=&quot;comment&quot;&gt;// Decay knob:&lt;/span&gt;
GetParam(mFilterDecay)-&amp;gt;InitDouble(&lt;span class=&quot;string&quot;&gt;&quot;Filter Env Decay&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0.5&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0.01&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;15.0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0.001&lt;/span&gt;);
GetParam(mFilterDecay)-&amp;gt;SetShape(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;);
pGraphics-&amp;gt;AttachControl(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; IKnobMultiControl(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;195&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;178&lt;/span&gt;, mFilterDecay, &amp;amp;smallKnobBitmap));
&lt;span class=&quot;comment&quot;&gt;// Sustain knob:&lt;/span&gt;
GetParam(mFilterSustain)-&amp;gt;InitDouble(&lt;span class=&quot;string&quot;&gt;&quot;Filter Env Sustain&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0.1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0.001&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0.001&lt;/span&gt;);
GetParam(mFilterSustain)-&amp;gt;SetShape(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);
pGraphics-&amp;gt;AttachControl(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; IKnobMultiControl(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;251&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;178&lt;/span&gt;, mFilterSustain, &amp;amp;smallKnobBitmap));
&lt;span class=&quot;comment&quot;&gt;// Release knob:&lt;/span&gt;
GetParam(mFilterRelease)-&amp;gt;InitDouble(&lt;span class=&quot;string&quot;&gt;&quot;Filter Env Release&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0.001&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;15.0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0.001&lt;/span&gt;);
GetParam(mFilterRelease)-&amp;gt;SetShape(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;);
pGraphics-&amp;gt;AttachControl(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; IKnobMultiControl(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;307&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;178&lt;/span&gt;, mFilterRelease, &amp;amp;smallKnobBitmap));

&lt;span class=&quot;comment&quot;&gt;// Filter envelope amount knob:&lt;/span&gt;
GetParam(mFilterEnvelopeAmount)-&amp;gt;InitDouble(&lt;span class=&quot;string&quot;&gt;&quot;Filter Env Amount&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0.0&lt;/span&gt;, -&lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0.001&lt;/span&gt;);
pGraphics-&amp;gt;AttachControl(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; IKnobMultiControl(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;363&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;178&lt;/span&gt;, mFilterEnvelopeAmount, &amp;amp;smallKnobBitmap));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is very similar to the volume envelope knobs, except that we use the &lt;code&gt;smallKnobBitmap&lt;/code&gt; here. In addition to the four envelope controls, we also add a knob for the filter envelope amount.
The only thing left is to react to user input on these knobs. Add these &lt;code&gt;case&lt;/code&gt;s to the &lt;code&gt;switch&lt;/code&gt; in &lt;code&gt;Synthesis::OnParamChange&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; mFilterAttack:
    mFilterEnvelopeGenerator.setStageValue(EnvelopeGenerator::ENVELOPE_STAGE_ATTACK, GetParam(paramIdx)-&amp;gt;Value());
    &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;
&lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; mFilterDecay:
    mFilterEnvelopeGenerator.setStageValue(EnvelopeGenerator::ENVELOPE_STAGE_DECAY, GetParam(paramIdx)-&amp;gt;Value());
    &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;
&lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; mFilterSustain:
    mFilterEnvelopeGenerator.setStageValue(EnvelopeGenerator::ENVELOPE_STAGE_SUSTAIN, GetParam(paramIdx)-&amp;gt;Value());
    &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;
&lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; mFilterRelease:
    mFilterEnvelopeGenerator.setStageValue(EnvelopeGenerator::ENVELOPE_STAGE_RELEASE, GetParam(paramIdx)-&amp;gt;Value());
    &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;
&lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; mFilterEnvelopeAmount:
    filterEnvelopeAmount = GetParam(paramIdx)-&amp;gt;Value();
    &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;i-love-acid-&quot;&gt;I Love Acid!&lt;/h2&gt;
&lt;p&gt;And it’s done! Run the plugin again and modulate the filter using the new envelope!
Try the following knob positions and play low notes (around C1) for a particularly squelchy bass sound:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/blog/articles/audio-plugins-013-filter/screenshot.png&quot;&gt;&lt;img src=&quot;/blog/articles/audio-plugins-013-filter/screenshot.png&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;With little work, we have re-used our &lt;code&gt;EnvelopeGenerator&lt;/code&gt; class as a filter envelope. This makes our plugin even more flexible, and it’s already capable of a wide range of sounds.
We have almost finished a classic monophonic synthesizer! You can download the source files for this post &lt;a href=&quot;/blog/articles/audio-plugins-013-filter/source.zip&quot;&gt;here&lt;/a&gt;. In the next post we’ll learn &lt;a href=&quot;http://www.martin-finke.de/articles/audio-plugins-014-lfo/&quot;&gt;how to create an LFO&lt;/a&gt;!&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Making Audio Plugins Part 12: Envelope GUI</title>
      <link>http://www.martin-finke.de/blog/articles/audio-plugins-012-envelopes-gui/</link>
      <pubDate>Sat, 05 Oct 2013 19:49:00 +0200</pubDate>
      <guid isPermaLink="true">http://www.martin-finke.de/blog/articles/audio-plugins-012-envelopes-gui/</guid>
      <author></author>
      <description>&lt;p&gt;Let’s add some knobs to change our volume envelope in real-time! &lt;span class=&quot;more&quot;&gt;&lt;/span&gt; While we’re at it, we will also add a switch to change the waveform. This is the look we’re going for (click &lt;a href=&quot;/blog/articles/audio-plugins-012-envelopes-gui/gui.tif&quot;&gt;here&lt;/a&gt; for a TIF with all the layers):&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/blog/articles/audio-plugins-012-envelopes-gui/gui.png&quot;&gt;&lt;img src=&quot;/blog/articles/audio-plugins-012-envelopes-gui/gui.png&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;creating-the-gui&quot;&gt;Creating the GUI&lt;/h2&gt;
&lt;p&gt;Download the following files and add them to the project:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/blog/articles/audio-plugins-012-envelopes-gui/bg.png&quot;&gt;bg.png&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/blog/articles/audio-plugins-012-envelopes-gui/knob.png&quot;&gt;knob.png&lt;/a&gt; (Credits to &lt;a href=&quot;http://www.kvraudio.com/forum/viewtopic.php?p=3075317#3075317&quot;&gt;Bootsie&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/blog/articles/audio-plugins-012-envelopes-gui/waveform.png&quot;&gt;waveform.png&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Make sure you copy them to the project folder and add them to all targets (as always). Now open &lt;em&gt;resource.h&lt;/em&gt; and add the references:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Unique IDs for each image resource.&lt;/span&gt;
&lt;span class=&quot;preprocessor&quot;&gt;#define BG_ID         101&lt;/span&gt;
&lt;span class=&quot;preprocessor&quot;&gt;#define WHITE_KEY_ID  102&lt;/span&gt;
&lt;span class=&quot;preprocessor&quot;&gt;#define BLACK_KEY_ID  103&lt;/span&gt;
&lt;span class=&quot;preprocessor&quot;&gt;#define WAVEFORM_ID   104&lt;/span&gt;
&lt;span class=&quot;preprocessor&quot;&gt;#define KNOB_ID       105&lt;/span&gt;

&lt;span class=&quot;comment&quot;&gt;// Image resource locations for this plug.&lt;/span&gt;
&lt;span class=&quot;preprocessor&quot;&gt;#define BG_FN         &quot;resources/img/bg.png&quot;&lt;/span&gt;
&lt;span class=&quot;preprocessor&quot;&gt;#define WHITE_KEY_FN  &quot;resources/img/whitekey.png&quot;&lt;/span&gt;
&lt;span class=&quot;preprocessor&quot;&gt;#define BLACK_KEY_FN  &quot;resources/img/blackkey.png&quot;&lt;/span&gt;
&lt;span class=&quot;preprocessor&quot;&gt;#define WAVEFORM_FN   &quot;resources/img/waveform.png&quot;&lt;/span&gt;
&lt;span class=&quot;preprocessor&quot;&gt;#define KNOB_FN       &quot;resources/img/knob.png&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;While you’re there, change the GUI height to match the dimensions of &lt;em&gt;bg.png&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#define GUI_HEIGHT 296&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Also edit the beginning of &lt;em&gt;Synthesis.rc&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#include &quot;resource.h&quot;&lt;/span&gt;

BG_ID       PNG BG_FN
WHITE_KEY_ID       PNG WHITE_KEY_FN
BLACK_KEY_ID       PNG BLACK_KEY_FN
WAVEFORM_ID       PNG WAVEFORM_FN
KNOB_ID       PNG KNOB_FN
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We need to add parameters for the waveform and for the envelope stages &lt;em&gt;Attack&lt;/em&gt;, &lt;em&gt;Decay&lt;/em&gt;, &lt;em&gt;Sustain&lt;/em&gt; and &lt;em&gt;Release&lt;/em&gt;. Go into &lt;em&gt;Synthesis.cpp&lt;/em&gt; and change the &lt;code&gt;EParams&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;enum&lt;/span&gt; EParams
{
    mWaveform = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,
    mAttack,
    mDecay,
    mSustain,
    mRelease,
    kNumParams
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Also change the virtual keyboard’s position so it’s at the bottom:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;enum&lt;/span&gt; ELayout
{
    kWidth = GUI_WIDTH,
    kHeight = GUI_HEIGHT,
    kKeybX = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,
    kKeybY = &lt;span class=&quot;number&quot;&gt;230&lt;/span&gt;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now go to &lt;em&gt;Oscillator.h&lt;/em&gt; and change the &lt;code&gt;OscillatorMode&lt;/code&gt; to include the total number of modes:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;enum&lt;/span&gt; OscillatorMode {
    OSCILLATOR_MODE_SINE = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,
    OSCILLATOR_MODE_SAW,
    OSCILLATOR_MODE_SQUARE,
    OSCILLATOR_MODE_TRIANGLE,
    kNumOscillatorModes
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Change the initializer list so the sine wave is the default:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;Oscillator() :
    mOscillatorMode(OSCILLATOR_MODE_SINE),
    &lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Building the GUI is done in the constructor. Add the following just before the &lt;code&gt;AttachGraphics(pGraphics)&lt;/code&gt; line:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Waveform switch&lt;/span&gt;
GetParam(mWaveform)-&amp;gt;InitEnum(&lt;span class=&quot;string&quot;&gt;&quot;Waveform&quot;&lt;/span&gt;, OSCILLATOR_MODE_SINE, kNumOscillatorModes);
GetParam(mWaveform)-&amp;gt;SetDisplayText(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Sine&quot;&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;// Needed for VST3, thanks plunntic&lt;/span&gt;
IBitmap waveformBitmap = pGraphics-&amp;gt;LoadIBitmap(WAVEFORM_ID, WAVEFORM_FN, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;);
pGraphics-&amp;gt;AttachControl(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ISwitchControl(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;24&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;53&lt;/span&gt;, mWaveform, &amp;amp;waveformBitmap));

&lt;span class=&quot;comment&quot;&gt;// Knob bitmap for ADSR&lt;/span&gt;
IBitmap knobBitmap = pGraphics-&amp;gt;LoadIBitmap(KNOB_ID, KNOB_FN, &lt;span class=&quot;number&quot;&gt;64&lt;/span&gt;);
&lt;span class=&quot;comment&quot;&gt;// Attack knob:&lt;/span&gt;
GetParam(mAttack)-&amp;gt;InitDouble(&lt;span class=&quot;string&quot;&gt;&quot;Attack&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0.01&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0.01&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;10.0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0.001&lt;/span&gt;);
GetParam(mAttack)-&amp;gt;SetShape(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;);
pGraphics-&amp;gt;AttachControl(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; IKnobMultiControl(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;95&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;34&lt;/span&gt;, mAttack, &amp;amp;knobBitmap));
&lt;span class=&quot;comment&quot;&gt;// Decay knob:&lt;/span&gt;
GetParam(mDecay)-&amp;gt;InitDouble(&lt;span class=&quot;string&quot;&gt;&quot;Decay&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0.5&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0.01&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;15.0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0.001&lt;/span&gt;);
GetParam(mDecay)-&amp;gt;SetShape(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;);
pGraphics-&amp;gt;AttachControl(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; IKnobMultiControl(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;177&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;34&lt;/span&gt;, mDecay, &amp;amp;knobBitmap));
&lt;span class=&quot;comment&quot;&gt;// Sustain knob:&lt;/span&gt;
GetParam(mSustain)-&amp;gt;InitDouble(&lt;span class=&quot;string&quot;&gt;&quot;Sustain&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0.1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0.001&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0.001&lt;/span&gt;);
GetParam(mSustain)-&amp;gt;SetShape(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);
pGraphics-&amp;gt;AttachControl(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; IKnobMultiControl(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;259&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;34&lt;/span&gt;, mSustain, &amp;amp;knobBitmap));
&lt;span class=&quot;comment&quot;&gt;// Release knob:&lt;/span&gt;
GetParam(mRelease)-&amp;gt;InitDouble(&lt;span class=&quot;string&quot;&gt;&quot;Release&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0.001&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;15.0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0.001&lt;/span&gt;);
GetParam(mRelease)-&amp;gt;SetShape(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;);
pGraphics-&amp;gt;AttachControl(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; IKnobMultiControl(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;341&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;34&lt;/span&gt;, mRelease, &amp;amp;knobBitmap));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;First, we create the &lt;code&gt;mWaveform&lt;/code&gt; parameter. It’s an &lt;code&gt;Enum&lt;/code&gt; parameter with the default value of &lt;code&gt;OSCILLATOR_MODE_SINE&lt;/code&gt; and &lt;code&gt;kNumOscillatorModes&lt;/code&gt; possible values. The we load the &lt;em&gt;waveform.png&lt;/em&gt; bitmap. Here we use the literal &lt;code&gt;4&lt;/code&gt; for the number of frames. We could use &lt;code&gt;kNumOscillatorModes&lt;/code&gt;, which at the moment has the value of &lt;code&gt;4&lt;/code&gt;. But if we add additional waveforms to the oscillator and we don’t change &lt;em&gt;waveform.png&lt;/em&gt; to include them, it will break. We then create a &lt;code&gt;new ISwitchControl&lt;/code&gt;, passing the coordinates and linking it to the &lt;code&gt;mWaveform&lt;/code&gt; parameter.&lt;br&gt;For the knobs, we import &lt;em&gt;knob.png&lt;/em&gt; just &lt;em&gt;once&lt;/em&gt; and use it for all four &lt;code&gt;IKnobMultiControl&lt;/code&gt;s. We use &lt;code&gt;SetShape&lt;/code&gt; to make the knobs more sensitive for small values (and more coarse for large values). We’re setting the same default values as in the &lt;code&gt;EnvelopeGenerator&lt;/code&gt;‘s constructor. This duplication could be avoided. You can choose the minimum and maximum values freely (the 3rd and 4th parameter to &lt;code&gt;InitDouble&lt;/code&gt;).&lt;/p&gt;
&lt;h2 id=&quot;handling-value-changes&quot;&gt;Handling Value Changes&lt;/h2&gt;
&lt;p&gt;Reacting to user input is done by implementing &lt;code&gt;OnParamChange&lt;/code&gt; (in &lt;em&gt;Synthesis.cpp&lt;/em&gt;):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; Synthesis::OnParamChange(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; paramIdx)
{
    IMutexLock lock(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;);
    &lt;span class=&quot;keyword&quot;&gt;switch&lt;/span&gt;(paramIdx) {
        &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; mWaveform:
            mOscillator.setMode(&lt;span class=&quot;keyword&quot;&gt;static_cast&lt;/span&gt;&amp;lt;OscillatorMode&amp;gt;(GetParam(mWaveform)-&amp;gt;Int()));
            &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;
        &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; mAttack:
        &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; mDecay:
        &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; mSustain:
        &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; mRelease:
            mEnvelopeGenerator.setStageValue(&lt;span class=&quot;keyword&quot;&gt;static_cast&lt;/span&gt;&amp;lt;EnvelopeGenerator::EnvelopeStage&amp;gt;(paramIdx), GetParam(paramIdx)-&amp;gt;Value());
            &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For the &lt;code&gt;mWaveform&lt;/code&gt; case, we get the &lt;code&gt;int&lt;/code&gt; value and simply cast it to &lt;code&gt;OscillatorMode&lt;/code&gt;.&lt;br&gt;As you can see, all envelope parameters share the same line of code. If you compare the &lt;code&gt;EParams&lt;/code&gt; and &lt;code&gt;EnvelopeStage&lt;/code&gt; &lt;code&gt;enum&lt;/code&gt;s, you’ll see that in both of them, &lt;em&gt;Attack&lt;/em&gt;, &lt;em&gt;Decay&lt;/em&gt;, &lt;em&gt;Sustain&lt;/em&gt; and &lt;em&gt;Release&lt;/em&gt; have the values &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt;, &lt;code&gt;3&lt;/code&gt; and &lt;code&gt;4&lt;/code&gt;, respectively. Therefore, &lt;code&gt;static_cast&amp;lt;EnvelopeGenerator::EnvelopeStage&amp;gt;(paramIdx)&lt;/code&gt; gives us the changed &lt;code&gt;EnvelopeStage&lt;/code&gt;. And &lt;code&gt;GetParam(paramIdx)-&amp;gt;Value()&lt;/code&gt; gives us the value of the changed stage. So we can just call &lt;code&gt;setStageValue&lt;/code&gt; with these two. But we haven’t implemented it yet! Add the following member function prototype to the &lt;code&gt;public&lt;/code&gt; section of the &lt;code&gt;EnvelopeGenerator&lt;/code&gt; class:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; setStageValue(EnvelopeStage stage, &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; value);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let’s imagine for a moment that this was a simple setter:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// This won't be enough:&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; EnvelopeGenerator::setStageValue(EnvelopeStage stage,
                                      &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; value) {
    stageValue[stage] = value;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;What if we change the &lt;code&gt;stageValue[ENVELOPE_STAGE_ATTACK]&lt;/code&gt; while the generator is in that stage? This implementation doesn’t call &lt;code&gt;calculateMultiplier&lt;/code&gt; or set &lt;code&gt;nextStageSampleIndex&lt;/code&gt;. So the generator will only consider the change &lt;em&gt;the next time it enters&lt;/em&gt; the given stage. This is also true for the SUSTAIN stage: You can’t hold a note and tweak the knob to find the right sustain level.&lt;br&gt;This is inconvenient and you wouldn’t find this in a professional plugin. When we turn a knob, we want to hear the change immediately.&lt;br&gt;So whenever we change the value for the stage the generator is currently in, the generator should update its values. This means calling &lt;code&gt;calculateMultiplier&lt;/code&gt; with a new time interval &lt;em&gt;and&lt;/em&gt; recalculating &lt;code&gt;nextStageSampleIndex&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; EnvelopeGenerator::setStageValue(EnvelopeStage stage,
                                      &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; value) {
    stageValue[stage] = value;
    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (stage == currentStage) {
        &lt;span class=&quot;comment&quot;&gt;// Re-calculate the multiplier and nextStageSampleIndex&lt;/span&gt;
        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(currentStage == ENVELOPE_STAGE_ATTACK ||
                currentStage == ENVELOPE_STAGE_DECAY ||
                currentStage == ENVELOPE_STAGE_RELEASE) {
            &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; nextLevelValue;
            &lt;span class=&quot;keyword&quot;&gt;switch&lt;/span&gt; (currentStage) {
                &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; ENVELOPE_STAGE_ATTACK:
                    nextLevelValue = &lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;;
                    &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;
                &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; ENVELOPE_STAGE_DECAY:
                    nextLevelValue = fmax(stageValue[ENVELOPE_STAGE_SUSTAIN], minimumLevel);
                    &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;
                &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; ENVELOPE_STAGE_RELEASE:
                    nextLevelValue = minimumLevel;
                    &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;
                &lt;span class=&quot;keyword&quot;&gt;default&lt;/span&gt;:
                    &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;
            }
            &lt;span class=&quot;comment&quot;&gt;// How far the generator is into the current stage:&lt;/span&gt;
            &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; currentStageProcess = (currentSampleIndex + &lt;span class=&quot;number&quot;&gt;0.0&lt;/span&gt;) / nextStageSampleIndex;
            &lt;span class=&quot;comment&quot;&gt;// How much of the current stage is left:&lt;/span&gt;
            &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; remainingStageProcess = &lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt; - currentStageProcess;
            &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; samplesUntilNextStage = remainingStageProcess * value * sampleRate;
            nextStageSampleIndex = currentSampleIndex + samplesUntilNextStage;
            calculateMultiplier(currentLevel, nextLevelValue, samplesUntilNextStage);
        } &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(currentStage == ENVELOPE_STAGE_SUSTAIN) {
            currentLevel = value;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The inner &lt;code&gt;if&lt;/code&gt; statement checks if the generator is in a stage that uses &lt;code&gt;nextStageSampleIndex&lt;/code&gt; to expire (i.e. ATTACK, DECAY or RELEASE). &lt;code&gt;nextLevelValue&lt;/code&gt; is the level value the generator is currently transitioning to. It is set just like inside the &lt;code&gt;enterStage&lt;/code&gt; function. The interesting part is below the &lt;code&gt;switch&lt;/code&gt; statement: Whatever phase the generator currently is in, it should behave according to the new value &lt;em&gt;for the rest of the current stage&lt;/em&gt;. So we have to split the current stage into the past and the future part. First we calculate how far the generator is into the current stage. For example, &lt;code&gt;0.1&lt;/code&gt; means “10% done”. &lt;code&gt;remainingStageProcess&lt;/code&gt; is how much is left in the current stage. We can then calculate &lt;code&gt;samplesUntilNextStage&lt;/code&gt; and update &lt;code&gt;nextStageSampleIndex&lt;/code&gt;. Finally (and most importantly), we call &lt;code&gt;calculateMultiplier&lt;/code&gt; to get a transition from &lt;code&gt;currentLevel&lt;/code&gt; to &lt;code&gt;nextLevelValue&lt;/code&gt; over &lt;code&gt;samplesUntilNextStage&lt;/code&gt; samples.&lt;br&gt;The SUSTAIN case is simple: We just set &lt;code&gt;currentLevel&lt;/code&gt; to the new value.&lt;/p&gt;
&lt;p&gt;With this implementation, we have covered &lt;em&gt;almost&lt;/em&gt; all cases. There’s one more special case we have to handle: When the generator is in DECAY stage and the SUSTAIN value is changed. With the current implementation, it will decay to the &lt;em&gt;old&lt;/em&gt; sustain level, and when the decay stage is over, it will &lt;em&gt;jump&lt;/em&gt; to the &lt;em&gt;new&lt;/em&gt; sustain level. To correct this behaviour, add the following at the end of &lt;code&gt;setStageValue&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (currentStage == ENVELOPE_STAGE_DECAY &amp;amp;&amp;amp;
    stage == ENVELOPE_STAGE_SUSTAIN) {
    &lt;span class=&quot;comment&quot;&gt;// We have to decay to a different sustain value than before.&lt;/span&gt;
    &lt;span class=&quot;comment&quot;&gt;// Re-calculate multiplier:&lt;/span&gt;
    &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; samplesUntilNextStage = nextStageSampleIndex - currentSampleIndex;
    calculateMultiplier(currentLevel,
                        fmax(stageValue[ENVELOPE_STAGE_SUSTAIN], minimumLevel),
                        samplesUntilNextStage);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This makes sure we’re decaying to the new sustain level. Note that we’re not changing &lt;code&gt;nextStageSampleIndex&lt;/code&gt; here because it’s not affected by the sustain level.&lt;/p&gt;
&lt;p&gt;Run the plugin. You can cycle through waveforms by clicking on the waveform icon. Tweak all four knobs while playing and holding notes and see how it immediately reacts and does what we want.&lt;/p&gt;
&lt;h2 id=&quot;further-improvements&quot;&gt;Further Improvements&lt;/h2&gt;
&lt;p&gt;Have a look at this part of &lt;code&gt;ProcessDoubleReplacing&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; velocity = mMIDIReceiver.getLastVelocity();
&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (velocity &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) {
    mOscillator.setFrequency(mMIDIReceiver.getLastFrequency());
    mOscillator.setMuted(&lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;);
} &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; {
    mOscillator.setMuted(&lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Remember &lt;a href=&quot;http://www.martin-finke.de/articles/audio-plugins-011-envelopes/#no_longer_resetting_velocity&quot;&gt;that we decided not to reset the MIDI receiver’s &lt;code&gt;mLastVelocity&lt;/code&gt; anymore&lt;/a&gt;? This means that after the first played note, &lt;code&gt;mOscillator&lt;/code&gt; will never be muted again. So it will keep generating a waveform even when no note is played. Change the &lt;code&gt;for&lt;/code&gt; loop to look like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; nFrames; ++i) {
    mMIDIReceiver.advance();
    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; velocity = mMIDIReceiver.getLastVelocity();
    mOscillator.setFrequency(mMIDIReceiver.getLastFrequency());
    leftOutput[i] = rightOutput[i] = mOscillator.nextSample() * mEnvelopeGenerator.nextSample() * velocity / &lt;span class=&quot;number&quot;&gt;127.0&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So when should &lt;code&gt;mOscillator&lt;/code&gt; generate a waveform? Whenever &lt;code&gt;mEnvelopeGenerator.currentStage&lt;/code&gt; is not &lt;code&gt;ENVELOPE_STAGE_OFF&lt;/code&gt;. So the right place to react is inside &lt;code&gt;mEnvelopeGenerator.enterStage&lt;/code&gt;. Of course, for reasons explained &lt;a href=&quot;http://www.martin-finke.de/articles/audio-plugins-011-envelopes/#avoiding_coupling&quot;&gt;before&lt;/a&gt;, we’re not going to call something on &lt;code&gt;mOscillator&lt;/code&gt; here. We’re again using &lt;a href=&quot;http://www.martin-finke.de/articles/audio-plugins-011-envelopes/#signals_slots&quot;&gt;Signals &amp;amp; Slots&lt;/a&gt; for a clean solution. In &lt;em&gt;EnvelopeGenerator.h&lt;/em&gt;, add the following two lines before the class definition:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#include &quot;GallantSignal.h&quot;&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;using&lt;/span&gt; Gallant::Signal0;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Add two &lt;code&gt;Signal&lt;/code&gt;s to the &lt;code&gt;public&lt;/code&gt; section:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;Signal0&amp;lt;&amp;gt; beganEnvelopeCycle;
Signal0&amp;lt;&amp;gt; finishedEnvelopeCycle;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In &lt;em&gt;EnvelopeGenerator.cpp&lt;/em&gt;, add the following at the very beginning of &lt;code&gt;enterStage&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (currentStage == newStage) &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;
&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (currentStage == ENVELOPE_STAGE_OFF) {
    beganEnvelopeCycle();
}
&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (newStage == ENVELOPE_STAGE_OFF) {
    finishedEnvelopeCycle();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The first &lt;code&gt;if&lt;/code&gt; statement just makes sure that the generator can’t go from a stage into that same stage. The other two &lt;code&gt;if&lt;/code&gt; statements mean:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;When we go &lt;em&gt;out of&lt;/em&gt; the OFF stage, it means we’re beginning a new cycle.&lt;/li&gt;
&lt;li&gt;When we go &lt;em&gt;into&lt;/em&gt; the OFF stage, it means we have finished a cycle.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Let’s react to the &lt;code&gt;Signal&lt;/code&gt;! Add the following &lt;code&gt;private&lt;/code&gt; member functions to &lt;em&gt;Synthesis.h&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; onBeganEnvelopeCycle() { mOscillator.setMuted(&lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;); }
&lt;span class=&quot;keyword&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; onFinishedEnvelopeCycle() { mOscillator.setMuted(&lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;); }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When an envelope cycle begins, we unmute the oscillator. When it ends, we mute the oscillator again.&lt;br&gt;In &lt;em&gt;Synthesis.cpp&lt;/em&gt;, connect signal and slot at the very end of the constructor:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;mEnvelopeGenerator.beganEnvelopeCycle.Connect(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, &amp;amp;Synthesis::onBeganEnvelopeCycle);
mEnvelopeGenerator.finishedEnvelopeCycle.Connect(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, &amp;amp;Synthesis::onFinishedEnvelopeCycle);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That’s it! Run the plugin and it should behave just like before! If you press Cmd+Alt+P in Reaper (Ctrl+Alt+P on Windows) you’ll get a performance meter:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/blog/articles/audio-plugins-012-envelopes-gui/performance-meter.png&quot;&gt;&lt;img src=&quot;/blog/articles/audio-plugins-012-envelopes-gui/performance-meter.png&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The percent value marked red is the track’s total CPU usage. It should go up whenever you play a note, and down again whenever it has fully faded out. That’s because the oscillator won’t have to calculate sample values.&lt;/p&gt;
&lt;p&gt;Now we have a very nice envelope generator! Click &lt;a href=&quot;/blog/articles/audio-plugins-012-envelopes-gui/source.zip&quot;&gt;here&lt;/a&gt; to download the source files for this post.&lt;br&gt;Up next: &lt;a href=&quot;http://www.martin-finke.de/articles/audio-plugins-013-filter/&quot;&gt;How to create a filter&lt;/a&gt;!&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Making Audio Plugins Part 11: Envelopes</title>
      <link>http://www.martin-finke.de/blog/articles/audio-plugins-011-envelopes/</link>
      <pubDate>Sat, 05 Oct 2013 19:48:00 +0200</pubDate>
      <guid isPermaLink="true">http://www.martin-finke.de/blog/articles/audio-plugins-011-envelopes/</guid>
      <author></author>
      <description>&lt;p&gt;Sound is only interesting when there’s variation over time. Let’s create an envelope generator to make variations in volume! &lt;span class=&quot;more&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;envelope-generator-basics&quot;&gt;Envelope Generator Basics&lt;/h2&gt;
&lt;p&gt;If you’re not familiar with the term &lt;em&gt;ADSR&lt;/em&gt; (meaning &lt;em&gt;Attack Decay Sustain Release&lt;/em&gt;), please read &lt;a href=&quot;http://en.wikipedia.org/wiki/Synthesizer#ADSR_envelope&quot;&gt;this&lt;/a&gt; before we go on.&lt;br&gt;Basically, our envelope generator is a &lt;a href=&quot;http://en.wikipedia.org/wiki/Finite-state_machine&quot;&gt;finite state machine&lt;/a&gt; with the states &lt;em&gt;Off&lt;/em&gt;, &lt;em&gt;Attack&lt;/em&gt;, &lt;em&gt;Decay&lt;/em&gt;, &lt;em&gt;Sustain&lt;/em&gt; and &lt;em&gt;Release&lt;/em&gt;. That’s a fancy way of saying that at any given point in time, it is in exactly one of those states. In envelope terms, these are called &lt;em&gt;stages&lt;/em&gt;. Going from one stage to another will be done by calling the &lt;code&gt;enterStage&lt;/code&gt; member function.&lt;br&gt;A few key points about envelope stages:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The generator gets out of the ATTACK, DECAY and RELEASE stage by itself: After a given time has passed, it calls &lt;code&gt;enterStage&lt;/code&gt; to go to the next stage.&lt;/li&gt;
&lt;li&gt;It stays in the OFF and SUSTAIN stages indefinitely, until &lt;code&gt;enterStage&lt;/code&gt; is called from outside.&lt;/li&gt;
&lt;li&gt;Therefore, ATTACK, DECAY and RELEASE are &lt;em&gt;time&lt;/em&gt; values, but SUSTAIN is a &lt;em&gt;level&lt;/em&gt; value.&lt;/li&gt;
&lt;li&gt;It can enter the RELEASE stage coming from the ATTACK, DECAY or SUSTAIN stage.&lt;/li&gt;
&lt;li&gt;When entering RELEASE, it should decay &lt;em&gt;from the current level&lt;/em&gt; down to zero.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For each sample, the envelope generator will give us a &lt;code&gt;double&lt;/code&gt; between zero and one. We’ll get the current value from the envelope generator, and then we’ll &lt;em&gt;multiply&lt;/em&gt; our signal with this value. This way, the signal’s volume will be determined by the envelope: We’ll be able to create tones that fade in slowly or quickly decay in volume.&lt;/p&gt;
&lt;h2 id=&quot;the-envelopegenerator-class&quot;&gt;The &lt;code&gt;EnvelopeGenerator&lt;/code&gt; Class&lt;/h2&gt;
&lt;p&gt;Create a new C++ class named &lt;code&gt;EnvelopeGenerator&lt;/code&gt; and add it to all targets. Go into &lt;em&gt;EnvelopeGenerator.h&lt;/em&gt; and add the following class declaration (between &lt;code&gt;#define&lt;/code&gt; and &lt;code&gt;#endif&lt;/code&gt;):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#include &amp;lt;cmath&amp;gt;&lt;/span&gt;

&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; EnvelopeGenerator {
&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:
    &lt;span class=&quot;keyword&quot;&gt;enum&lt;/span&gt; EnvelopeStage {
        ENVELOPE_STAGE_OFF = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,
        ENVELOPE_STAGE_ATTACK,
        ENVELOPE_STAGE_DECAY,
        ENVELOPE_STAGE_SUSTAIN,
        ENVELOPE_STAGE_RELEASE,
        kNumEnvelopeStages
    };
    &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; enterStage(EnvelopeStage newStage);
    &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; nextSample();
    &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; setSampleRate(&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; newSampleRate);
    &lt;span class=&quot;keyword&quot;&gt;inline&lt;/span&gt; EnvelopeStage getCurrentStage() &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; { &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; currentStage; };
    &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; minimumLevel;

    EnvelopeGenerator() :
    minimumLevel(&lt;span class=&quot;number&quot;&gt;0.0001&lt;/span&gt;),
    currentStage(ENVELOPE_STAGE_OFF),
    currentLevel(minimumLevel),
    multiplier(&lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;),
    sampleRate(&lt;span class=&quot;number&quot;&gt;44100.0&lt;/span&gt;),
    currentSampleIndex(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;),
    nextStageSampleIndex(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) {
        stageValue[ENVELOPE_STAGE_OFF] = &lt;span class=&quot;number&quot;&gt;0.0&lt;/span&gt;;
        stageValue[ENVELOPE_STAGE_ATTACK] = &lt;span class=&quot;number&quot;&gt;0.01&lt;/span&gt;;
        stageValue[ENVELOPE_STAGE_DECAY] = &lt;span class=&quot;number&quot;&gt;0.5&lt;/span&gt;;
        stageValue[ENVELOPE_STAGE_SUSTAIN] = &lt;span class=&quot;number&quot;&gt;0.1&lt;/span&gt;;
        stageValue[ENVELOPE_STAGE_RELEASE] = &lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;;
    };
&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt;:
    EnvelopeStage currentStage;
    &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; currentLevel;
    &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; multiplier;
    &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; sampleRate;
    &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; stageValue[kNumEnvelopeStages];
    &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; calculateMultiplier(&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; startLevel, &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; endLevel, &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; lengthInSamples);
    &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; currentSampleIndex;
    &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; nextStageSampleIndex;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;First, we’re defining an &lt;code&gt;enum&lt;/code&gt; with all the envelope stages. We add &lt;code&gt;kNumEnvelopeStages&lt;/code&gt; at the end so we know how many stages there are. Note that we’re scoping the &lt;code&gt;enum&lt;/code&gt; to the &lt;code&gt;EnvelopeGenerator&lt;/code&gt; class. This means that it won’t go into the global namespace.&lt;br&gt;We’ll discuss the member functions when we implement them. &lt;code&gt;minimumLevel&lt;/code&gt; is needed because the envelope calculations don’t work with an amplitude of zero. We initialize it to the very small value of &lt;code&gt;0.001&lt;/code&gt;.&lt;br&gt;The initializer list makes sure that the envelope is in the &lt;code&gt;OFF&lt;/code&gt; stage by default and initializes the &lt;code&gt;stageValue&lt;/code&gt; array to some default values: Short attack, 0.5 seconds decay, quiet sustain, one second release.&lt;br&gt;In the &lt;code&gt;private&lt;/code&gt; section, &lt;code&gt;currentStage&lt;/code&gt; indicates what stage the envelope is currently in. &lt;code&gt;currentLevel&lt;/code&gt; is the current envelope level that we’ll get on every sample. The &lt;code&gt;multiplier&lt;/code&gt; is responsible for the exponential decay as &lt;a href=&quot;http://www.martin-finke.de/articles/audio-plugins-011-envelopes/#decay_multiplier&quot;&gt;described below&lt;/a&gt;.&lt;br&gt;During ATTACK, DECAY and RELEASE, the generator has to keep track of where it currently is so it can enter the next stage after a given time (i.e. after the transition is finished). Instead of comparing some &lt;code&gt;double&lt;/code&gt; value, we’re using a &lt;code&gt;currentSampleIndex&lt;/code&gt;. Open &lt;em&gt;EnvelopeGenerator.cpp&lt;/em&gt; and add the following implementation:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; EnvelopeGenerator::nextSample() {
    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (currentStage != ENVELOPE_STAGE_OFF &amp;amp;&amp;amp;
        currentStage != ENVELOPE_STAGE_SUSTAIN) {
        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (currentSampleIndex == nextStageSampleIndex) {
            EnvelopeStage newStage = &lt;span class=&quot;keyword&quot;&gt;static_cast&lt;/span&gt;&amp;lt;EnvelopeStage&amp;gt;(
                (currentStage + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) % kNumEnvelopeStages
            );
            enterStage(newStage);
        }
        currentLevel *= multiplier;
        currentSampleIndex++;
    }
    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; currentLevel;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If the generator is in ATTACK, DECAY or RELEASE stage and the &lt;code&gt;currentSampleIndex&lt;/code&gt; has reached the value of &lt;code&gt;nextStageSampleIndex&lt;/code&gt;, we just get the next item from the &lt;code&gt;EnvelopeStage&lt;/code&gt; &lt;code&gt;enum&lt;/code&gt;. Because of the modulo operator, it will go back to &lt;code&gt;ENVELOPE_STAGE_OFF&lt;/code&gt; after &lt;code&gt;ENVELOPE_STAGE_RELEASE&lt;/code&gt; (which is what we want). Finally, we call &lt;code&gt;enterStage&lt;/code&gt; to go into the next stage.&lt;br&gt;We then modify the &lt;code&gt;currentLevel&lt;/code&gt; and increment the &lt;code&gt;currentSampleIndex&lt;/code&gt; to keep track of time. Note that this doesn’t happen in the OFF and SUSTAIN stages: In these stages the level must stay the same, so there’s no need to calculate. The same goes for &lt;code&gt;currentSampleIndex&lt;/code&gt;: The OFF and SUSTAIN stages don’t expire after a given time, so the generator doesn’t have to check if they are over.&lt;/p&gt;
&lt;p&gt;&lt;a name=&quot;decay_multiplier&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;transitions-over-time&quot;&gt;Transitions Over Time&lt;/h2&gt;
&lt;p&gt;In the ATTACK, DECAY and RELEASE stage, the generator transitions between two values over a given amount of time. Our ear perceives volume &lt;a href=&quot;http://en.wikibooks.org/wiki/Engineering_Acoustics/The_Human_Ear_and_Sound_Perception&quot;&gt;in a &lt;em&gt;logarithmic&lt;/em&gt; way&lt;/a&gt;. So in order to &lt;em&gt;hear&lt;/em&gt; a volume change as linear, it has to be &lt;em&gt;exponential&lt;/em&gt;.&lt;br&gt;There are different ways to calculate an exponential curve between two points. The most intuitive would be to call &lt;code&gt;exp&lt;/code&gt; (from &lt;code&gt;&amp;lt;cmath&amp;gt;&lt;/code&gt;) on every sample. However, there’s a smarter way that calculates a multiplier based on the two values and the given time. On every sample, the current envelope value is multiplied with this value.&lt;br&gt;Implement the following function to calculate the value (it’s based on Christian Schoenebeck’s &lt;a href=&quot;http://www.musicdsp.org/showone.php?id=189&quot;&gt;Fast Exponential Envelope Generator&lt;/a&gt;):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; EnvelopeGenerator::calculateMultiplier(&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; startLevel,
                                            &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; endLevel,
                                            &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; lengthInSamples) {
    multiplier = &lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt; + (&lt;span class=&quot;built_in&quot;&gt;log&lt;/span&gt;(endLevel) - &lt;span class=&quot;built_in&quot;&gt;log&lt;/span&gt;(startLevel)) / (lengthInSamples);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;At this point it’s not that important to fully understand the equation. Just be aware that this function takes &lt;code&gt;startLevel&lt;/code&gt;, &lt;code&gt;endLevel&lt;/code&gt; and the transition’s &lt;code&gt;lengthInSamples&lt;/code&gt; and calculates a &lt;code&gt;multiplier&lt;/code&gt; that will be a number slightly below or slightly above 1. We’ll multiply &lt;code&gt;currentLevel&lt;/code&gt; with this to get an exponential transition. By the way, &lt;code&gt;log()&lt;/code&gt; is the &lt;em&gt;natural&lt;/em&gt; logarithm.&lt;/p&gt;
&lt;h2 id=&quot;changing-envelope-stages&quot;&gt;Changing Envelope Stages&lt;/h2&gt;
&lt;p&gt;Now that we know how to calculate the &lt;code&gt;multiplier&lt;/code&gt;, let’s implement &lt;code&gt;enterStage&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; EnvelopeGenerator::enterStage(EnvelopeStage newStage) {
    currentStage = newStage;
    currentSampleIndex = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;
    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (currentStage == ENVELOPE_STAGE_OFF ||
        currentStage == ENVELOPE_STAGE_SUSTAIN) {
        nextStageSampleIndex = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;
    } &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; {
        nextStageSampleIndex = stageValue[currentStage] * sampleRate;
    }
    &lt;span class=&quot;keyword&quot;&gt;switch&lt;/span&gt; (newStage) {
        &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; ENVELOPE_STAGE_OFF:
            currentLevel = &lt;span class=&quot;number&quot;&gt;0.0&lt;/span&gt;;
            multiplier = &lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;;
            &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;
        &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; ENVELOPE_STAGE_ATTACK:
            currentLevel = minimumLevel;
            calculateMultiplier(currentLevel,
                                &lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;,
                                nextStageSampleIndex);
            &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;
        &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; ENVELOPE_STAGE_DECAY:
            currentLevel = &lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;;
            calculateMultiplier(currentLevel,
                                fmax(stageValue[ENVELOPE_STAGE_SUSTAIN], minimumLevel),
                                nextStageSampleIndex);
            &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;
        &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; ENVELOPE_STAGE_SUSTAIN:
            currentLevel = stageValue[ENVELOPE_STAGE_SUSTAIN];
            multiplier = &lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;;
            &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;
        &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; ENVELOPE_STAGE_RELEASE:
            &lt;span class=&quot;comment&quot;&gt;// We could go from ATTACK/DECAY to RELEASE,&lt;/span&gt;
            &lt;span class=&quot;comment&quot;&gt;// so we're not changing currentLevel here.&lt;/span&gt;
            calculateMultiplier(currentLevel,
                                minimumLevel,
                                nextStageSampleIndex);
            &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;
        &lt;span class=&quot;keyword&quot;&gt;default&lt;/span&gt;:
            &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After updating &lt;code&gt;currentStage&lt;/code&gt; to the new value, we make sure that &lt;code&gt;currentSampleIndex&lt;/code&gt; starts counting from zero again. Then we calculate how long (i.e. &lt;em&gt;how many samples&lt;/em&gt;) it will take until the next stage. As already mentioned, this is only needed for the ATTACK, DECAY and RELEASE stages. Since &lt;code&gt;stageValue[currentStage]&lt;/code&gt; gives us a &lt;code&gt;double&lt;/code&gt; value (the stage duration in seconds), we multiply with sampleRate to get the stage length &lt;em&gt;in samples&lt;/em&gt;.&lt;br&gt;The &lt;code&gt;switch&lt;/code&gt; branches between the possible stages. In the OFF case, we just set the level to zero and the multiplier to one (actually we don’t &lt;em&gt;have&lt;/em&gt; to do that, but to me it looks more consistent). For ATTACK, we make sure to start from the very silent &lt;code&gt;minimumLevel&lt;/code&gt; and we calculate the multiplier, so the transition will be from the currentLevel to &lt;code&gt;1.0&lt;/code&gt;. For DECAY, we let the level fall from the current value to the sustain level (&lt;code&gt;stageValue[ENVELOPE_STAGE_SUSTAIN]&lt;/code&gt;), but using &lt;code&gt;fmax&lt;/code&gt; we make sure that it doesn’t reach zero. The RELEASE stage decays from the &lt;code&gt;currentLevel&lt;/code&gt; (whatever that is) to the &lt;code&gt;minimumLevel&lt;/code&gt;. As explained by the comment, we’re not changing &lt;code&gt;currentLevel&lt;/code&gt; here because we don’t know from which stage and level it is entering RELEASE stage.&lt;br&gt;The SUSTAIN stage is a special case. As already mentioned, &lt;code&gt;stageValue[ENVELOPE_STAGE_SUSTAIN]&lt;/code&gt; holds a &lt;em&gt;level&lt;/em&gt; value, not a &lt;em&gt;time&lt;/em&gt; value. So we just assign that to &lt;code&gt;currentLevel&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&quot;a-first-test&quot;&gt;A First Test&lt;/h2&gt;
&lt;p&gt;Add the (simple) implementation for &lt;code&gt;setSampleRate&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; EnvelopeGenerator::setSampleRate(&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; newSampleRate) {
    sampleRate = newSampleRate;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Add a &lt;code&gt;private&lt;/code&gt; member to the &lt;code&gt;Synthesis&lt;/code&gt; class (in &lt;em&gt;Synthesis.h&lt;/em&gt;):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;EnvelopeGenerator mEnvelopeGenerator;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Make sure you also &lt;code&gt;#include &amp;quot;EnvelopeGenerator.h&amp;quot;&lt;/code&gt; before the class declaration.&lt;br&gt;&lt;a name=&quot;envelope_looping&quot;&gt;&lt;/a&gt;
In &lt;em&gt;Synthesis.cpp&lt;/em&gt;, replace the &lt;code&gt;leftOutput[i]&lt;/code&gt; line in &lt;code&gt;ProcessDoubleReplacing&lt;/code&gt; with the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// leftOutput[i] = rightOutput[i] = mOscillator.nextSample() * velocity / 127.0;&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (mEnvelopeGenerator.getCurrentStage() == EnvelopeGenerator::ENVELOPE_STAGE_OFF) {
    mEnvelopeGenerator.enterStage(EnvelopeGenerator::ENVELOPE_STAGE_ATTACK);
}
&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (mEnvelopeGenerator.getCurrentStage() == EnvelopeGenerator::ENVELOPE_STAGE_SUSTAIN) {
    mEnvelopeGenerator.enterStage(EnvelopeGenerator::ENVELOPE_STAGE_RELEASE);
}
leftOutput[i] = rightOutput[i] = mOscillator.nextSample() * mEnvelopeGenerator.nextSample() * velocity / &lt;span class=&quot;number&quot;&gt;127.0&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The code is for testing purposes: The two &lt;code&gt;if&lt;/code&gt; statements make the envelope generator go automatically from OFF to ATTACK stage and from SUSTAIN to RELEASE stage. This means that it will loop indefinitely. Every sample is multiplied with the current envelope generator value.&lt;br&gt;When the sample rate is set, &lt;code&gt;mEnvelopeGenerator&lt;/code&gt; has to be notified. Add the following line to &lt;code&gt;Synthesis::Reset()&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;mEnvelopeGenerator.setSampleRate(GetSampleRate());
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We’re now ready to test this! Run your plugin and hold a note on the virtual keyboard. Keep the mouse button pressed and you’ll hear that the generator keeps looping through the stages. Great!&lt;/p&gt;
&lt;h2 id=&quot;triggering-with-note-on-off&quot;&gt;Triggering with Note On/Off&lt;/h2&gt;
&lt;p&gt;A looping envelope is nice (maybe we’ll need this later), but right now we want the behaviour we know from classic synthesizers: When we play a key, it should start the ATTACK stage. When we release the key, it should go into RELEASE and fade out. The &lt;code&gt;mMIDIReceiver&lt;/code&gt; knows about note on/off, so we have to somehow connect it to &lt;code&gt;mEnvelopeGenerator&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a name=&quot;avoiding_coupling&quot;&gt;&lt;/a&gt;
A simple way to do this would be to &lt;code&gt;#include EnvelopeGenerator.h&lt;/code&gt; in &lt;em&gt;MIDIReceiver.h&lt;/em&gt;. We could then pass a reference to &lt;code&gt;mEnvelopeGenerator&lt;/code&gt; from &lt;em&gt;Synthesis.h&lt;/em&gt;, so &lt;code&gt;mMIDIReceiver&lt;/code&gt; can access it. The MIDI receiver would then just call &lt;code&gt;enterStage&lt;/code&gt; whenever it gets a note on/off message.&lt;br&gt;This is a bad idea because it makes &lt;code&gt;MIDIReceiver&lt;/code&gt; depend on an &lt;code&gt;EnvelopeGenerator&lt;/code&gt; instance. We want to have a clean separation between components: If we some day write a pure MIDI plugin without envelopes, we want to use the &lt;code&gt;MIDIReceiver&lt;/code&gt; class without depending on &lt;em&gt;EnvelopeGenerator.h&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a name=&quot;signals_slots&quot;&gt;&lt;/a&gt;
A better approach is to use &lt;a href=&quot;http://qt-project.org/doc/qt-5.0/qtcore/signalsandslots.html&quot;&gt;Signals and Slots&lt;/a&gt;. The pattern comes from the Qt framework. It can be used to connect a button to a text field, &lt;em&gt;without the two knowing each other&lt;/em&gt;. When the button is clicked, it emits a &lt;em&gt;signal&lt;/em&gt;. This signal can be connected to a &lt;em&gt;slot&lt;/em&gt; on the text field, such as &lt;code&gt;setText()&lt;/code&gt;. So when you click the button, the text changes. It’s important to know that the button’s signal doesn’t care if any (or how many) slots are connected. Whatever’s connected gets notified. We can use this pattern to connect the different components in our plugin (&lt;code&gt;Oscillator&lt;/code&gt;, &lt;code&gt;EnvelopeGenerator&lt;/code&gt;, &lt;code&gt;MIDIReceiver&lt;/code&gt;). The connection will be done &lt;em&gt;from outside&lt;/em&gt;, i.e. from the &lt;code&gt;Synthesis&lt;/code&gt; class.&lt;/p&gt;
&lt;p&gt;We won’t use the Qt framework just to get this one feature. We’ll use Patrick Hogan’s &lt;a href=&quot;https://github.com/pbhogan/Signals&quot;&gt;Signals&lt;/a&gt; library. Download and extract it. Now rename &lt;em&gt;Signal.h&lt;/em&gt; to &lt;em&gt;GallantSignal.h&lt;/em&gt; (this is to avoid name clashes). Drag the &lt;em&gt;Delegate.h&lt;/em&gt; and &lt;em&gt;GallantSignal.h&lt;/em&gt; into your project, making sure to &lt;em&gt;“Copy items into destination group’s folder”&lt;/em&gt;, and add them to all targets.&lt;/p&gt;
&lt;p&gt;We want the &lt;code&gt;MIDIReceiver&lt;/code&gt; to emit a signal whenever a note is pressed, and whenever it is released. Add the following above the class definition in &lt;em&gt;MIDIReceiver.h&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#include &quot;GallantSignal.h&quot;&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;using&lt;/span&gt; Gallant::Signal2;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Signal2&lt;/code&gt; is a signal that passes two parameters. There’s &lt;code&gt;Signal0&lt;/code&gt; through &lt;code&gt;Signal8&lt;/code&gt;, so you can choose depending on how many parameters you need. Add the following to the &lt;code&gt;public&lt;/code&gt; section:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;Signal2&amp;lt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &amp;gt; noteOn;
Signal2&amp;lt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &amp;gt; noteOff;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As you can see, both signals will pass two &lt;code&gt;int&lt;/code&gt;s. Go into &lt;em&gt;MIDIReceiver.cpp&lt;/em&gt; and modify the following parts of the &lt;code&gt;advance&lt;/code&gt; function:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// A key pressed later overrides any previously pressed key:&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (noteNumber != mLastNoteNumber) {
    mLastNoteNumber = noteNumber;
    mLastFrequency = noteNumberToFrequency(mLastNoteNumber);
    mLastVelocity = velocity;
    &lt;span class=&quot;comment&quot;&gt;// Emit a &quot;note on&quot; signal:&lt;/span&gt;
    noteOn(noteNumber, velocity);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a name=&quot;no_longer_resetting_velocity&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// If the last note was released, nothing should play:&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (noteNumber == mLastNoteNumber) {
    mLastNoteNumber = -&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;
    noteOff(noteNumber, mLastVelocity);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As you can see, the first argument is the note number and the second one is the velocity. We’re no longer setting &lt;code&gt;mLastFrequency&lt;/code&gt; to &lt;code&gt;-1&lt;/code&gt; when a key is released: During the RELEASE stage we still need the frequency to fade out. The same goes for &lt;code&gt;mLastVelocity&lt;/code&gt;: If we set it to zero, the sound will cut off immediately.&lt;br&gt;Note that the code still runs even though we haven’t connected any slot to the signals! The beauty  of the signal/slot system is to keep components independent.&lt;/p&gt;
&lt;p&gt;The next step is to connect &lt;code&gt;mEnvelopeGenerator&lt;/code&gt; to the two signals. We could add the member functions &lt;code&gt;onNoteOn&lt;/code&gt; and &lt;code&gt;onNoteOff&lt;/code&gt; to the &lt;code&gt;EnvelopeGenerator&lt;/code&gt; class and connect them to the signals. Not a bad solution, but it clutters the &lt;code&gt;EnvelopeGenerator&lt;/code&gt; with the concept of &lt;em&gt;notes&lt;/em&gt;. In my opinion, it shouldn’t know about this. Also we can’t connect the signals directly to &lt;code&gt;enterStage&lt;/code&gt; because the arguments don’t match. So let’s add the member functions to the &lt;code&gt;Synthesis&lt;/code&gt; class (in the &lt;code&gt;private&lt;/code&gt; section):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; onNoteOn(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; noteNumber, &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; velocity) { mEnvelopeGenerator.enterStage(EnvelopeGenerator::ENVELOPE_STAGE_ATTACK); };
&lt;span class=&quot;keyword&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; onNoteOff(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; noteNumber, &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; velocity) { mEnvelopeGenerator.enterStage(EnvelopeGenerator::ENVELOPE_STAGE_RELEASE); };
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note that the arguments match &lt;code&gt;noteOn&lt;/code&gt; and &lt;code&gt;noteOff&lt;/code&gt;.&lt;br&gt;To connect to the signals, add the following at the end of the constructor (in &lt;em&gt;Synthesis.cpp&lt;/em&gt;):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;mMIDIReceiver.noteOn.Connect(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, &amp;amp;Synthesis::onNoteOn);
mMIDIReceiver.noteOff.Connect(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, &amp;amp;Synthesis::onNoteOff);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The first argument is a pointer to the instance, the second one points to the member function.&lt;br&gt;We can now change &lt;code&gt;ProcessDoubleReplacing&lt;/code&gt; and remove the envelope looping. Delete the two &lt;code&gt;if&lt;/code&gt; statements we &lt;a href=&quot;http://www.martin-finke.de/articles/audio-plugins-011-envelopes/#envelope_looping&quot;&gt;added before&lt;/a&gt; (but keep the line that generates the audio samples).&lt;/p&gt;
&lt;h2 id=&quot;it-s-done-&quot;&gt;It’s done!&lt;/h2&gt;
&lt;p&gt;Run the plugin again. It should retrigger the envelope whenever you press a key. Also it should keep the sustain level as long as you hold the key. Try releasing a key during the DECAY stage: It should go into RELEASE and fade out from the current level. Try setting some different initial &lt;code&gt;stageValue&lt;/code&gt;s inside &lt;em&gt;EnvelopeGenerator.h&lt;/em&gt; to get different timbres.&lt;br&gt;Now if there was a way to change these values in realtime with some nice knobs, something like this:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/blog/articles/audio-plugins-012-envelopes-gui/gui.png&quot;&gt;&lt;img src=&quot;/blog/articles/audio-plugins-012-envelopes-gui/gui.png&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Let’s &lt;a href=&quot;http://www.martin-finke.de/articles/audio-plugins-012-envelopes-gui/&quot;&gt;make it happen&lt;/a&gt;!&lt;/p&gt;
&lt;p&gt;The source files for this part can be downloaded &lt;a href=&quot;/blog/articles/audio-plugins-011-envelopes/source.zip&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Making Audio Plugins Part 10: Virtual Keyboard</title>
      <link>http://www.martin-finke.de/blog/articles/audio-plugins-010-virtual-keyboard/</link>
      <pubDate>Wed, 02 Oct 2013 09:23:00 +0200</pubDate>
      <guid isPermaLink="true">http://www.martin-finke.de/blog/articles/audio-plugins-010-virtual-keyboard/</guid>
      <author></author>
      <description>&lt;p&gt;REAPER’s virtual keyboard is a little laborious to set up, and your customers may not always have a host with such functionality. Let’s add a little on-screen keyboard to our plugin’s GUI. &lt;span class=&quot;more&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;the-gui-element&quot;&gt;The GUI Element&lt;/h2&gt;
&lt;p&gt;In WDL-OL, GUI elements are called &lt;em&gt;controls&lt;/em&gt;. WDL-OL comes with an &lt;code&gt;IKeyboardControl&lt;/code&gt; which has all the functionality we need. It uses a background graphic and two sprites: One is a pressed black key, the other contains several pressed white keys. The reason for this is that all black keys have the same shape, but the white keys have different shapes. Initially, only the background will be visible. When a key is played, the &lt;em&gt;pressed&lt;/em&gt; key graphic will be overlaid on top at the appropriate position.&lt;br&gt;If you are interested in creating a beautiful piano graphic yourself, check out &lt;a href=&quot;http://naldzgraphics.net/tutorials/piano-app-ui-in-photoshop/&quot;&gt;this tutorial&lt;/a&gt;. Anyway, here are the three files that come with WDL-OL:&lt;/p&gt;
&lt;p&gt;&lt;div style=&quot;text-align: center;&quot;&gt;Background:&lt;/div&gt;
&lt;a href=&quot;/blog/articles/audio-plugins-010-virtual-keyboard/bg.png&quot;&gt;&lt;img src=&quot;/blog/articles/audio-plugins-010-virtual-keyboard/bg.png&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;div style=&quot;text-align: center;&quot;&gt;Pressed black key:&lt;/div&gt;
&lt;a href=&quot;/blog/articles/audio-plugins-010-virtual-keyboard/blackkey.png&quot;&gt;&lt;img src=&quot;/blog/articles/audio-plugins-010-virtual-keyboard/blackkey.png&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;div style=&quot;text-align: center;&quot;&gt;Pressed white keys:&lt;/div&gt;
&lt;a href=&quot;/blog/articles/audio-plugins-010-virtual-keyboard/whitekey.png&quot;&gt;&lt;img src=&quot;/blog/articles/audio-plugins-010-virtual-keyboard/whitekey.png&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Download all three, put them in your project’s &lt;em&gt;/resources/img/&lt;/em&gt; folder. Then drag them into Xcode to add them to the project. As usual with graphics, we’ll first add the filename to &lt;em&gt;resource.h&lt;/em&gt;. While you’re there, remove the &lt;em&gt;knob.png&lt;/em&gt; and &lt;em&gt;background.png&lt;/em&gt; references and remove the two files from your project.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Unique IDs for each image resource.&lt;/span&gt;
&lt;span class=&quot;preprocessor&quot;&gt;#define BG_ID         101&lt;/span&gt;
&lt;span class=&quot;preprocessor&quot;&gt;#define WHITE_KEY_ID  102&lt;/span&gt;
&lt;span class=&quot;preprocessor&quot;&gt;#define BLACK_KEY_ID  103&lt;/span&gt;

&lt;span class=&quot;comment&quot;&gt;// Image resource locations for this plug.&lt;/span&gt;
&lt;span class=&quot;preprocessor&quot;&gt;#define BG_FN         &quot;resources/img/bg.png&quot;&lt;/span&gt;
&lt;span class=&quot;preprocessor&quot;&gt;#define WHITE_KEY_FN  &quot;resources/img/whitekey.png&quot;&lt;/span&gt;
&lt;span class=&quot;preprocessor&quot;&gt;#define BLACK_KEY_FN  &quot;resources/img/blackkey.png&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Also change the GUI size:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// GUI default dimensions&lt;/span&gt;
&lt;span class=&quot;preprocessor&quot;&gt;#define GUI_WIDTH 434&lt;/span&gt;
&lt;span class=&quot;preprocessor&quot;&gt;#define GUI_HEIGHT 66&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To have the png files included in windows builds, edit &lt;em&gt;Synthesis.rc&lt;/em&gt; and modify the beginning to this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#include &quot;resource.h&quot;&lt;/span&gt;

BG_ID       PNG BG_FN
WHITE_KEY_ID       PNG WHITE_KEY_FN
BLACK_KEY_ID       PNG BLACK_KEY_FN
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now add some public members to the &lt;code&gt;Synthesis&lt;/code&gt; class (in &lt;em&gt;Synthesis.h&lt;/em&gt;):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:
    &lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;

    &lt;span class=&quot;comment&quot;&gt;// Needed for the GUI keyboard:&lt;/span&gt;
    &lt;span class=&quot;comment&quot;&gt;// Should return non-zero if one or more keys are playing.&lt;/span&gt;
    &lt;span class=&quot;keyword&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; GetNumKeys() &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; { &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; mMIDIReceiver.getNumKeys(); };
    &lt;span class=&quot;comment&quot;&gt;// Should return true if the specified key is playing.&lt;/span&gt;
    &lt;span class=&quot;keyword&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt; GetKeyStatus(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; key) &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; { &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; mMIDIReceiver.getKeyStatus(key); };
    &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; virtualKeyboardMinimumNoteNumber = &lt;span class=&quot;number&quot;&gt;48&lt;/span&gt;;
    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; lastVirtualKeyboardNoteNumber;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Initialize &lt;code&gt;lastVirtualKeyboardNoteNumber&lt;/code&gt; in the initializer list (in &lt;em&gt;Synthesis.cpp&lt;/em&gt;):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;Synthesis::Synthesis(IPlugInstanceInfo instanceInfo)
    :   IPLUG_CTOR(kNumParams, kNumPrograms, instanceInfo),
    lastVirtualKeyboardNoteNumber(virtualKeyboardMinimumNoteNumber - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) {
    &lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When MIDI notes are played from the host, they should be visible as pressed keys on our virtual keyboard. The virtual keyboard will call &lt;code&gt;getNumKeys&lt;/code&gt; and &lt;code&gt;getKeyStatus&lt;/code&gt; to find out which keys are currently being pressed. We have already implemented these functions on the &lt;code&gt;MIDIReceiver&lt;/code&gt;, so we’re just passing it on.&lt;br&gt;The &lt;code&gt;private&lt;/code&gt; section needs two additions:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;IControl* mVirtualKeyboard;
&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; processVirtualKeyboard();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;IControl&lt;/code&gt; class is the base class of all the GUI controls. We can’t declare an instance of &lt;code&gt;IKeyboardControl&lt;/code&gt; here because it isn’t known in header files. For that reason, we have to use a pointer. &lt;em&gt;IKeyboardControl.h&lt;/em&gt; has some comments saying that you &lt;em&gt;“should include this header file after your plug-in class has already been declared, so it is propbably best to include it in your plug-in’s main .cpp file”&lt;/em&gt;.&lt;br&gt;To make this a little more clear, let’s go into &lt;em&gt;Synthesis.cpp&lt;/em&gt;. Add &lt;code&gt;#include &amp;quot;IKeyboardControl.h&amp;quot;&lt;/code&gt; right before you &lt;code&gt;#include resource.h&lt;/code&gt;. Now modify the constructor as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;Synthesis::Synthesis(IPlugInstanceInfo instanceInfo)
    :   IPLUG_CTOR(kNumParams, kNumPrograms, instanceInfo),
    lastVirtualKeyboardNoteNumber(virtualKeyboardMinimumNoteNumber - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) {
    TRACE;

    IGraphics* pGraphics = MakeGraphics(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, kWidth, kHeight);
    pGraphics-&amp;gt;AttachBackground(BG_ID, BG_FN);

    IBitmap whiteKeyImage = pGraphics-&amp;gt;LoadIBitmap(WHITE_KEY_ID, WHITE_KEY_FN, &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;);
    IBitmap blackKeyImage = pGraphics-&amp;gt;LoadIBitmap(BLACK_KEY_ID, BLACK_KEY_FN);

    &lt;span class=&quot;comment&quot;&gt;//                            C#     D#          F#      G#      A#&lt;/span&gt;
    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; keyCoordinates[&lt;span class=&quot;number&quot;&gt;12&lt;/span&gt;] = { &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;12&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;24&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;36&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;43&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;48&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;56&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;60&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;69&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;72&lt;/span&gt; };
    mVirtualKeyboard = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; IKeyboardControl(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, kKeybX, kKeybY, virtualKeyboardMinimumNoteNumber, &lt;span class=&quot;comment&quot;&gt;/* octaves: */&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;, &amp;amp;whiteKeyImage, &amp;amp;blackKeyImage, keyCoordinates);

    pGraphics-&amp;gt;AttachControl(mVirtualKeyboard);

    AttachGraphics(pGraphics);

    CreatePresets();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The interesting part begins after we have attached the background graphic. First we load the pressed black/white keys as &lt;code&gt;IBitmap&lt;/code&gt;s. The second argument (&lt;code&gt;6&lt;/code&gt;) to &lt;code&gt;LoadIBitmap&lt;/code&gt; tells the graphics system that &lt;em&gt;whitekeys.png&lt;/em&gt; contains six frames:
&lt;a name=&quot;virtual_keyboard_white_key_frames&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;&lt;q&gt;By default pRegularKeys should contain 6 bitmaps (C/F, D, E/B, G, A, high
C), while pSharpKey should only contain 1 bitmap (for all flat/sharp keys).&lt;/q&gt;&lt;footer&gt;IKeyboardControl.h&lt;/footer&gt;&lt;/blockquote&gt;

&lt;p&gt;The &lt;code&gt;keyCoordinates&lt;/code&gt; array tells the system how far each key is offset from the left. Note that you only have to do this for one octave; &lt;code&gt;IKeyboardControl&lt;/code&gt; will infer the coordinates for all other octaves.&lt;br&gt;On the next line, we assign a &lt;code&gt;new IKeyboardControl&lt;/code&gt; to &lt;code&gt;mVirtualKeyboard&lt;/code&gt;. We pass a lot of information:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A pointer to our plugin instance. This is an example of the &lt;a href=&quot;http://en.wikipedia.org/wiki/Delegation_pattern&quot;&gt;delegate pattern&lt;/a&gt;: The virtual keyboard will call &lt;code&gt;GetNumKeys&lt;/code&gt; and &lt;code&gt;GetKeyStatus&lt;/code&gt; on &lt;code&gt;this&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;The keyboard’s X and Y coordinates on the GUI.&lt;/li&gt;
&lt;li&gt;The lowest note number. When you click the leftmost key, this note will be played.&lt;/li&gt;
&lt;li&gt;The number of octaves&lt;/li&gt;
&lt;li&gt;The addresses of our two &lt;em&gt;pressed key&lt;/em&gt; images&lt;/li&gt;
&lt;li&gt;The X coordinate of each key in one octave&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Interestingly, the virtual keyboard knows nothing about &lt;em&gt;bg.png&lt;/em&gt;. It doesn’t need it! This is good because the keyboard may be part of one big background bitmap and it would be annoying to cut out the keyboard part just to pass it to the &lt;code&gt;IKeyboardControl&lt;/code&gt; constructor. It just acts when keys are pressed.&lt;/p&gt;
&lt;p&gt;If you have some C++ experience, writing &lt;code&gt;new&lt;/code&gt; in the constructor may (and should) urge you to put &lt;code&gt;delete mVirtualKeyboard&lt;/code&gt; in the destructor. If you do that and &lt;em&gt;unload&lt;/em&gt; your plugin (i.e. remove it from a track), you’ll get a runtime exception. The reason is that when you call:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;pGraphics-&amp;gt;AttachControl(mVirtualKeyboard);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You’re passing ownership to the graphics system. This means that the memory management is no longer your responsibility, and using &lt;code&gt;delete&lt;/code&gt; will try to deallocate memory that has already been deallocated.&lt;br&gt;Now empty the &lt;code&gt;CreatePresets&lt;/code&gt; function:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; Synthesis::CreatePresets() {
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And add &lt;code&gt;kKeybX&lt;/code&gt; and &lt;code&gt;kKeybY&lt;/code&gt; to &lt;code&gt;ELayout&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;enum&lt;/span&gt; ELayout
{
    kWidth = GUI_WIDTH,
    kHeight = GUI_HEIGHT,
    kKeybX = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,
    kKeybY = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For performance reasons, the &lt;code&gt;IKeyboardControl&lt;/code&gt; doesn’t redraw itself just by itself. A common pattern in graphics programming is to mark a GUI component as &lt;em&gt;dirty&lt;/em&gt;, which means that it will be redrawn on the next paint cycle. If you look in &lt;em&gt;IKeyboardControl.h&lt;/em&gt;, particularly &lt;code&gt;OnMouseDown&lt;/code&gt; and &lt;code&gt;OnMouseUp&lt;/code&gt;, you’ll see that &lt;code&gt;mKey&lt;/code&gt; is set to some value and &lt;code&gt;SetDirty&lt;/code&gt; is called (as opposed to &lt;code&gt;Draw&lt;/code&gt;). &lt;code&gt;SetDirty&lt;/code&gt; is an &lt;code&gt;IControl&lt;/code&gt; member function (found in &lt;em&gt;IControl.cpp&lt;/em&gt;) that sets the control’s &lt;code&gt;mDirty&lt;/code&gt; member to &lt;code&gt;true&lt;/code&gt;. On every paint cycle, the graphics system repaints all controls whose &lt;code&gt;mDirty&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;. I’m going into such detail here because this is an important aspect of how the graphics system works.&lt;/p&gt;
&lt;h2 id=&quot;reacting-to-external-midi&quot;&gt;Reacting to External MIDI&lt;/h2&gt;
&lt;p&gt;Until now, the keyboard marks itself dirty only when it’s clicked. It gets the status of pressed keys from the &lt;code&gt;mMIDIReceiver&lt;/code&gt;, but it has to be informed when external MIDI is received. &lt;code&gt;mVirtualKeyboard&lt;/code&gt; and &lt;code&gt;mMIDIReceiver&lt;/code&gt; know nothing about each other, so we’ll modify &lt;code&gt;ProcessMidiMsg&lt;/code&gt; (in &lt;em&gt;Synthesis.cpp&lt;/em&gt;):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; Synthesis::ProcessMidiMsg(IMidiMsg* pMsg) {
    mMIDIReceiver.onMessageReceived(pMsg);
    mVirtualKeyboard-&amp;gt;SetDirty();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;First, &lt;code&gt;mMIDIReceiver&lt;/code&gt; can update its &lt;code&gt;mLast...&lt;/code&gt; members according to the received MIDI data. Then, &lt;code&gt;mVirtualKeyboard&lt;/code&gt; is marked as dirty. So on the next paint cycle, the renderer will call &lt;code&gt;Draw&lt;/code&gt; on &lt;code&gt;mVirtualKeyboard&lt;/code&gt;, which will call &lt;code&gt;GetNumKeys&lt;/code&gt; and &lt;code&gt;GetKeyStatus&lt;/code&gt;. This may sound a little indirect at first, but it’s a clean design that keeps components separate and avoids redundant work.&lt;br&gt;Our virtual keyboard now reacts to external MIDI input and shows the appropriate keys as being pressed.&lt;/p&gt;
&lt;h2 id=&quot;reacting-to-virtual-key-presses&quot;&gt;Reacting to Virtual Key Presses&lt;/h2&gt;
&lt;p&gt;The last part that’s missing is the opposite direction: Reacting to clicks on the virtual keyboard, generating MIDI messages and passing them to &lt;code&gt;mMIDIReceiver&lt;/code&gt;.&lt;br&gt;Add the following call to &lt;code&gt;ProcessDoubleReplacing&lt;/code&gt;, right before the &lt;code&gt;for&lt;/code&gt; loop:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;processVirtualKeyboard();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And implement the function:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; Synthesis::processVirtualKeyboard() {
    IKeyboardControl* virtualKeyboard = (IKeyboardControl*) mVirtualKeyboard;
    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; virtualKeyboardNoteNumber = virtualKeyboard-&amp;gt;GetKey() + virtualKeyboardMinimumNoteNumber;

    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(lastVirtualKeyboardNoteNumber &amp;gt;= virtualKeyboardMinimumNoteNumber &amp;amp;&amp;amp; virtualKeyboardNoteNumber != lastVirtualKeyboardNoteNumber) {
        &lt;span class=&quot;comment&quot;&gt;// The note number has changed from a valid key to something else (valid key or nothing). Release the valid key:&lt;/span&gt;
        IMidiMsg midiMessage;
        midiMessage.MakeNoteOffMsg(lastVirtualKeyboardNoteNumber, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);
        mMIDIReceiver.onMessageReceived(&amp;amp;midiMessage);
    }

    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (virtualKeyboardNoteNumber &amp;gt;= virtualKeyboardMinimumNoteNumber &amp;amp;&amp;amp; virtualKeyboardNoteNumber != lastVirtualKeyboardNoteNumber) {
        &lt;span class=&quot;comment&quot;&gt;// A valid key is pressed that wasn't pressed the previous call. Send a &quot;note on&quot; message to the MIDI receiver:&lt;/span&gt;
        IMidiMsg midiMessage;
        midiMessage.MakeNoteOnMsg(virtualKeyboardNoteNumber, virtualKeyboard-&amp;gt;GetVelocity(), &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);
        mMIDIReceiver.onMessageReceived(&amp;amp;midiMessage);
    }

    lastVirtualKeyboardNoteNumber = virtualKeyboardNoteNumber;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After a cast, we get the pressed key’s MIDI note number using &lt;code&gt;GetKey&lt;/code&gt;. &lt;code&gt;IKeyboardControl&lt;/code&gt; doesn’t support multi-touch, so only one key can be clicked at once. The first &lt;code&gt;if&lt;/code&gt; statement releases a key that is no longer clicked (if any). Since this function is called every &lt;code&gt;mBlockSize&lt;/code&gt; samples, the second &lt;code&gt;if&lt;/code&gt; ensures that clicking a key will only generate one &lt;em&gt;note on&lt;/em&gt; message for a given click, and not one every &lt;code&gt;mBlockSize&lt;/code&gt; samples. We’re remembering the &lt;code&gt;lastVirtualKeyboardNoteNumber&lt;/code&gt; to avoid this kind of “re-triggering” on every call.&lt;/p&gt;
&lt;h2 id=&quot;showtime-&quot;&gt;Showtime!&lt;/h2&gt;
&lt;p&gt;We’re ready to run our plugin again! You should be able to play notes using the plugin’s virtual keyboard. Using REAPER’s virtual keyboard (or any other MIDI input) should make the plugin’s GUI show the appropriate key&lt;em&gt;s&lt;/em&gt; (plural) as being pressed. You will only hear a tone for the last-pressed key, though. We will address polyphony in a later post.&lt;/p&gt;
&lt;p&gt;We can play our favourite Beethoven with the sound of classic analogue waveforms! But the sound is a little “static” and you can hear click sounds when you press and release a key (especially using the sine waveform). So the next thing to do is to &lt;a href=&quot;http://www.martin-finke.de/articles/audio-plugins-011-envelopes/&quot;&gt;add envelopes&lt;/a&gt;. You can download the current source files &lt;a href=&quot;/blog/articles/audio-plugins-010-virtual-keyboard/source.zip&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Making Audio Plugins Part 9: Receiving MIDI</title>
      <link>http://www.martin-finke.de/blog/articles/audio-plugins-009-receiving-midi/</link>
      <pubDate>Sat, 28 Sep 2013 10:10:00 +0200</pubDate>
      <guid isPermaLink="true">http://www.martin-finke.de/blog/articles/audio-plugins-009-receiving-midi/</guid>
      <author></author>
      <description>&lt;p&gt;So far we’ve been generating a steady waveform that keeps playing. Let’s see how we can react to MIDI and start/stop the waveform at the right pitch according to the notes we’re receiving. &lt;span class=&quot;more&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;midi-handling-basics&quot;&gt;MIDI Handling Basics&lt;/h2&gt;
&lt;p&gt;When our plugin is loaded into a host, it receives all MIDI data on the track it is on. When a note is played or released, the plugin’s &lt;code&gt;ProcessMidiMsg&lt;/code&gt; member function is called. It doesn’t matter if the note was played on a MIDI keyboard or it came from a piano roll. And it’s not just for key presses, but also for things like Pitch Bend or &lt;a href=&quot;http://en.wikipedia.org/wiki/General_MIDI#Controller_events&quot;&gt;Control Changes (CC)&lt;/a&gt; (e.g. when there’s automation for a plugin parameter). The &lt;code&gt;ProcessMidiMsg&lt;/code&gt; function is passed an &lt;code&gt;IMidiMsg&lt;/code&gt;, which describes the MIDI event in a normalized, format-independent way. It has member functions like &lt;code&gt;NoteNumber&lt;/code&gt; and &lt;code&gt;Velocity&lt;/code&gt;. We’re going to use these to find out at what pitch and volume our oscillator will play.&lt;/p&gt;
&lt;p&gt;Whenever a MIDI message is received, the system is already playing back an audio buffer that was generated previously. There’s no way to &lt;em&gt;push&lt;/em&gt; some audio to the system just at the moment when MIDI data arrives. We have to remember what happened until &lt;code&gt;ProcessDoubleReplacing&lt;/code&gt; is called again. We also need the time when each message arrived, so that we can keep the timing intact when we’re generating the next audio buffer.&lt;/p&gt;
&lt;p&gt;The &lt;a href=&quot;https://github.com/olilarkin/wdl-ol/blob/master/WDL/IPlug/IMidiQueue.h&quot;&gt;&lt;code&gt;IMidiQueue&lt;/code&gt;&lt;/a&gt; is the right tool for this.&lt;/p&gt;
&lt;h2 id=&quot;creating-a-midi-receiver&quot;&gt;Creating a MIDI Receiver&lt;/h2&gt;
&lt;p&gt;We’re going to reuse our &lt;em&gt;Synthesis&lt;/em&gt; project. If you’re using version control, this may be a good time to commit. Create a new class &lt;em&gt;MIDIReceiver&lt;/em&gt; and make sure the &lt;em&gt;.cpp&lt;/em&gt; file is compiled with each target. Put the interface between &lt;code&gt;#define&lt;/code&gt; and &lt;code&gt;#endif&lt;/code&gt; in &lt;em&gt;MIDIReceiver.h&lt;/em&gt;:
&lt;a name=&quot;midi_receiver_class&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#pragma clang diagnostic push&lt;/span&gt;
&lt;span class=&quot;preprocessor&quot;&gt;#pragma clang diagnostic ignored &quot;-Wextra-tokens&quot;&lt;/span&gt;
&lt;span class=&quot;preprocessor&quot;&gt;#include &quot;IPlug_include_in_plug_hdr.h&quot;&lt;/span&gt;
&lt;span class=&quot;preprocessor&quot;&gt;#pragma clang diagnostic pop&lt;/span&gt;

&lt;span class=&quot;preprocessor&quot;&gt;#include &quot;IMidiQueue.h&quot;&lt;/span&gt;

&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; MIDIReceiver {
&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt;:
    IMidiQueue mMidiQueue;
    &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; keyCount = &lt;span class=&quot;number&quot;&gt;128&lt;/span&gt;;
    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; mNumKeys; &lt;span class=&quot;comment&quot;&gt;// how many keys are being played at the moment (via midi)&lt;/span&gt;
    &lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt; mKeyStatus[keyCount]; &lt;span class=&quot;comment&quot;&gt;// array of on/off for each key (index is note number)&lt;/span&gt;
    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; mLastNoteNumber;
    &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; mLastFrequency;
    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; mLastVelocity;
    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; mOffset;
    &lt;span class=&quot;keyword&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; noteNumberToFrequency(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; noteNumber) { &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;440.0&lt;/span&gt; * &lt;span class=&quot;built_in&quot;&gt;pow&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;2.0&lt;/span&gt;, (noteNumber - &lt;span class=&quot;number&quot;&gt;69.0&lt;/span&gt;) / &lt;span class=&quot;number&quot;&gt;12.0&lt;/span&gt;); }

&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:
    MIDIReceiver() :
    mNumKeys(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;),
    mLastNoteNumber(-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;),
    mLastFrequency(-&lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;),
    mLastVelocity(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;),
    mOffset(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) {
        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; keyCount; i++) {
            mKeyStatus[i] = &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;;
        }
    };

    &lt;span class=&quot;comment&quot;&gt;// Returns true if the key with a given index is currently pressed&lt;/span&gt;
    &lt;span class=&quot;keyword&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt; getKeyStatus(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; keyIndex) &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; { &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; mKeyStatus[keyIndex]; }
    &lt;span class=&quot;comment&quot;&gt;// Returns the number of keys currently pressed&lt;/span&gt;
    &lt;span class=&quot;keyword&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; getNumKeys() &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; { &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; mNumKeys; }
    &lt;span class=&quot;comment&quot;&gt;// Returns the last pressed note number&lt;/span&gt;
    &lt;span class=&quot;keyword&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; getLastNoteNumber() &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; { &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; mLastNoteNumber; }
    &lt;span class=&quot;keyword&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; getLastFrequency() &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; { &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; mLastFrequency; }
    &lt;span class=&quot;keyword&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; getLastVelocity() &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; { &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; mLastVelocity; }
    &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; advance();
    &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; onMessageReceived(IMidiMsg* midiMessage);
    &lt;span class=&quot;keyword&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; Flush(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; nFrames) { mMidiQueue.Flush(nFrames); mOffset = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; }
    &lt;span class=&quot;keyword&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; Resize(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; blockSize) { mMidiQueue.Resize(blockSize); }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We have to include &lt;em&gt;IPlug_include_in_plug_hdr.h&lt;/em&gt; here because otherwise &lt;em&gt;IMidiQueue.h&lt;/em&gt; will generate errors.&lt;br&gt;As you can see, we’re keeping a private &lt;code&gt;IMidiQueue&lt;/code&gt; member to store MIDI messages. We’re also storing some information about which notes are being played and how many in total. The three &lt;code&gt;mLast...&lt;/code&gt; members are needed because our plugin will be monophonic: A note played later will mute any previous one (“&lt;a href=&quot;http://www.soundonsound.com/sos/oct00/articles/synthsec.htm&quot;&gt;last note priority&lt;/a&gt;“). The function &lt;code&gt;noteNumberToFrequency&lt;/code&gt; converts from a MIDI note number to a frequency in Hz. We need it because our &lt;code&gt;Oscillator&lt;/code&gt; class deals with frequencies, not note numbers.&lt;br&gt;The &lt;code&gt;public&lt;/code&gt; section defines some &lt;code&gt;inline&lt;/code&gt; getters and passes &lt;code&gt;Flush&lt;/code&gt; and &lt;code&gt;Resize&lt;/code&gt; through to &lt;code&gt;mMidiQueue&lt;/code&gt;. In &lt;code&gt;Flush&lt;/code&gt;, we’re also setting &lt;code&gt;mOffset&lt;/code&gt; to zero: Calling &lt;code&gt;mMidiQueue.Flush(nFrames)&lt;/code&gt; means that we discard &lt;code&gt;nFrames&lt;/code&gt; from the queue’s front. We have already processed that length in the last call to the &lt;code&gt;advance&lt;/code&gt; function. Resetting &lt;code&gt;mOffset&lt;/code&gt; ensures that inside the next &lt;code&gt;advance&lt;/code&gt;, we’re starting from the queue’s front again. (Thanks to &lt;em&gt;Tale&lt;/em&gt; for help with this.)&lt;br&gt;The &lt;code&gt;const&lt;/code&gt; behind the parentheses means that the function &lt;a href=&quot;http://stackoverflow.com/a/5598730/966567&quot;&gt;doesn’t modify non-mutable members of its class&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Let’s add the implementation for &lt;code&gt;onMessageReceived&lt;/code&gt; to &lt;em&gt;MIDIReceiver.cpp&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; MIDIReceiver::onMessageReceived(IMidiMsg* midiMessage) {
    IMidiMsg::EStatusMsg status = midiMessage-&amp;gt;StatusMsg();
    &lt;span class=&quot;comment&quot;&gt;// We're only interested in Note On/Off messages (not CC, pitch, etc.)&lt;/span&gt;
    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(status == IMidiMsg::kNoteOn || status == IMidiMsg::kNoteOff) {
        mMidiQueue.Add(midiMessage);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This function will be called whenever the plugin receives a MIDI message. We select only &lt;em&gt;note on/off&lt;/em&gt; messages and &lt;code&gt;Add&lt;/code&gt; them to our &lt;code&gt;mMidiQueue&lt;/code&gt;.&lt;br&gt;The interesting function is &lt;code&gt;advance&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; MIDIReceiver::advance() {
    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (!mMidiQueue.Empty()) {
        IMidiMsg* midiMessage = mMidiQueue.Peek();
        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (midiMessage-&amp;gt;mOffset &amp;gt; mOffset) &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;

        IMidiMsg::EStatusMsg status = midiMessage-&amp;gt;StatusMsg();
        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; noteNumber = midiMessage-&amp;gt;NoteNumber();
        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; velocity = midiMessage-&amp;gt;Velocity();
        &lt;span class=&quot;comment&quot;&gt;// There are only note on/off messages in the queue, see ::OnMessageReceived&lt;/span&gt;
        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (status == IMidiMsg::kNoteOn &amp;amp;&amp;amp; velocity) {
            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(mKeyStatus[noteNumber] == &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;) {
                mKeyStatus[noteNumber] = &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;;
                mNumKeys += &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;
            }
            &lt;span class=&quot;comment&quot;&gt;// A key pressed later overrides any previously pressed key:&lt;/span&gt;
            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (noteNumber != mLastNoteNumber) {
                mLastNoteNumber = noteNumber;
                mLastFrequency = noteNumberToFrequency(mLastNoteNumber);
                mLastVelocity = velocity;
            }
        } &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; {
            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(mKeyStatus[noteNumber] == &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;) {
                mKeyStatus[noteNumber] = &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;;
                mNumKeys -= &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;
            }
            &lt;span class=&quot;comment&quot;&gt;// If the last note was released, nothing should play:&lt;/span&gt;
            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (noteNumber == mLastNoteNumber) {
                mLastNoteNumber = -&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;
                mLastFrequency = -&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;
                mLastVelocity = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;
            }
        }
        mMidiQueue.Remove();
    }
    mOffset++;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is called &lt;em&gt;on every sample&lt;/em&gt; while we’re generating an audio buffer. As long as there are messages in the queue, we’re processing and removing them from the front (using &lt;code&gt;Peek&lt;/code&gt; and &lt;code&gt;Remove&lt;/code&gt;). But we only do this for MIDI messages whose &lt;code&gt;mOffset&lt;/code&gt; isn’t greater than the current offset into the buffer. This means that we process every message at the right sample, keeping the relative timing intact.&lt;br&gt;After reading &lt;code&gt;noteNumber&lt;/code&gt; and &lt;code&gt;velocity&lt;/code&gt;, the &lt;code&gt;if&lt;/code&gt; statement distinguishes &lt;em&gt;note on&lt;/em&gt; and &lt;em&gt;off&lt;/em&gt; messages (&lt;em&gt;no velocity&lt;/em&gt; is interpreted as &lt;em&gt;note off&lt;/em&gt;). In both cases, we’re keeping track of which notes are being played, as well as how many of them. We also update the &lt;code&gt;mLast...&lt;/code&gt; members so the already mentioned &lt;em&gt;last note priority&lt;/em&gt; happens. This is the place where we know the frequency has to change, so we’re updating it here. Finally, the &lt;code&gt;mOffset&lt;/code&gt; is incremented so that the receiver knows how far into the buffer it currently is. An alternative would be to pass the offset in as an argument.
So we now have a class that can receive all incoming MIDI note on/off messages. It always keeps track of which notes are being played and what the last played note (and frequency) was. Let’s make use of it!&lt;/p&gt;
&lt;h2 id=&quot;using-the-midi-receiver&quot;&gt;Using the MIDI Receiver&lt;/h2&gt;
&lt;p&gt;First, go into &lt;em&gt;resource.h&lt;/em&gt; and make the following changes:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// #define PLUG_CHANNEL_IO &quot;1-1 2-2&quot;&lt;/span&gt;
&lt;span class=&quot;preprocessor&quot;&gt;#if (defined(AAX_API) || defined(RTAS_API)) &lt;/span&gt;
&lt;span class=&quot;preprocessor&quot;&gt;#define PLUG_CHANNEL_IO &quot;1-1 2-2&quot;&lt;/span&gt;
&lt;span class=&quot;preprocessor&quot;&gt;#else&lt;/span&gt;
&lt;span class=&quot;comment&quot;&gt;// no audio input. mono or stereo output&lt;/span&gt;
&lt;span class=&quot;preprocessor&quot;&gt;#define PLUG_CHANNEL_IO &quot;0-1 0-2&quot;&lt;/span&gt;
&lt;span class=&quot;preprocessor&quot;&gt;#endif&lt;/span&gt;

&lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;
&lt;span class=&quot;preprocessor&quot;&gt;#define PLUG_IS_INST 1&lt;/span&gt;

&lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;
&lt;span class=&quot;preprocessor&quot;&gt;#define EFFECT_TYPE_VST3 &quot;Instrument|Synth&quot;&lt;/span&gt;

&lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;
&lt;span class=&quot;preprocessor&quot;&gt;#define PLUG_DOES_MIDI 1&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This tells the host that our plugin is an instrument that does MIDI. The &lt;code&gt;0-1 0-2&lt;/code&gt; means that there’s either &lt;em&gt;no input and one output (mono)&lt;/em&gt; (&lt;code&gt;0-1&lt;/code&gt;) or &lt;em&gt;no input and two outputs (stereo)&lt;/em&gt; (&lt;code&gt;0-2&lt;/code&gt;).&lt;br&gt;Next, go into &lt;em&gt;Synthesis.h&lt;/em&gt; and &lt;code&gt;#include &amp;quot;MIDIReceiver.h&amp;quot;&lt;/code&gt; below &lt;em&gt;Oscillator.h&lt;/em&gt;. In the &lt;code&gt;public&lt;/code&gt; section, add the following member function declaration:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// to receive MIDI messages:&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; ProcessMidiMsg(IMidiMsg* pMsg);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Add a new &lt;code&gt;MIDIReceiver&lt;/code&gt; instance to the &lt;code&gt;private&lt;/code&gt; section:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt;:
    &lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;
    MIDIReceiver mMIDIReceiver;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Go into &lt;em&gt;Synthesis.cpp&lt;/em&gt; and add the (quite simple) implementation:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; Synthesis::ProcessMidiMsg(IMidiMsg* pMsg) {
    mMIDIReceiver.onMessageReceived(pMsg);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This function will be called whenever the application receives a MIDI message. We’re passing the messages through to our MIDI receiver.&lt;br&gt;Let’s clean up a bit. Change the two &lt;code&gt;enum&lt;/code&gt;s at the top:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;enum&lt;/span&gt; EParams
{
    kNumParams
};

&lt;span class=&quot;keyword&quot;&gt;enum&lt;/span&gt; ELayout
{
    kWidth = GUI_WIDTH,
    kHeight = GUI_HEIGHT
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Create just one default preset:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; Synthesis::CreatePresets() {
    MakeDefaultPreset((&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *) &lt;span class=&quot;string&quot;&gt;&quot;-&quot;&lt;/span&gt;, kNumPrograms);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Don’t do anything when a parameter is changed:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; Synthesis::OnParamChange(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; paramIdx)
{
    IMutexLock lock(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We don’t need a knob in our user interface. Let’s change the constructor to something really minimal:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;Synthesis::Synthesis(IPlugInstanceInfo instanceInfo)
    :   IPLUG_CTOR(kNumParams, kNumPrograms, instanceInfo) {
    TRACE;

    IGraphics* pGraphics = MakeGraphics(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, kWidth, kHeight);
    pGraphics-&amp;gt;AttachPanelBackground(&amp;amp;COLOR_RED);
    AttachGraphics(pGraphics);
    CreatePresets();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When some audio preference is changed, we have to update our oscillator with the new sample rate:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; Synthesis::Reset()
{
    TRACE;
    IMutexLock lock(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;);
    mOscillator.setSampleRate(GetSampleRate());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The only thing left is &lt;code&gt;ProcessDoubleReplacing&lt;/code&gt;. Thinking about it, we have to call &lt;code&gt;mMIDIReceiver.advance()&lt;/code&gt; &lt;em&gt;on every sample&lt;/em&gt;. After that, we’ll &lt;code&gt;getLastVelocity&lt;/code&gt; and &lt;code&gt;getLastFrequency&lt;/code&gt; from the MIDI receiver. Then we’ll call &lt;code&gt;mOscillator.setFrequency()&lt;/code&gt; and &lt;code&gt;mOscillator.generate()&lt;/code&gt; to fill the audio buffer with a tone at the right frequency.&lt;br&gt;We have designed &lt;code&gt;generate&lt;/code&gt; to operate on a complete buffer and fill it. The MIDI receiver works on a sample level: MIDI messages can have any offset into a buffer, so &lt;code&gt;mLastFrequency&lt;/code&gt; &lt;em&gt;can change at any sample&lt;/em&gt;. We have to change our &lt;code&gt;Oscillator&lt;/code&gt; class so it can work on a sample level as well.&lt;/p&gt;
&lt;p&gt;First, move the &lt;code&gt;twoPI&lt;/code&gt; out of &lt;code&gt;generate&lt;/code&gt; and into the &lt;code&gt;private&lt;/code&gt; section in &lt;em&gt;Oscillator.h&lt;/em&gt;. Make sure you put it &lt;em&gt;below&lt;/em&gt; the declaration of &lt;code&gt;mPI&lt;/code&gt;, because variables are initialized in the order in which they are declared.
&lt;a name=&quot;adding_isMuted_property&quot;&gt;&lt;/a&gt;
While we’re there, let’s also add a &lt;code&gt;bool&lt;/code&gt; to indicate if the oscillator is currently muted (when no note is playing):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; twoPI;
&lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt; isMuted;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Initialize them by modifying the constructor’s initializer list. It should now look like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;Oscillator() :
    mOscillatorMode(OSCILLATOR_MODE_SINE),
    mPI(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;*&lt;span class=&quot;built_in&quot;&gt;acos&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;0.0&lt;/span&gt;)),
    twoPI(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; * mPI), &lt;span class=&quot;comment&quot;&gt;// This line is new&lt;/span&gt;
    isMuted(&lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;),  &lt;span class=&quot;comment&quot;&gt;// And this line&lt;/span&gt;
    mFrequency(&lt;span class=&quot;number&quot;&gt;440.0&lt;/span&gt;),
    mPhase(&lt;span class=&quot;number&quot;&gt;0.0&lt;/span&gt;),
    mSampleRate(&lt;span class=&quot;number&quot;&gt;44100.0&lt;/span&gt;) { updateIncrement(); };
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Add an &lt;code&gt;inline&lt;/code&gt; setter to the &lt;code&gt;public&lt;/code&gt; section:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; setMuted(&lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt; muted) { isMuted = muted; }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Right below that, add the following declaration:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; nextSample();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We’ll call this function on every sample to get audio data from the oscillator. Put the following implementation in &lt;em&gt;Oscillator.cpp&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; Oscillator::nextSample() {
    &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; value = &lt;span class=&quot;number&quot;&gt;0.0&lt;/span&gt;;
    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(isMuted) &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; value;

    &lt;span class=&quot;keyword&quot;&gt;switch&lt;/span&gt; (mOscillatorMode) {
        &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; OSCILLATOR_MODE_SINE:
            value = &lt;span class=&quot;built_in&quot;&gt;sin&lt;/span&gt;(mPhase);
            &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;
        &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; OSCILLATOR_MODE_SAW:
            value = &lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt; - (&lt;span class=&quot;number&quot;&gt;2.0&lt;/span&gt; * mPhase / twoPI);
            &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;
        &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; OSCILLATOR_MODE_SQUARE:
            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (mPhase &amp;lt;= mPI) {
                value = &lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;;
            } &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; {
                value = -&lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;;
            }
            &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;
        &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; OSCILLATOR_MODE_TRIANGLE:
            value = -&lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt; + (&lt;span class=&quot;number&quot;&gt;2.0&lt;/span&gt; * mPhase / twoPI);
            value = &lt;span class=&quot;number&quot;&gt;2.0&lt;/span&gt; * (&lt;span class=&quot;built_in&quot;&gt;fabs&lt;/span&gt;(value) - &lt;span class=&quot;number&quot;&gt;0.5&lt;/span&gt;);
            &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;
    }
    mPhase += mPhaseIncrement;
    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (mPhase &amp;gt;= twoPI) {
        mPhase -= twoPI;
    }
    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; value;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As you can see, we’re using &lt;code&gt;twoPI&lt;/code&gt; here, and it would be wasteful to keep calculating it every sample. That’s why we turned it into a constant member variable.&lt;br&gt;Whenever the oscillator is muted, we just return zero. The &lt;code&gt;switch&lt;/code&gt; should look very familiar, although we’re not using a &lt;code&gt;for&lt;/code&gt; loop anymore. We’re just generating a single value instead of filling an entire buffer. This structure also allows us to move the phase incrementing part our, avoiding duplication.&lt;/p&gt;
&lt;p&gt;This was a good example of refactoring existing code because it’s no longer flexible enough. Of course, we could have spent an hour or two thinking about what we need from our oscillator before writing the buffer-based &lt;code&gt;generate&lt;/code&gt; function. But actually implementing it took less than an hour. In simple applications like this one, it’s sometimes more efficient to just implement one approach and see how it works in practice. Most of the time (like in this case), you’ll find that the overall idea was right (e.g. how to calculate different waveforms), but maybe you forgot one facet of the problem. If, on the other hand, you’re designing a public API, changing something later may be very inconvenient, so you better think thoroughly in advance. It depends.&lt;/p&gt;
&lt;p&gt;We will call &lt;code&gt;setFrequency&lt;/code&gt; on every sample. This means that &lt;code&gt;updateIncrement&lt;/code&gt; will also be called very often, and it’s not very optimized:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; Oscillator::updateIncrement() {
    mPhaseIncrement = mFrequency * &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; * mPI / mSampleRate;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;2 * mPI * mSampleRate&lt;/code&gt; only changes when the sample rate changes. So you could cache this calculation and only recalculate it inside &lt;code&gt;Oscillator::setSampleRate&lt;/code&gt;. But overzealous optimization like this can make code ugly. In practice, I didn’t notice a performance issue here. After all, we’re only playing one voice at the time, so when we get polyphonic, things will be different and we will definitely improve this.
Now we’re ready to implement &lt;code&gt;ProcessDoubleReplacing&lt;/code&gt; in &lt;em&gt;Synthesis.cpp&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; Synthesis::ProcessDoubleReplacing(
    &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt;** inputs,
    &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt;** outputs,
    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; nFrames)
{
    &lt;span class=&quot;comment&quot;&gt;// Mutex is already locked for us.&lt;/span&gt;

    &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; *leftOutput = outputs[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;];
    &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; *rightOutput = outputs[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;];

    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; nFrames; ++i) {
        mMIDIReceiver.advance();
        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; velocity = mMIDIReceiver.getLastVelocity();
        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (velocity &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) {
            mOscillator.setFrequency(mMIDIReceiver.getLastFrequency());
            mOscillator.setMuted(&lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;);
        } &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; {
            mOscillator.setMuted(&lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;);
        }
        leftOutput[i] = rightOutput[i] = mOscillator.nextSample() * velocity / &lt;span class=&quot;number&quot;&gt;127.0&lt;/span&gt;;
    }

    mMIDIReceiver.Flush(nFrames);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the &lt;code&gt;for&lt;/code&gt; loop, we’re first letting the MIDI receiver update its values (by calling &lt;code&gt;advance&lt;/code&gt;). If there’s a note playing (i.e. &lt;code&gt;velocity &amp;gt; 0&lt;/code&gt;), we update the oscillator’s frequency and unmute it. Otherwise, we mute the oscillator (meaning that &lt;code&gt;nextSample&lt;/code&gt; will return zeros).&lt;br&gt;After that, it’s simply about calling &lt;code&gt;nextSample&lt;/code&gt; to get a value, changing its volume (&lt;code&gt;velocity&lt;/code&gt; is an integer between &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;127&lt;/code&gt;), and assigning the result to both output buffers. Finally we call &lt;code&gt;Flush&lt;/code&gt; to move the MIDI queue’s front.&lt;/p&gt;
&lt;h2 id=&quot;try-it-&quot;&gt;Try it!&lt;/h2&gt;
&lt;p&gt;Run as &lt;em&gt;VST2&lt;/em&gt; or &lt;em&gt;AU&lt;/em&gt;. If the AudioUnit doesn’t appear in your host, you may have to change the &lt;code&gt;PLUG_UNIQUE_ID&lt;/code&gt; in &lt;em&gt;resource.h&lt;/em&gt;. If two plugins have the same ID, your host may ignore all but one of them.&lt;br&gt;You will have to input some MIDI data into your plugin. The easiest way to do that is to use REAPER’s virtual keyboard. Click &lt;em&gt;View&lt;/em&gt; → &lt;em&gt;Virtual MIDI Keyboard&lt;/em&gt; to show it. On the track with your plugin, there’s a round red record button. &lt;em&gt;Right&lt;/em&gt;-click it and configure the track to receive MIDI from the virtual keyboard:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/blog/articles/audio-plugins-009-receiving-midi/midi-input.png&quot;&gt;&lt;img src=&quot;/blog/articles/audio-plugins-009-receiving-midi/midi-input.png&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;In the same menu, make sure &lt;em&gt;Monitor Input&lt;/em&gt; is enabled. Now, &lt;em&gt;with the virtual keyboard’s window focussed&lt;/em&gt;, you can play your plugin using your computer keyboard. Press the QWERTY keys and your should hear sound from your plugin.&lt;br&gt;If you have a MIDI keyboard connected, you can also try the standalone version. Make you you select the right MIDI input in the preferences. If you don’t hear any audio, you may have to delete &lt;em&gt;~/Library/Application Support/Synthesis/settings.ini&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;You can download the current project &lt;a href=&quot;/blog/articles/audio-plugins-009-receiving-midi/source.zip&quot;&gt;here&lt;/a&gt;. &lt;a href=&quot;http://www.martin-finke.de/articles/audio-plugins-010-virtual-keyboard/&quot;&gt;Next time&lt;/a&gt;, we’ll add a nice virtual keyboard to our plugin’s GUI!&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Making Audio Plugins Part 8: Synthesizing Waveforms</title>
      <link>http://www.martin-finke.de/blog/articles/audio-plugins-008-synthesizing-waveforms/</link>
      <pubDate>Sat, 21 Sep 2013 07:54:00 +0200</pubDate>
      <guid isPermaLink="true">http://www.martin-finke.de/blog/articles/audio-plugins-008-synthesizing-waveforms/</guid>
      <author></author>
      <description>&lt;p&gt;After all this GUI stuff it’s time for some audio programming. First we’ll generate the classic &lt;em&gt;Sine&lt;/em&gt;, &lt;em&gt;Saw&lt;/em&gt;, &lt;em&gt;Square&lt;/em&gt; and &lt;em&gt;Triangle&lt;/em&gt; waveforms. &lt;span class=&quot;more&quot;&gt;&lt;/span&gt;&lt;br&gt;Let’s begin by running the &lt;em&gt;duplicate&lt;/em&gt; script:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;./duplicate.py DigitalDistortion/ Synthesis YourName
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Again, you’ll have to go to &lt;em&gt;Product&lt;/em&gt; → &lt;em&gt;Scheme&lt;/em&gt; → &lt;em&gt;Edit Scheme…&lt;/em&gt; and change &lt;em&gt;“Run”&lt;/em&gt; so that it starts &lt;em&gt;REAPER64.app&lt;/em&gt; with your &lt;em&gt;reaper-project.RPP&lt;/em&gt; (as &lt;a href=&quot;http://www.martin-finke.de/articles/audio-plugins-004-vst-and-au/#edit_scheme&quot;&gt;described earlier&lt;/a&gt;). If Reaper complains about the AU not being found, change the names and IDs in &lt;em&gt;resource.h&lt;/em&gt;, or remove the &lt;em&gt;DigitalDistortion.component&lt;/em&gt;.&lt;/p&gt;
&lt;h2 id=&quot;creating-the-oscillator-class&quot;&gt;Creating the Oscillator Class&lt;/h2&gt;
&lt;p&gt;All of this will be about DSP, but we will not just write our code into the &lt;code&gt;ProcessDoubleReplacing&lt;/code&gt; function. Instead, we will create an &lt;code&gt;Oscillator&lt;/code&gt; class. It will be called from &lt;code&gt;ProcessDoubleReplacing&lt;/code&gt; and will fill buffers with &lt;code&gt;double&lt;/code&gt; values for the current waveform. To generate the waveforms, we’ll first take the most intuitive approach. We will then see the disadvantages and find a better-sounding way.&lt;br&gt;Create a new Class by going to &lt;em&gt;File&lt;/em&gt; → &lt;em&gt;New&lt;/em&gt; → &lt;em&gt;File…&lt;/em&gt;:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/blog/articles/audio-plugins-008-synthesizing-waveforms/create-cpp-class.jpg&quot;&gt;&lt;img src=&quot;/blog/articles/audio-plugins-008-synthesizing-waveforms/create-cpp-class.jpg&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Call it &lt;em&gt;Oscillator&lt;/em&gt;.&lt;br&gt;&lt;a name=&quot;compile_sources&quot;&gt;&lt;/a&gt;
Now make sure &lt;em&gt;Oscillator.cpp&lt;/em&gt; gets compiled when we build. Go to your project settings, select a target (e.g. &lt;em&gt;AU&lt;/em&gt;) and click &lt;em&gt;Build Phases&lt;/em&gt;. Click the plus button below &lt;em&gt;Compile Sources&lt;/em&gt; and add the &lt;em&gt;.cpp&lt;/em&gt; file (you’ll have to do this for every target you need):&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/blog/articles/audio-plugins-008-synthesizing-waveforms/compile-sources.png&quot;&gt;&lt;img src=&quot;/blog/articles/audio-plugins-008-synthesizing-waveforms/compile-sources.png&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Let’s write the header first. Put this between the &lt;code&gt;#define&lt;/code&gt; and &lt;code&gt;#endif&lt;/code&gt; in &lt;em&gt;Oscillator.h&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#include &amp;lt;math.h&amp;gt;&lt;/span&gt;

&lt;span class=&quot;keyword&quot;&gt;enum&lt;/span&gt; OscillatorMode {
    OSCILLATOR_MODE_SINE,
    OSCILLATOR_MODE_SAW,
    OSCILLATOR_MODE_SQUARE,
    OSCILLATOR_MODE_TRIANGLE
};

&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; Oscillator {
&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt;:
    OscillatorMode mOscillatorMode;
    &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; mPI;
    &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; mFrequency;
    &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; mPhase;
    &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; mSampleRate;
    &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; mPhaseIncrement;
    &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; updateIncrement();
&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:
    &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; setMode(OscillatorMode mode);
    &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; setFrequency(&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; frequency);
    &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; setSampleRate(&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; sampleRate);
    &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; generate(&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt;* buffer, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; nFrames);
    Oscillator() :
        mOscillatorMode(OSCILLATOR_MODE_SINE),
        mPI(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;*&lt;span class=&quot;built_in&quot;&gt;acos&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;0.0&lt;/span&gt;)),
        mFrequency(&lt;span class=&quot;number&quot;&gt;440.0&lt;/span&gt;),
        mPhase(&lt;span class=&quot;number&quot;&gt;0.0&lt;/span&gt;),
        mSampleRate(&lt;span class=&quot;number&quot;&gt;44100.0&lt;/span&gt;) { updateIncrement(); };
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We are using an &lt;code&gt;enum&lt;/code&gt; to indicate which waveform the oscillator is generating. Here it defaults to a sine wave, but this can be changed using the &lt;code&gt;setMode&lt;/code&gt; member function. Calculating π this way is more portable than using the &lt;code&gt;M_PI&lt;/code&gt; constant.&lt;br&gt;The Oscillator stores the frequency, phase and sample rate. Just to be clear, the phase is the value that will change all the time to indicate &lt;em&gt;where in the waveform cycle the oscillator currently is&lt;/em&gt;. The phase increment is the amount that’s added to the phase every sample.&lt;br&gt;Finally, there’s more setter functions (for frequency and sample rate) and, most importantly, &lt;code&gt;generate&lt;/code&gt;. This is the function that takes a buffer of doubles and fills it with sample values.&lt;/p&gt;
&lt;p&gt;Let’s add the implementation of the setter functions (in &lt;em&gt;Oscillator.cpp&lt;/em&gt;):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; Oscillator::setMode(OscillatorMode mode) {
    mOscillatorMode = mode;
}

&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; Oscillator::setFrequency(&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; frequency) {
    mFrequency = frequency;
    updateIncrement();
}

&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; Oscillator::setSampleRate(&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; sampleRate) {
    mSampleRate = sampleRate;
    updateIncrement();
}

&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; Oscillator::updateIncrement() {
    mPhaseIncrement = mFrequency * &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; * mPI / mSampleRate;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;mPhaseIncrement&lt;/code&gt; depends on both &lt;code&gt;mFrequency&lt;/code&gt; and &lt;code&gt;mSampleRate&lt;/code&gt;, so it has to be updated everytime one of the two is changed. We could calculate it every sample, but of course it’s far more efficient to do it here.&lt;br&gt;Add the implementation for &lt;code&gt;generate&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; Oscillator::generate(&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt;* buffer, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; nFrames) {
    &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; twoPI = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; * mPI;
    &lt;span class=&quot;keyword&quot;&gt;switch&lt;/span&gt; (mOscillatorMode) {
        &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; OSCILLATOR_MODE_SINE:
            &lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;
            &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;
        &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; OSCILLATOR_MODE_SAW:
            &lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;
            &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;
        &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; OSCILLATOR_MODE_SQUARE:
            &lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;
            &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;
        &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; OSCILLATOR_MODE_TRIANGLE:
            &lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;
            &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This function will be called everytime &lt;code&gt;ProcessDoubleReplacing&lt;/code&gt; is called. We’re using a &lt;code&gt;switch&lt;/code&gt; to use the right code for whatever waveform is currently selected.&lt;/p&gt;
&lt;h2 id=&quot;generating-waveforms&quot;&gt;Generating Waveforms&lt;/h2&gt;
&lt;p&gt;The code for generating a sine wave is quite simple:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; OSCILLATOR_MODE_SINE:
    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; nFrames; i++) {
        buffer[i] = &lt;span class=&quot;built_in&quot;&gt;sin&lt;/span&gt;(mPhase);
        mPhase += mPhaseIncrement;
        &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (mPhase &amp;gt;= twoPI) {
            mPhase -= twoPI;
        }
    }
    &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note that we’re not working with &lt;code&gt;mFrequency&lt;/code&gt; and &lt;code&gt;mSampleRate&lt;/code&gt; here. We’re just incrementing &lt;code&gt;mPhase&lt;/code&gt; and make sure it stays between &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;twoPI&lt;/code&gt;. The only more complex operation is the call to the C &lt;code&gt;sin()&lt;/code&gt; function, which on many systems will be calculated on a hardware level.&lt;/p&gt;
&lt;p&gt;Here’s the code for the saw wave:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; OSCILLATOR_MODE_SAW:
    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; nFrames; i++) {
        buffer[i] = &lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt; - (&lt;span class=&quot;number&quot;&gt;2.0&lt;/span&gt; * mPhase / twoPI);
        mPhase += mPhaseIncrement;
        &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (mPhase &amp;gt;= twoPI) {
            mPhase -= twoPI;
        }
    }
    &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The interesting part is – again – the line of code that’s writing into the buffer. When I see formulas like these, I like to decompose them:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;mPhase&lt;/code&gt; goes from &lt;code&gt;0&lt;/code&gt; upwards, and jumps back to &lt;code&gt;0&lt;/code&gt; when it reaches &lt;code&gt;twoPI&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;So &lt;code&gt;(mPhase / twoPI)&lt;/code&gt; goes from &lt;code&gt;0&lt;/code&gt; upwards and jumps back to &lt;code&gt;0&lt;/code&gt; when it reaches &lt;code&gt;1&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;This means that &lt;code&gt;(2.0 * mPhase / twoPI)&lt;/code&gt; goes from &lt;code&gt;0&lt;/code&gt; up and jumps back at &lt;code&gt;2&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;When &lt;code&gt;mPhase&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;, the expression &lt;code&gt;1.0 - (2.0 * mPhase / twoPI)&lt;/code&gt; is &lt;code&gt;1&lt;/code&gt;. While &lt;code&gt;mPhase&lt;/code&gt; goes upwards, the expression goes &lt;em&gt;downwards&lt;/em&gt; and jumps back to &lt;code&gt;1&lt;/code&gt; when it reaches &lt;code&gt;-1&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;So we have a downwards saw wave!&lt;br&gt;The lower part that’s dealing with &lt;code&gt;mPhase&lt;/code&gt; is duplication that could be avoided, but in that case we would have to take the &lt;code&gt;switch&lt;/code&gt; statement into the loop. This would also prevent duplicating the &lt;code&gt;for&lt;/code&gt; statement, but the code would &lt;code&gt;switch&lt;/code&gt; more often than neccessary.&lt;br&gt;In most programming scenarios, we would prefer brevity and readability over performance. DSP code that’s executed 44100 or 96000 times per second &lt;em&gt;can&lt;/em&gt; be an exception to this rule. But be aware that the compiler will optimize a lot behind the scenes and what feels like &lt;em&gt;“a lot of work”&lt;/em&gt; to you (the programmer), may be very trivial compared to other areas you’re not thinking about.&lt;/p&gt;
&lt;p&gt;Next is the square wave:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; OSCILLATOR_MODE_SQUARE:
    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; nFrames; i++) {
        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (mPhase &amp;lt;= mPI) {
            buffer[i] = &lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;;
        } &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; {
            buffer[i] = -&lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;;
        }
        mPhase += mPhaseIncrement;
        &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (mPhase &amp;gt;= twoPI) {
            mPhase -= twoPI;
        }
    }
    &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You’re already familiar with the lower part. Every cycle is &lt;code&gt;twoPI&lt;/code&gt; long, so the &lt;code&gt;if&lt;/code&gt; statement causes the first half of every cycle to have values of &lt;code&gt;1&lt;/code&gt;, and the second half to have values of &lt;code&gt;-1&lt;/code&gt;. So there’s a very sudden jump when &lt;code&gt;mPhase&lt;/code&gt; becomes greater than &lt;code&gt;mPI&lt;/code&gt;. That’s a square wave.&lt;/p&gt;
&lt;p&gt;The triangle wave is just a little more complex:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; OSCILLATOR_MODE_TRIANGLE:
    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; nFrames; i++) {
        &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; value = -&lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt; + (&lt;span class=&quot;number&quot;&gt;2.0&lt;/span&gt; * mPhase / twoPI);
        buffer[i] = &lt;span class=&quot;number&quot;&gt;2.0&lt;/span&gt; * (&lt;span class=&quot;built_in&quot;&gt;fabs&lt;/span&gt;(value) - &lt;span class=&quot;number&quot;&gt;0.5&lt;/span&gt;);
        mPhase += mPhaseIncrement;
        &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (mPhase &amp;gt;= twoPI) {
            mPhase -= twoPI;
        }
    }
    &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you decompose &lt;code&gt;-1.0 + (2.0 * mPhase / twoPI)&lt;/code&gt; like I did above, you’ll notice that it’s the &lt;em&gt;inverse&lt;/em&gt; of the above saw wave: It’s an &lt;em&gt;upwards&lt;/em&gt; saw wave.&lt;br&gt;Let’s go from here: Taking absolute values (&lt;code&gt;fabs&lt;/code&gt;) of the upwards saw wave means that all values below &lt;code&gt;0&lt;/code&gt; will be &lt;em&gt;inverted&lt;/em&gt; (flipped around the &lt;em&gt;x&lt;/em&gt; axis). This means that the values will go up and down. Subtracting &lt;code&gt;0.5&lt;/code&gt; centers the waveform around &lt;code&gt;0&lt;/code&gt;. Multiplying by &lt;code&gt;2.0&lt;/code&gt; makes the values go between &lt;code&gt;-1&lt;/code&gt; to &lt;code&gt;+1&lt;/code&gt;. We have a triangle wave.&lt;/p&gt;
&lt;p&gt;Let’s use our oscillator! Include &lt;em&gt;Oscillator.h&lt;/em&gt; and add an &lt;code&gt;Oscillator&lt;/code&gt; member to your &lt;code&gt;Synthesis&lt;/code&gt; class:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;
&lt;span class=&quot;preprocessor&quot;&gt;#include &quot;Oscillator.h&quot;&lt;/span&gt;

&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; Synthesis : &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; IPlug
{
&lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt;:
    &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; mFrequency;
    &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; CreatePresets();
    Oscillator mOscillator;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We also renamed &lt;code&gt;mThreshold&lt;/code&gt; to &lt;code&gt;mFrequency&lt;/code&gt;.&lt;br&gt;In &lt;em&gt;Synthesis.cpp&lt;/em&gt;, rename all instances of &lt;code&gt;Threshold&lt;/code&gt; with &lt;code&gt;Frequency&lt;/code&gt;. Now change the parameter initialization inside the constructor:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;GetParam(kFrequency)-&amp;gt;InitDouble(&lt;span class=&quot;string&quot;&gt;&quot;Frequency&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;440.0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;50.0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;20000.0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0.01&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Hz&quot;&lt;/span&gt;);
GetParam(kFrequency)-&amp;gt;SetShape(&lt;span class=&quot;number&quot;&gt;2.0&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We’re re-using the knob for testing our class. We’ll be able to change the oscillator’s frequency between 50 Hz and 20 kHz (the default will be 440 Hz).&lt;br&gt;Change the &lt;code&gt;createPresets&lt;/code&gt; member function:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; Synthesis::CreatePresets() {
  MakePreset(&lt;span class=&quot;string&quot;&gt;&quot;clean&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;440.0&lt;/span&gt;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Inside &lt;code&gt;Reset&lt;/code&gt;, we have to tell the oscillator what sample rate is being used:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; Synthesis::Reset()
{
  TRACE;
  IMutexLock lock(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;);
  mOscillator.setSampleRate(GetSampleRate());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If we didn’t do this and the oscillator had the wrong sample rate, it would still generate the same waveforms, but at the wrong frequencies. &lt;code&gt;GetSampleRate&lt;/code&gt; is a member function that’s inherited from the &lt;code&gt;IPlugBase&lt;/code&gt; class.&lt;/p&gt;
&lt;p&gt;We have to edit &lt;code&gt;OnParamChange&lt;/code&gt; as well, so the oscillator’s frequency can be changed using the knob.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; Synthesis::OnParamChange(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; paramIdx)
{
  IMutexLock lock(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;);

  &lt;span class=&quot;keyword&quot;&gt;switch&lt;/span&gt; (paramIdx)
  {
    &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; kFrequency:
      mOscillator.setFrequency(GetParam(kFrequency)-&amp;gt;Value());
      &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;

    &lt;span class=&quot;keyword&quot;&gt;default&lt;/span&gt;:
      &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Finally, &lt;code&gt;ProcessDoubleReplacing&lt;/code&gt; has to use the oscillator:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; Synthesis::ProcessDoubleReplacing(&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt;** inputs,
                &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt;** outputs,
                &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; nFrames) {
  &lt;span class=&quot;comment&quot;&gt;// Mutex is already locked for us.&lt;/span&gt;

  &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; *leftOutput = outputs[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;];
  &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; *rightOutput = outputs[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;];

  mOscillator.generate(leftOutput, nFrames);

  &lt;span class=&quot;comment&quot;&gt;// Copy left buffer into right buffer:&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; s = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; s &amp;lt; nFrames; ++s) {
    rightOutput[s] = leftOutput[s];
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Basically we’re letting &lt;code&gt;mOscillator&lt;/code&gt; fill the left channel buffer. Then we copy everything into the right channel buffer.&lt;br&gt;Let’s hear how it sounds! Run the &lt;em&gt;VST2&lt;/em&gt; or &lt;em&gt;AU&lt;/em&gt; target. If you get linker errors, make sure you &lt;a href=&quot;http://www.martin-finke.de/articles/audio-plugins-008-synthesizing-waveforms/#compile_sources&quot;&gt;added &lt;em&gt;Oscillator.cpp&lt;/em&gt; to the &lt;em&gt;Compile Sources&lt;/em&gt; phase&lt;/a&gt;.&lt;br&gt;Once it’s running, you’ll hear a steady tone. Turn the knob and the frequency will change. Now change the initial value of &lt;code&gt;mOscillatorMode&lt;/code&gt; in &lt;em&gt;Oscillator.h&lt;/em&gt;, by modifying the constructor’s initializer list:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;Oscillator() :
    mOscillatorMode(OSCILLATOR_MODE_SAW),
    mPI(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;*&lt;span class=&quot;built_in&quot;&gt;acos&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;0.0&lt;/span&gt;)),
    mFrequency(&lt;span class=&quot;number&quot;&gt;440.0&lt;/span&gt;),
    mPhase(&lt;span class=&quot;number&quot;&gt;0.0&lt;/span&gt;),
    mSampleRate(&lt;span class=&quot;number&quot;&gt;44100.0&lt;/span&gt;) { updateIncrement(); };
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Run again and you’ll hear a sharper tone. Try &lt;code&gt;OSCILLATOR_MODE_SQUARE&lt;/code&gt; and &lt;code&gt;OSCILLATOR_MODE_TRIANGLE&lt;/code&gt;, too. Note the different timbres and turn the frequency knob. For all waveforms except the sine, you’ll hear that once you get into high frequencies, strange noises appear. There are additional tones, even below the base frequency. They sound inharmonic and when you turn the knob up and down, &lt;em&gt;they move in the opposite direction&lt;/em&gt;!&lt;/p&gt;
&lt;p&gt;&lt;a name=&quot;aliasing&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;aliasing&quot;&gt;Aliasing&lt;/h2&gt;
&lt;p&gt;If you look at the code for the square wave, you’ll notice that every time &lt;code&gt;mPhase&lt;/code&gt; becomes greater than &lt;code&gt;mPI&lt;/code&gt;, the waveform will jump from the positive max to the negative max, all from one sample to the next. The opposite jump happens when &lt;code&gt;twoPI&lt;/code&gt; is subtracted from mPhase and it becomes less than &lt;code&gt;mPI&lt;/code&gt; again. Generally, sudden jumps in a waveform mean that there’s a lot of high frequency content. Imagine somebody told you to &lt;em&gt;construct this jump using as many sine waves as you like, but only sine waves&lt;/em&gt;. Given the generally round shape of sine waves, you can imagine how you’d need a lot of sine waves with a very high frequency. You actually need an infinite number of sine waves with frequencies going towards infinity to create a perfect square, saw or triangle wave.&lt;/p&gt;
&lt;p&gt;In computers, everything is &lt;em&gt;finite&lt;/em&gt;. You have a limited amount of disk space and RAM, so when you record one second of audio, your computer can only use a finite number of values to save it. This number (called the &lt;em&gt;Sample Rate&lt;/em&gt;) can be any value, but is often 44100, 48000 or 96000 samples per second. An audio signal stored using a finite number of samples per second is called &lt;a href=&quot;http://en.wikipedia.org/wiki/Discrete_signal&quot;&gt;discrete&lt;/a&gt;.&lt;br&gt;To describe a signal that’s oscillating between +1 and -1, you need &lt;em&gt;at the very least&lt;/em&gt; two samples per cycle: one with the value +1 and one with the value -1. So if you have 44100 samples per second, the maximum frequency you can describe is 22050 Hz (see &lt;a href=&quot;http://en.wikipedia.org/wiki/Nyquist_frequency&quot;&gt;Nyquist frequency&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;So, it’s not possible to describe a perfect square, saw or triangle wave in a discrete time signal. If we try to do it (by generating the sharp jumps in the waveform), we will get &lt;a href=&quot;https://en.wikipedia.org/wiki/Aliasing&quot;&gt;aliasing effects&lt;/a&gt;. For more information, click &lt;a href=&quot;http://www.dspguide.com/ch3/2.htm&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;How can we generate &lt;em&gt;the best, alias-free wave for a given sample rate&lt;/em&gt;? &lt;em&gt;“Best”&lt;/em&gt; meaning &lt;em&gt;“closest to the shape we calculated above”&lt;/em&gt;.&lt;br&gt;The Nyquist frequency is a constraint that’s expressed in the frequency domain. It doesn’t say &lt;em&gt;“Your waveform shouldn’t have spikes that are steeper than X”&lt;/em&gt;. It says &lt;em&gt;“Your signal shouldn’t have frequencies above X Hz”&lt;/em&gt;. So we need to shift our work to the frequency domain. We will do that in a &lt;a href=&quot;http://www.martin-finke.de/articles/audio-plugins-018-polyblep-oscillator/&quot;&gt;future post&lt;/a&gt;, but in the next post we’ll look at how we can &lt;a href=&quot;http://www.martin-finke.de/articles/audio-plugins-009-receiving-midi/&quot;&gt;receive incoming MIDI data&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;You can download the code we’ve created so far &lt;a href=&quot;/blog/articles/audio-plugins-008-synthesizing-waveforms/source.zip&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Making Audio Plugins Part 7: GUI</title>
      <link>http://www.martin-finke.de/blog/articles/audio-plugins-007-gui/</link>
      <pubDate>Sun, 15 Sep 2013 17:36:00 +0200</pubDate>
      <guid isPermaLink="true">http://www.martin-finke.de/blog/articles/audio-plugins-007-gui/</guid>
      <author></author>
      <description>&lt;p&gt;It’s time to create a better user interface for our digital distortion plugin. &lt;span class=&quot;more&quot;&gt;&lt;/span&gt; Here’s the look we’re going for:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/blog/articles/audio-plugins-007-gui/gui.jpg&quot;&gt;&lt;img src=&quot;/blog/articles/audio-plugins-007-gui/gui.jpg&quot; alt=&quot;GUI Preview&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;It’s not &lt;em&gt;awesome&lt;/em&gt;, and just to demonstrate how we can add graphics and – more interestingly – how to create the rotating knob.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/blog/articles/audio-plugins-007-gui/gui.tif&quot;&gt;Here&lt;/a&gt;‘s the TIFF of the design. Open it in Photoshop (or your preferred tool) and have a look at the different layers and groups. As you can see, the only part that’s really going to change is the knob. So we can export the rest as one PNG:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/blog/articles/audio-plugins-007-gui/background.png&quot;&gt;&lt;img src=&quot;/blog/articles/audio-plugins-007-gui/background.png&quot; alt=&quot;Background&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;adding-the-background-for-mac-builds&quot;&gt;Adding the Background for Mac Builds&lt;/h2&gt;
&lt;p&gt;Click on the above image and save it to your desktop. Open the &lt;em&gt;DigitalDistortion&lt;/em&gt; project in Xcode. In the project navigator, expand the &lt;em&gt;Resources&lt;/em&gt; folder and drag your image into the &lt;em&gt;img&lt;/em&gt; folder inside of that:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/blog/articles/audio-plugins-007-gui/drag-into-xcode.jpg&quot;&gt;&lt;img src=&quot;/blog/articles/audio-plugins-007-gui/drag-into-xcode.jpg&quot; alt=&quot;Drag background image into Xcode&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Make sure you check the  &lt;em&gt;Copy items into folder&lt;/em&gt; option and add it to all targets:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/blog/articles/audio-plugins-007-gui/add-to-targets.jpg&quot;&gt;&lt;img src=&quot;/blog/articles/audio-plugins-007-gui/add-to-targets.jpg&quot; alt=&quot;Add to targets&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;adding-the-background-for-windows-builds&quot;&gt;Adding the Background for Windows Builds&lt;/h2&gt;
&lt;p&gt;For Visual Studio, adding a resource (like an image) to your project is a little different. &lt;em&gt;Adding to all targets&lt;/em&gt; on Mac means that the image will be included into the &lt;em&gt;.app&lt;/em&gt;, &lt;em&gt;.vst&lt;/em&gt; and &lt;em&gt;.component&lt;/em&gt; files you ship to your users.&lt;br&gt;To achieve this with Visual Studio, edit your project’s &lt;em&gt;&lt;Projectname&gt;.rc&lt;/em&gt; file. For this project it’s called &lt;em&gt;DigitalDistortion.rc&lt;/em&gt;. When you open it, the top looks like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#include &quot;resource.h&quot;&lt;/span&gt;

KNOB_ID       PNG KNOB_FN
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;First, &lt;em&gt;resource.h&lt;/em&gt; is included, so all the &lt;code&gt;#define&lt;/code&gt;s from there are available here. The line below that declares that the knob should be included. So to include the background as well, add this line just below that:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;BACKGROUND_ID       PNG BACKGROUND_FN
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We’ll add &lt;code&gt;BACKGROUND_ID&lt;/code&gt; and &lt;code&gt;BACKGROUND_FN&lt;/code&gt; to &lt;em&gt;resource.h&lt;/em&gt; in a second.&lt;br&gt;&lt;strong&gt;Whenever we add an image to our project, we have to to add a line like this.&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;using-the-background&quot;&gt;Using the Background&lt;/h2&gt;
&lt;p&gt;Let’s reference the image from our code. Go into &lt;em&gt;resource.h&lt;/em&gt; and change the GUI size (around line 62):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// GUI default dimensions&lt;/span&gt;
&lt;span class=&quot;preprocessor&quot;&gt;#define GUI_WIDTH 280&lt;/span&gt;
&lt;span class=&quot;preprocessor&quot;&gt;#define GUI_HEIGHT 230&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;…and add the background image ID and filename:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Unique IDs for each image resource.&lt;/span&gt;
&lt;span class=&quot;preprocessor&quot;&gt;#define KNOB_ID 101&lt;/span&gt;
&lt;span class=&quot;preprocessor&quot;&gt;#define BACKGROUND_ID 102&lt;/span&gt;

&lt;span class=&quot;comment&quot;&gt;// Image resource locations for this plug.&lt;/span&gt;
&lt;span class=&quot;preprocessor&quot;&gt;#define KNOB_FN &quot;resources/img/knob.png&quot;&lt;/span&gt;
&lt;span class=&quot;preprocessor&quot;&gt;#define BACKGROUND_FN &quot;resources/img/background.png&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In &lt;em&gt;DigitalDistortion.cpp&lt;/em&gt;, change the constructor code to attach &lt;em&gt;background.png&lt;/em&gt; instead of the red color:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// pGraphics-&amp;gt;AttachPanelBackground(&amp;amp;COLOR_RED);&lt;/span&gt;
pGraphics-&amp;gt;AttachBackground(BACKGROUND_ID, BACKGROUND_FN);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That was easy! Run the &lt;em&gt;APP&lt;/em&gt; target and you’ll see the nice background:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/blog/articles/audio-plugins-007-gui/background-changed.jpg&quot;&gt;&lt;img src=&quot;/blog/articles/audio-plugins-007-gui/background-changed.jpg&quot; alt=&quot;Running APP target&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;If the background isn’t working on windows, you may have to put &lt;em&gt;background.png&lt;/em&gt; inside the folder &lt;em&gt;DigitalDistortion\resources\img\&lt;/em&gt;, so it’s found correctly.&lt;/p&gt;
&lt;h2 id=&quot;adding-the-knob&quot;&gt;Adding the knob&lt;/h2&gt;
&lt;p&gt;The knob is slightly more difficult. Have a look at the design again and you may see how the knob consists of a textured part and some reflections. When you turn a knob, the metal itself moves, but the lamp on your ceiling sure doesn’t! So some parts of the graphic should rotate (metal texture, the black arrow), while others should stay fixed (anything due to light). What about the “outer ring”? It has some contour, but all of that is due to incidence of light, so it shouldn’t rotate.&lt;br&gt;That’s why we can’t just export the knob in twelve-o’clock-position and rotate it at runtime.&lt;br&gt;To be more precise, there should be a knob &lt;em&gt;base&lt;/em&gt; which &lt;em&gt;doesn’t&lt;/em&gt; rotate. On top of that, we need the &lt;em&gt;metal texture&lt;/em&gt; which &lt;em&gt;does&lt;/em&gt; rotate. And finally we need another layer with the light reflections which &lt;em&gt;doesn’t&lt;/em&gt; rotate. These are the three parts, exported separately (the black background is just added so you can see everything):&lt;/p&gt;
&lt;p&gt;&lt;p style=&quot;background: black; margin-left: auto; margin-right: auto; width: 125px;&quot;&gt;
    &lt;a href=&quot;/blog/articles/audio-plugins-007-gui/knob-base.png&quot;&gt;&lt;img src=&quot;/blog/articles/audio-plugins-007-gui/knob-base.png&quot; alt=&quot;&quot;&gt;&lt;/a&gt;
    &lt;a href=&quot;/blog/articles/audio-plugins-007-gui/metal-brush.png&quot;&gt;&lt;img src=&quot;/blog/articles/audio-plugins-007-gui/metal-brush.png&quot; alt=&quot;&quot;&gt;&lt;/a&gt;
    &lt;a href=&quot;/blog/articles/audio-plugins-007-gui/highlight.png&quot;&gt;&lt;img src=&quot;/blog/articles/audio-plugins-007-gui/highlight.png&quot; alt=&quot;&quot;&gt;&lt;/a&gt;
&lt;/p&gt;
There’s a very good tool for this. It’s called &lt;em&gt;KnobMan&lt;/em&gt;, it’s freeware and it’s made for this exact purpose. &lt;a href=&quot;http://www.g200kg.com/en/software/knobman.html&quot;&gt;Download JKnobMan&lt;/a&gt; for your system, start it and load &lt;a href=&quot;/blog/articles/audio-plugins-007-gui/knob.knob&quot;&gt;the knob file&lt;/a&gt; I’ve prepared:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/blog/articles/audio-plugins-007-gui/knobman.jpg&quot;&gt;&lt;img src=&quot;/blog/articles/audio-plugins-007-gui/knobman.jpg&quot; alt=&quot;Knobman&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;All I’ve done is add the three layers and change some coordinates so the metal texture rotates correctly without moving around. There’s a &lt;a href=&quot;http://www.g200kg.com/en/docs/knobman/overview.html&quot;&gt;tutorial&lt;/a&gt; available if you want to get deeper into the software.&lt;br&gt;Export (Cmd+E, Ctrl+E on Windows) the knob to a file and name it &lt;em&gt;knob.png&lt;/em&gt; (or &lt;a href=&quot;/blog/articles/audio-plugins-007-gui/knob.png&quot;&gt;download mine&lt;/a&gt;). The PNG has 128 frames covering all rotations, and only the metal &amp;amp; arrow are rotated. Nice!&lt;/p&gt;
&lt;p&gt;Back in Xcode, right-click the existing &lt;em&gt;knob.png&lt;/em&gt; and click &lt;em&gt;Delete&lt;/em&gt;. In the following prompt, select &lt;em&gt;Move to Trash&lt;/em&gt;. Now drag the &lt;em&gt;knob.png&lt;/em&gt; onto the &lt;em&gt;img&lt;/em&gt; folder and do everything the same way as for the background image above.&lt;br&gt;Since the filename is the same, we can leave &lt;em&gt;resource.h&lt;/em&gt; alone. Go straight into &lt;em&gt;DigitalDistortion.cpp&lt;/em&gt; and change the &lt;code&gt;enum ELayout&lt;/code&gt; as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;enum&lt;/span&gt; ELayout
{
  kWidth = GUI_WIDTH,
  kHeight = GUI_HEIGHT,

  kThresholdX = &lt;span class=&quot;number&quot;&gt;79&lt;/span&gt;,
  kThresholdY = &lt;span class=&quot;number&quot;&gt;62&lt;/span&gt;,
  kKnobFrames = &lt;span class=&quot;number&quot;&gt;128&lt;/span&gt;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We don’t even have to tell WDL that the knob is bigger than the previous one! We just say &lt;em&gt;“the PNG has 128 frames in it”&lt;/em&gt; and specify where the knob should be placed.&lt;br&gt;Run your plugin as VST2 and check out how you can turn the knob and it will go through the rotation frames. What’s confusing, though, is that our plugin does &lt;em&gt;distortion&lt;/em&gt; and having the knob at 100% gets us a clean sound!&lt;/p&gt;
&lt;p&gt;&lt;a name=&quot;correcting_knob_direction&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;correcting-the-knob-direction&quot;&gt;Correcting the Knob Direction&lt;/h2&gt;
&lt;p&gt;Let’s change that in line 98:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;mThreshold = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; - (GetParam(kThreshold)-&amp;gt;Value() / &lt;span class=&quot;number&quot;&gt;100.&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To prevent the &lt;em&gt;division by zero&lt;/em&gt; problem described &lt;a href=&quot;http://www.martin-finke.de/articles/audio-plugins-005-digital-distortion/#no_division_by_zero&quot;&gt;earlier&lt;/a&gt;, we also have to modify line 33 so that the parameter defaults to &lt;code&gt;0&lt;/code&gt; and will not exceed &lt;code&gt;99.99&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;GetParam(kThreshold)-&amp;gt;InitDouble(&lt;span class=&quot;string&quot;&gt;&quot;Threshold&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0.0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0.0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;99.99&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0.01&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;%&quot;&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you run again, the plugin should work as expected. It might be a good idea to rename the variables from &lt;code&gt;Threshold&lt;/code&gt; to something like &lt;code&gt;DistortionAmount&lt;/code&gt;. The only thing still representing a threshold is the internal &lt;code&gt;mThreshold&lt;/code&gt; variable.&lt;/p&gt;
&lt;h2 id=&quot;summary&quot;&gt;Summary&lt;/h2&gt;
&lt;p&gt;With minimal DSP code we have created a working distortion plugin with a custom user interface. This was to give you an idea of what goes into creating an audio plugin – sort of the &lt;em&gt;big picture&lt;/em&gt;.&lt;br&gt;Now that we have an overview, we’re ready to get into more interesting signal processing: &lt;a href=&quot;http://www.martin-finke.de/articles/audio-plugins-008-synthesizing-waveforms/&quot;&gt;The next post will be about synthesizing waveforms&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;If you got stuck somewhere, you can download a ZIP with all files &lt;a href=&quot;/blog/articles/audio-plugins-007-gui/DigitalDistortion_Finished.zip&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;further-reading&quot;&gt;Further Reading&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;There are a lot of free KnobMan examples &lt;a href=&quot;http://www.kvraudio.com/forum/viewtopic.php?t=232629&quot;&gt;here&lt;/a&gt; and &lt;a href=&quot;http://radorec.com/-skins/20-free-vst-knobs&quot;&gt;here&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;credits&quot;&gt;Credits&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;The metal look is based on &lt;a href=&quot;http://psd.tutsplus.com/tutorials/interface-tutorials/creating-a-cool-brushed-metal-surface-in-photoshop/&quot;&gt;this&lt;/a&gt; Photoshop tutorial. Thanks to the author!  &lt;/li&gt;
&lt;li&gt;Thanks to &lt;a href=&quot;http://www.g200kg.com/&quot;&gt;g200kg&lt;/a&gt; for KnobMan!&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    <item>
      <title>Making Audio Plugins Part 6: Presets</title>
      <link>http://www.martin-finke.de/blog/articles/audio-plugins-006-presets/</link>
      <pubDate>Sun, 15 Sep 2013 17:35:00 +0200</pubDate>
      <guid isPermaLink="true">http://www.martin-finke.de/blog/articles/audio-plugins-006-presets/</guid>
      <author></author>
      <description>&lt;p&gt;Let’s add some presets to our distortion plugin! &lt;span class=&quot;more&quot;&gt;&lt;/span&gt; Presets allow your plugin to store values for its parameters. For now, a preset consists of a name and values for all the parameters. We will later see that you can actually store arbitrary data. Presets are sometimes called &lt;em&gt;programs&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;First, let’s make the GUI a little wider so we can see the host’s preset selection better. Open &lt;em&gt;resource.h&lt;/em&gt; and change the constant:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// GUI default dimensions&lt;/span&gt;
&lt;span class=&quot;preprocessor&quot;&gt;#define GUI_WIDTH 400&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In &lt;em&gt;DigitalDistortion.h&lt;/em&gt;, declare a private member function:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt;:
  &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; mThreshold;
  &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; CreatePresets();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Add the implementation to &lt;em&gt;DigitalDistortion.cpp&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; DigitalDistortion::CreatePresets() {
  MakePreset(&lt;span class=&quot;string&quot;&gt;&quot;clean&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;100.0&lt;/span&gt;);
  MakePreset(&lt;span class=&quot;string&quot;&gt;&quot;slightly distorted&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;80.0&lt;/span&gt;);
  MakePreset(&lt;span class=&quot;string&quot;&gt;&quot;woooo&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;40.0&lt;/span&gt;);
  MakePreset(&lt;span class=&quot;string&quot;&gt;&quot;waaaa&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;20.0&lt;/span&gt;);
  MakePreset(&lt;span class=&quot;string&quot;&gt;&quot;buzzz!!!&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0.01&lt;/span&gt;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;MakePreset&lt;/code&gt; takes the name of the preset, followed by values for all parameters. The order is defined in the &lt;code&gt;enum EParams&lt;/code&gt; at the top of the file. Notice how the values are between 0 and 100, &lt;em&gt;not&lt;/em&gt; between 0 and 1. They refer to the &lt;em&gt;parameter&lt;/em&gt; &lt;code&gt;kThreshold&lt;/code&gt;, not to the &lt;code&gt;mThreshold&lt;/code&gt; member variable.&lt;/p&gt;
&lt;p&gt;Remove the &lt;code&gt;MakeDefaultPreset&lt;/code&gt; call at the end of the constructor and instead call &lt;code&gt;CreatePresets&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;DigitalDistortion::DigitalDistortion(IPlugInstanceInfo instanceInfo)
  : IPLUG_CTOR(kNumParams, kNumPrograms, instanceInfo), mThreshold(&lt;span class=&quot;number&quot;&gt;1.&lt;/span&gt;)
{
  &lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;

  CreatePresets();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Finally, we have to change the constant in line 13 (which is passed to the base class constructor call):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; kNumPrograms = &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If this is a higher number than the times you call &lt;code&gt;MakePreset&lt;/code&gt;, the remaining presets will just be called “Empty”.&lt;br&gt;Run the &lt;em&gt;VST2&lt;/em&gt; target. You may have to remove the plugin from your track and insert it again to get the newly added presets. You can change presets by using the dropdown above your plugin GUI. Change presets and watch how the knob takes different values and the distortion amount changes. Remember, when you change presets, &lt;code&gt;OnParamChange&lt;/code&gt; is called for every parameter.&lt;br&gt;To the right of the dropdown menu there’s a button which opens the preset menu:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/blog/articles/audio-plugins-006-presets/preset-menu.jpg&quot;&gt;&lt;img src=&quot;/blog/articles/audio-plugins-006-presets/preset-menu.jpg&quot; alt=&quot;Preset Menu&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Try renaming a preset and turn the knob. These changes would be lost if you removed the plugin and inserted it again. To save them, click &lt;em&gt;“Export VST patch/bank file (.fxp/.fxb)…”&lt;/em&gt; and save the file &lt;em&gt;test.fxb&lt;/em&gt; to your desktop. Remove the plugin, insert it again and import &lt;em&gt;test.fxb&lt;/em&gt; to restore your changes.&lt;br&gt;VST plugins use the &lt;em&gt;FXP&lt;/em&gt; format to store a single preset, and the &lt;em&gt;FX&lt;strong&gt;B&lt;/strong&gt;&lt;/em&gt; format to store a bank of them.&lt;/p&gt;
&lt;p&gt;Run the &lt;em&gt;AU&lt;/em&gt; target (you may have to &lt;a href=&quot;http://www.martin-finke.de/articles/audio-plugins-004-vst-and-au/#edit_scheme&quot;&gt;Edit Scheme&lt;/a&gt; first to make it run in Reaper). Make sure you actually insert the &lt;em&gt;AU&lt;/em&gt; plugin and not the &lt;em&gt;VST&lt;/em&gt;. Note how Reaper defaults to “No preset”, but all presets are there in the dropdown menu and everything works as expected. Saving presets is a little different: You can’t import or export banks. For more details on preset saving see &lt;a href=&quot;http://forum.cockos.com/showpost.php?p=969598&quot;&gt;this post&lt;/a&gt; by Oli Larkin.&lt;/p&gt;
&lt;p&gt;Now let’s add a &lt;a href=&quot;http://www.martin-finke.de/articles/audio-plugins-007-gui/&quot;&gt;better GUI&lt;/a&gt;!&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Making Audio Plugins Part 5: Digital Distortion</title>
      <link>http://www.martin-finke.de/blog/articles/audio-plugins-005-digital-distortion/</link>
      <pubDate>Sun, 15 Sep 2013 17:34:00 +0200</pubDate>
      <guid isPermaLink="true">http://www.martin-finke.de/blog/articles/audio-plugins-005-digital-distortion/</guid>
      <author></author>
      <description>&lt;p&gt;It’s time to write our first plugin, a nasty digital distortion. &lt;span class=&quot;more&quot;&gt;&lt;/span&gt; To be more precise, the plugin will apply &lt;a href=&quot;http://en.wikipedia.org/wiki/Clipping_%28audio%29&quot;&gt;clipping&lt;/a&gt; to the audio signal. Signal values above a certain threshold will be limited to it so that the threshold is never exceeded:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/blog/articles/audio-plugins-005-digital-distortion/threshold.jpg&quot;&gt;&lt;img src=&quot;/blog/articles/audio-plugins-005-digital-distortion/threshold.jpg&quot; alt=&quot;Threshold&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Note that by “above” I mean “above a certain positive threshold &lt;em&gt;or below a certain negative threshold&lt;/em&gt;“.&lt;/p&gt;
&lt;p&gt;Using the &lt;code&gt;duplicate&lt;/code&gt; script &lt;a href=&quot;http://www.martin-finke.de/articles/audio-plugins-002-setting-up-wdl-ol/#duplicate_script&quot;&gt;introduced earlier&lt;/a&gt;, we can clone any existing project to a new project with a new name. This means that we don’t have to make all the &lt;a href=&quot;http://www.martin-finke.de/articles/audio-plugins-004-vst-and-au/#warnings&quot;&gt;modifications&lt;/a&gt; we did again for every new project.&lt;br&gt;Open a Terminal, go to your &lt;em&gt;IPlugExamples&lt;/em&gt; folder and run:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-bash&quot;&gt;./duplicate.py MyFirstPlugin/ DigitalDistortion YourName
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you haven’t followed the last post, you can download the files &lt;a href=&quot;/blog/articles/audio-plugins-005-digital-distortion/finished-004.zip&quot;&gt;here&lt;/a&gt;.
Make sure you don’t have any other project open in Xcode. From the newly created &lt;em&gt;DigitalDistortion&lt;/em&gt; folder, open &lt;em&gt;DigitalDistortion.xcodeproj&lt;/em&gt;. Verify that it builds the &lt;em&gt;APP&lt;/em&gt; target without errors. Edit the Schemes &lt;a href=&quot;http://www.martin-finke.de/articles/audio-plugins-004-vst-and-au/#edit_scheme&quot;&gt;like I’ve shown before&lt;/a&gt; to make sure Reaper runs for the VST2 and AU targets. Don’t forget to change the &lt;em&gt;Arguments Passed On Launch&lt;/em&gt; to point to the right &lt;em&gt;.RPP&lt;/em&gt; file.&lt;/p&gt;
&lt;p&gt;Now when you run Reaper, you’ll see that instead of loading &lt;em&gt;MyFirstPlugin&lt;/em&gt;, it has magically loaded the &lt;em&gt;DigitalDistortion&lt;/em&gt; plugin! This is because the Reaper project file is text-based and the &lt;code&gt;duplicate&lt;/code&gt; script replaces all occurrences of “MyFirstPlugin” with “DigitalDistortion”.&lt;/p&gt;
&lt;p&gt;Let’s start with turning our &lt;code&gt;mGain&lt;/code&gt; parameter into a &lt;code&gt;mThreshold&lt;/code&gt; parameter. Go into &lt;em&gt;DigitalDistortion.h&lt;/em&gt; and rename the &lt;code&gt;private&lt;/code&gt; member variable:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt;:
  &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; mThreshold;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now open &lt;em&gt;DigitalDistortion.cpp&lt;/em&gt; and replace (Cmd+Alt+F) all occurrences of the word &lt;em&gt;Gain&lt;/em&gt; with &lt;em&gt;Threshold&lt;/em&gt;. You should be able to build without errors.
&lt;a name=&quot;parameter_initialization&quot;&gt;&lt;/a&gt;
Change the parameter initialization in the constructor to have &lt;code&gt;0.01&lt;/code&gt; as the minimum and &lt;code&gt;100.0&lt;/code&gt; as the default value:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;GetParam(kThreshold)-&amp;gt;InitDouble(&lt;span class=&quot;string&quot;&gt;&quot;Threshold&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;100.0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0.01&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;100.0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0.01&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;%&quot;&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let’s implement the DSP part:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; DigitalDistortion::ProcessDoubleReplacing(
    &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt;** inputs,
    &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt;** outputs,
    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; nFrames)
{
  &lt;span class=&quot;comment&quot;&gt;// Mutex is already locked for us.&lt;/span&gt;

  &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; channelCount = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;

  &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; channelCount; i++) {
    &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt;* input = inputs[i];
    &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt;* output = outputs[i];

    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; s = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; s &amp;lt; nFrames; ++s, ++input, ++output) {
      &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(*input &amp;gt;= &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) {
        &lt;span class=&quot;comment&quot;&gt;// Make sure positive values can't go above the threshold:&lt;/span&gt;
        *output = fmin(*input, mThreshold);
      } &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; {
        &lt;span class=&quot;comment&quot;&gt;// Make sure negative values can't go below the threshold:&lt;/span&gt;
        *output = fmax(*input, -mThreshold);
      }
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a name=&quot;fmin_fmax_undefined&quot;&gt;&lt;/a&gt;
If you get an error that &lt;code&gt;fmax&lt;/code&gt; and &lt;code&gt;fmin&lt;/code&gt; are not defined, try changing the &lt;code&gt;fmin&lt;/code&gt; call to just &lt;code&gt;min&lt;/code&gt;, and &lt;code&gt;fmax&lt;/code&gt; to &lt;code&gt;max&lt;/code&gt;. If that doesn’t work, add this line to the top of &lt;em&gt;DigitalDistortion.cpp&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#include &amp;lt;math.h&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If that still doesn’t solve the problem, try adding this line instead:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#include &amp;lt;algorithm&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And change the &lt;code&gt;fmin&lt;/code&gt; to &lt;code&gt;std::min&lt;/code&gt;, and &lt;code&gt;fmax&lt;/code&gt; to &lt;code&gt;std::max&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Although the &lt;code&gt;channelCount&lt;/code&gt; is still hardcoded, we have removed some duplication by using an outer &lt;code&gt;for&lt;/code&gt; loop to iterate over all channels. This means that the plugin processes the samples for one audio channel at the time before processing the next channel.&lt;br&gt;The interesting part is the &lt;code&gt;if&lt;/code&gt; statement: For positive values we take the input value or the threshold value, whichever is lower. For negative values we take &lt;code&gt;*input&lt;/code&gt; or the negative threshold, whichever is &lt;em&gt;closer to zero&lt;/em&gt;.&lt;br&gt;Run the plugin in Reaper and try it on the test tone. When the knob is all the way to the right, you’ll hear a clean tone. When you turn the knob counter-clockwise, it will start to sound more and more distorted.&lt;br&gt;You’ll also notice that the signal is getting quieter the more you distort it. That’s because the threshold goes towards zero and so we’re clipping the signal to very small values. To compensate for this, divide the signal value by the threshold value:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(*input &amp;gt;= &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) {
  *output = fmin(*input, mThreshold);
} &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; {
  *output = fmax(*input, -mThreshold);
}
*output /= mThreshold;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a name=&quot;no_division_by_zero&quot;&gt;&lt;/a&gt;
Remember how we changed the parameter &lt;a href=&quot;http://www.martin-finke.de/articles/audio-plugins-005-digital-distortion/#parameter_initialization&quot;&gt;earlier&lt;/a&gt; to have a minimum value of &lt;code&gt;0.01&lt;/code&gt;? This ensures that we’re never dividing by zero, even if we turn the knob fully counter-clockwise.&lt;br&gt;If you run the plugin again, you’ll hear that the amplitude stays the same no matter how much you distort the signal. In fact, the signal appears to become &lt;em&gt;louder&lt;/em&gt;! The clipping turns our sine wave input into something close to a square wave, which has a higher &lt;a href=&quot;https://en.wikipedia.org/wiki/Root_mean_square#RMS_of_common_waveforms&quot;&gt;RMS&lt;/a&gt; than a sine wave.&lt;/p&gt;
&lt;p&gt;For now, I’m intentionally keeping the DSP part as simple as I can. In my opinion, a good plugin isn’t just about processing a chunk of samples. It’s a combination of:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Solid host integration (Presets, Compatibility)&lt;/li&gt;
&lt;li&gt;Good sound (&lt;em&gt;this&lt;/em&gt; is pure DSP)&lt;/li&gt;
&lt;li&gt;Clear user interface&lt;/li&gt;
&lt;li&gt;Beautiful graphics&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;So before we dive into more complex DSP, we will add &lt;a href=&quot;http://www.martin-finke.de/articles/audio-plugins-006-presets/&quot;&gt;presets&lt;/a&gt; and a &lt;a href=&quot;http://www.martin-finke.de/articles/audio-plugins-007-gui/&quot;&gt;better GUI&lt;/a&gt; to our plugin.&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Making Audio Plugins Part 4: VST and AU Targets</title>
      <link>http://www.martin-finke.de/blog/articles/audio-plugins-004-vst-and-au/</link>
      <pubDate>Sun, 15 Sep 2013 17:33:00 +0200</pubDate>
      <guid isPermaLink="true">http://www.martin-finke.de/blog/articles/audio-plugins-004-vst-and-au/</guid>
      <author></author>
      <description>&lt;p&gt;WDL-OL makes it very easy to turn our standalone app into a VST or AudioUnit plugin. &lt;span class=&quot;more&quot;&gt;&lt;/span&gt; To build a VST version, change your scheme to &lt;em&gt;VST2&lt;/em&gt; → &lt;em&gt;My Mac 64-Bit&lt;/em&gt;. Hit &lt;em&gt;Run&lt;/em&gt; and you shouldn’t get any errors, but nothing is being run! Open a Finder window and go to &lt;em&gt;~/Library/Audio/Plug-Ins/VST&lt;/em&gt; and you should see &lt;em&gt;MyFirstPlugin.vst&lt;/em&gt; there. If you can’t see the &lt;em&gt;Library&lt;/em&gt; folder in your home folder, press Cmd+Shift+G, paste in the path and hit Enter.&lt;/p&gt;
&lt;p&gt;The following is for Mac users with Xcode. For a guide on Windows, please see &lt;a href=&quot;http://www.martin-finke.de/articles/audio-plugins-004-vst-and-au/#windows_debugging_setup&quot;&gt;below&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;debugging-using-xcode&quot;&gt;Debugging using Xcode&lt;/h2&gt;
&lt;p&gt;To run the plugin, we need a host. Download the 64-bit version of &lt;a href=&quot;http://reaper.fm/&quot;&gt;Reaper&lt;/a&gt; and drag it to your Applications folder. You can evaluate it for 60 days, after that you’re asked to purchase a license. We’re going to set things up so when we click &lt;em&gt;Run&lt;/em&gt; in Xcode, it will start Reaper and connect the debugger. We’ll be able to use breakpoints just like with the standalone app.&lt;/p&gt;
&lt;p&gt;&lt;a name=&quot;edit_scheme&quot;&gt;&lt;/a&gt;
Go to &lt;em&gt;Product&lt;/em&gt; → &lt;em&gt;Scheme&lt;/em&gt; → &lt;em&gt;Edit Scheme…&lt;/em&gt; and make sure you have selected &lt;em&gt;Run&lt;/em&gt; in the list on the left side. Under &lt;em&gt;Executable&lt;/em&gt;, select &lt;em&gt;Other…&lt;/em&gt;:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/blog/articles/audio-plugins-004-vst-and-au/edit-scheme.jpg&quot;&gt;&lt;img src=&quot;/blog/articles/audio-plugins-004-vst-and-au/edit-scheme.jpg&quot; alt=&quot;Edit Scheme&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Use the dialog to find &lt;em&gt;REAPER64.app&lt;/em&gt;. Now it should look like this:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/blog/articles/audio-plugins-004-vst-and-au/executable.jpg&quot;&gt;&lt;img src=&quot;/blog/articles/audio-plugins-004-vst-and-au/executable.jpg&quot; alt=&quot;REAPER64 selected&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Click &lt;em&gt;OK&lt;/em&gt; and then &lt;em&gt;Run&lt;/em&gt; again. Reaper will start. Press Cmd+T (Ctrl+T on Windows) to insert a new Track, then click the &lt;em&gt;FX&lt;/em&gt; button:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/blog/articles/audio-plugins-004-vst-and-au/show-fx-window.jpg&quot;&gt;&lt;img src=&quot;/blog/articles/audio-plugins-004-vst-and-au/show-fx-window.jpg&quot; alt=&quot;FX Button&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;In the window that’s opened, enter &lt;em&gt;myfirstplugin&lt;/em&gt; and it will show up:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/blog/articles/audio-plugins-004-vst-and-au/select-plugin.jpg&quot;&gt;&lt;img src=&quot;/blog/articles/audio-plugins-004-vst-and-au/select-plugin.jpg&quot; alt=&quot;FX Button&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Select it and click &lt;em&gt;OK&lt;/em&gt;. The plugin will appear. The advantage over running standalone is that you can run any audio file through your plugin and hear what it does to the sound. This is much more interesting than being limited to your computer’s microphone. Also, you can use other plugins to inspect your own plugin’s output, which will come in handy later.&lt;br&gt;Download &lt;a href=&quot;/blog/articles/audio-plugins-004-vst-and-au/sine-110hz.flac&quot;&gt;this&lt;/a&gt; file and drag it onto the Track in Reaper. Make sure you drag it all the way to the left. Hit &lt;em&gt;space&lt;/em&gt; to start playback and you’ll hear a low tone:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/blog/articles/audio-plugins-004-vst-and-au/playback.png&quot;&gt;&lt;img src=&quot;/blog/articles/audio-plugins-004-vst-and-au/playback.png&quot; alt=&quot;Playing back audio in Reaper&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;For testing, it would be nice if the tone could play indefinitely until we hit &lt;em&gt;space&lt;/em&gt; again. Hold the Cmd key and double-click the sound file in the track (&lt;em&gt;below&lt;/em&gt; the filename). You will see how the file’s range gets selected (white). Then press &lt;em&gt;R&lt;/em&gt; to toggle Repeat. Press &lt;em&gt;space&lt;/em&gt; again and the tone should just keep on playing until you press it again. Turn the knob in the plugin and hear how you can change the volume!&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/blog/articles/audio-plugins-004-vst-and-au/playback-loop.png&quot;&gt;&lt;img src=&quot;/blog/articles/audio-plugins-004-vst-and-au/playback-loop.png&quot; alt=&quot;Looping in Reaper&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;There will be click sounds while you turn the knob; this is because we’re not interpolating between values and it creates small steps in the waveform. Now hit &lt;em&gt;Stop&lt;/em&gt; in Xcode to quit Reaper.&lt;/p&gt;
&lt;p&gt;Building the AudioUnit version is easy: Just change the target to &lt;em&gt;AU&lt;/em&gt;. Edit the &lt;em&gt;Run&lt;/em&gt; scheme so it starts &lt;em&gt;REAPER64.app&lt;/em&gt; and click &lt;em&gt;Run&lt;/em&gt;. The plugin will be built and put into &lt;em&gt;~/Library/Audio/Plug-Ins/Components&lt;/em&gt;. Reaper will start and you should be able to load the AU version of your plugin just like the VST version.&lt;/p&gt;
&lt;p&gt;The whole process of running, creating a track etc. can get quite repetitive. I’m a big fan of optimizing things you do often. Running and testing your plugin is such a thing. When you have everything set in Reaper (i.e. your plugin is inserted on a track, and the sound is playing repeatedly), hit Cmd+S (Ctrl+S on Windows) to save the project. Save it to your Xcode project’s folder (&lt;em&gt;~/plugin-development/wdl-ol/IPlugExamples/MyFirstPlugin/&lt;/em&gt;) and name it &lt;em&gt;reaper-project.RPP&lt;/em&gt;.  &lt;/p&gt;
&lt;p&gt;In Xcode’s &lt;em&gt;Edit Scheme&lt;/em&gt; screen, select the &lt;em&gt;VST2&lt;/em&gt; scheme at the top. Now go to the &lt;em&gt;Arguments&lt;/em&gt; tab and click the plus button below &lt;em&gt;“Arguments Passed On Launch”&lt;/em&gt;. Drag the &lt;em&gt;reaper-project.RPP&lt;/em&gt; from your project folder to the newly created line:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/blog/articles/audio-plugins-004-vst-and-au/run-reaper-arguments.jpg&quot;&gt;&lt;img src=&quot;/blog/articles/audio-plugins-004-vst-and-au/run-reaper-arguments.jpg&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Repeat this for the AU target. If you want, you can create a separate project for the AU version. From now on everytime you start Reaper it will run with everything in place. Awesome!&lt;/p&gt;
&lt;p&gt;If you want, play around a little with breakpoints and see how you can inspect plugin variables even though it’s not running directly inside Xcode!&lt;/p&gt;
&lt;p&gt;&lt;a name=&quot;windows_debugging_setup&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;debugging-on-windows&quot;&gt;Debugging on Windows&lt;/h2&gt;
&lt;p&gt;Open Explorer and go to &lt;em&gt;C:\Program Files\&lt;/em&gt;. Create a new folder and call it &lt;em&gt;vsthost&lt;/em&gt;. Now &lt;a href=&quot;http://www.hermannseib.com/english/savihost.htm&quot;&gt;download Savihost&lt;/a&gt; (you’ll want the &lt;em&gt;savihostx86.zip&lt;/em&gt;) and unzip it. Copy the &lt;em&gt;savihost.exe&lt;/em&gt; into the folder you just created:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/blog/articles/audio-plugins-004-vst-and-au/savihost_folder.png&quot;&gt;&lt;img src=&quot;/blog/articles/audio-plugins-004-vst-and-au/savihost_folder.png&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Back in Visual C++, right-click the &lt;em&gt;MyFirstPlugin-vst2&lt;/em&gt; project in the project explorer on the left. Select &lt;em&gt;Set as StartUp Project&lt;/em&gt;. Press &lt;em&gt;F5&lt;/em&gt; and it will run your plugin as VST2 in Savihost:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/blog/articles/audio-plugins-004-vst-and-au/savihost.png&quot;&gt;&lt;img src=&quot;/blog/articles/audio-plugins-004-vst-and-au/savihost.png&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;If nothing appears, try clicking the different windows in the Taskbar; it should be there.&lt;br&gt;There’s one more thing to do: With the current configuration, Savihost will try to catch exceptions and prevent your plugin from crashing. This may be nice when we’re using our plugin on stage, but not for debugging purposes. In Visual C++, right-click &lt;em&gt;MyFirstPlugin-vst2&lt;/em&gt; (in the project explorer on the left), and click &lt;em&gt;Properties&lt;/em&gt;. In the following dialog, select &lt;em&gt;Debugging&lt;/em&gt; on the left. On the right, append &lt;code&gt;/noexc /noft&lt;/code&gt; to the parameters (make sure there’s a space between each parameter):&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/blog/articles/audio-plugins-004-vst-and-au/savihost_unsafe.png&quot;&gt;&lt;img src=&quot;/blog/articles/audio-plugins-004-vst-and-au/savihost_unsafe.png&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;This will stop Savihost from catching exceptions, so now they will be passed through the Visual C++ debugger. Thanks to &lt;em&gt;arakula&lt;/em&gt; for this hint!&lt;/p&gt;
&lt;p&gt;If you try to run the VST3 version, you’ll most likely get an error like this (maybe not in German):&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/blog/articles/audio-plugins-004-vst-and-au/no_vst3_host.png&quot;&gt;&lt;img src=&quot;/blog/articles/audio-plugins-004-vst-and-au/no_vst3_host.png&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The &lt;em&gt;VST3PluginTestHost.exe&lt;/em&gt; is part of the VST3 SDK you &lt;a href=&quot;http://www.martin-finke.de/articles/audio-plugins-002-setting-up-wdl-ol/#copy_sdk_files&quot;&gt;downloaded in part 2&lt;/a&gt;. Just create the folder &lt;em&gt;C:\Program Files\Steinberg\VST3PluginTestHost\&lt;/em&gt; and put the &lt;em&gt;VST3PluginTestHost.exe&lt;/em&gt; in there.&lt;/p&gt;
&lt;p&gt;&lt;a name=&quot;warnings&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;inhibit-warnings-for-library-code-mac-&quot;&gt;Inhibit Warnings for Library Code (Mac)&lt;/h2&gt;
&lt;p&gt;This section is about Mac/Xcode. For Windows, please &lt;a href=&quot;http://www.martin-finke.de/articles/audio-plugins-004-vst-and-au/#warnings_windows&quot;&gt;skip to the next section&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;You may have noticed that we get a lot of warnings:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/blog/articles/audio-plugins-004-vst-and-au/warnings.png&quot;&gt;&lt;img src=&quot;/blog/articles/audio-plugins-004-vst-and-au/warnings.png&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Warnings are very valuable for us because they can call our attention to possible bugs and problems with our code. The 22 warnings are from library code, so we can’t just go in there and fix them: If we update the library at some point, we’ll have to do it all over again. Just leaving them there is bad, too: If we get used to seeing the warning sign all the time, we probably won’t notice when the &lt;em&gt;22&lt;/em&gt; turns into a &lt;em&gt;23&lt;/em&gt; because there’s a warning about our own code.&lt;/p&gt;
&lt;p&gt;The best solution in my opinion is to inhibit warnings for library code. So when a warning appears, we know it’s relevant for us. The compiler flag to inhibit warnings is &lt;code&gt;-w&lt;/code&gt;. Click on your project (blue icon) in the navigator, select the &lt;em&gt;APP&lt;/em&gt; target, go to &lt;em&gt;Build Phases&lt;/em&gt; and expand the &lt;em&gt;Compile Sources&lt;/em&gt; section. Mark everything except for &lt;em&gt;MyFirstPlugin.cpp&lt;/em&gt; and double-click a marked row in the &lt;em&gt;Compiler Flags&lt;/em&gt; column. Type &lt;code&gt;-w&lt;/code&gt; and hit &lt;em&gt;enter&lt;/em&gt;:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/blog/articles/audio-plugins-004-vst-and-au/inhibit-warnings.png&quot;&gt;&lt;img src=&quot;/blog/articles/audio-plugins-004-vst-and-au/inhibit-warnings.png&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Repeat this step for the &lt;em&gt;VST2&lt;/em&gt; and &lt;em&gt;AU&lt;/em&gt; targets (and any other targets you want to use). Now try to build again, and you’ll get only three warnings. The warning about &lt;em&gt;Validate Project Settings&lt;/em&gt; is easily fixed: Double-click it, uncheck everything and click &lt;em&gt;Done&lt;/em&gt;:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/blog/articles/audio-plugins-004-vst-and-au/validate-project-settings.jpg&quot;&gt;&lt;img src=&quot;/blog/articles/audio-plugins-004-vst-and-au/validate-project-settings.jpg&quot; alt=&quot;Validate Project Settings&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Now there are only two warnings left:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/blog/articles/audio-plugins-004-vst-and-au/few-warnings.png&quot;&gt;&lt;img src=&quot;/blog/articles/audio-plugins-004-vst-and-au/few-warnings.png&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The warning about &lt;em&gt;InfoPlist.strings&lt;/em&gt; encoding can be fixed by opening the file and setting it to UTF-8 using the &lt;em&gt;Utilities&lt;/em&gt; on the right (click &lt;em&gt;Convert&lt;/em&gt;):&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/blog/articles/audio-plugins-004-vst-and-au/unicode.jpg&quot;&gt;&lt;img src=&quot;/blog/articles/audio-plugins-004-vst-and-au/unicode.jpg&quot; alt=&quot;Setting to UTF-8&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The warning about &lt;em&gt;extra tokens&lt;/em&gt; can be silenced by surrounding the &lt;code&gt;#include&lt;/code&gt; directive in &lt;em&gt;MyFirstPlugin.h&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#pragma clang diagnostic push&lt;/span&gt;
&lt;span class=&quot;preprocessor&quot;&gt;#pragma clang diagnostic ignored &quot;-Wextra-tokens&quot;&lt;/span&gt;
&lt;span class=&quot;preprocessor&quot;&gt;#include &quot;IPlug_include_in_plug_hdr.h&quot;&lt;/span&gt;
&lt;span class=&quot;preprocessor&quot;&gt;#pragma clang diagnostic pop&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now the &lt;em&gt;APP&lt;/em&gt; and &lt;em&gt;AU&lt;/em&gt; targets are without warnings. Building the &lt;em&gt;VST2&lt;/em&gt; target warns you about &lt;em&gt;only one parameter on ‘main’ declaration&lt;/em&gt;. Let’s fix this by by surrounding the &lt;code&gt;#include&lt;/code&gt; directive in &lt;em&gt;MyFirstPlugin.cpp&lt;/em&gt; (&lt;em&gt;not&lt;/em&gt; .h!):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#include &quot;MyFirstPlugin.h&quot;&lt;/span&gt;
&lt;span class=&quot;preprocessor&quot;&gt;#pragma clang diagnostic push&lt;/span&gt;
&lt;span class=&quot;preprocessor&quot;&gt;#pragma clang diagnostic ignored &quot;-Wmain&quot;&lt;/span&gt;
&lt;span class=&quot;preprocessor&quot;&gt;#include &quot;IPlug_include_in_plug_src.h&quot;&lt;/span&gt;
&lt;span class=&quot;preprocessor&quot;&gt;#pragma clang diagnostic pop&lt;/span&gt;
&lt;span class=&quot;preprocessor&quot;&gt;#include &quot;IControl.h&quot;&lt;/span&gt;
&lt;span class=&quot;preprocessor&quot;&gt;#include &quot;resource.h&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Build again and you’ll see that there are no warnings left. Clean! &lt;/p&gt;
&lt;p&gt;&lt;a name=&quot;warnings_windows&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;inhibit-warnings-for-library-code-windows-&quot;&gt;Inhibit Warnings for Library Code (Windows)&lt;/h2&gt;
&lt;p&gt;In general, VS C++ will give different warnings than the GCC/LLVM used on Mac. You can find all VS C++ 2010 warnings on the left side of &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/8x5x43k7(v=vs.100).aspx&quot;&gt;this page&lt;/a&gt;. &lt;/p&gt;
&lt;p&gt;For example, if you get warnings C4101 and C4129 from some &lt;em&gt;.h&lt;/em&gt; file in WDL, you can ignore these: In &lt;em&gt;MyFirstPlugin.h&lt;/em&gt;, put a &lt;code&gt;#pragma&lt;/code&gt; before the &lt;code&gt;#include&lt;/code&gt; line:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#pragma warning( suppress : 4101 4129 )&lt;/span&gt;
&lt;span class=&quot;preprocessor&quot;&gt;#include &quot;IPlug_include_in_plug_hdr.h&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;suppress&lt;/code&gt; means that warnings will only be ignored for the next line (which is the &lt;code&gt;#include&lt;/code&gt;). So it will still warn you about all code after the &lt;code&gt;#include&lt;/code&gt; (which is good). Note that you only write the numbers, without the “C”. You can also do this in &lt;em&gt;MyFirstPlugin.cpp&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#pragma warning( suppress : 4101 4129 )&lt;/span&gt;
&lt;span class=&quot;preprocessor&quot;&gt;#include &quot;IPlug_include_in_plug_src.h&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This covers &lt;em&gt;.h&lt;/em&gt; files from the library.&lt;br&gt;If you get warnings for a certain &lt;em&gt;.cpp&lt;/em&gt; file, find it in the project explorer, right-click it and click “Properties”. In the dialog, select &lt;em&gt;C/C++&lt;/em&gt; → &lt;em&gt;Advanced&lt;/em&gt; on the left. On the right, you should get an option like &lt;em&gt;Disable certain warnings&lt;/em&gt;:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/blog/articles/audio-plugins-004-vst-and-au/disable_warnings_for_cpp_file.png&quot;&gt;&lt;img src=&quot;/blog/articles/audio-plugins-004-vst-and-au/disable_warnings_for_cpp_file.png&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Here, you can input a list of warning numbers, separated by semicolon. As you can see, it’s already ignoring four warnings for this file. Note that changes you make here only affect this particular &lt;em&gt;.cpp&lt;/em&gt; file. So you’ll have to find the right warning numbers for each file and put them here. If you start a new project in the future, make sure you &lt;code&gt;duplicate&lt;/code&gt; it from this one, so you don’t have to do it again.&lt;/p&gt;
&lt;h2 id=&quot;clean-&quot;&gt;Clean!&lt;/h2&gt;
&lt;p&gt;Without globally “blinding” ourselves against useful compiler output, we have made it easier to see warnings that come up in our own code. In the &lt;a href=&quot;http://www.martin-finke.de/articles/audio-plugins-005-digital-distortion/&quot;&gt;next post&lt;/a&gt; we will get our hands dirty and write a nasty digital distortion plugin.&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Making Audio Plugins Part 3: Examining the Code</title>
      <link>http://www.martin-finke.de/blog/articles/audio-plugins-003-examining-the-code/</link>
      <pubDate>Sun, 15 Sep 2013 17:32:00 +0200</pubDate>
      <guid isPermaLink="true">http://www.martin-finke.de/blog/articles/audio-plugins-003-examining-the-code/</guid>
      <author></author>
      <description>&lt;p&gt;Let’s have a closer look at the example project from last time. &lt;span class=&quot;more&quot;&gt;&lt;/span&gt; The most important files are &lt;em&gt;resource.h&lt;/em&gt;, &lt;em&gt;MyFirstPlugin.h&lt;/em&gt; and &lt;em&gt;MyFirstPlugin.cpp&lt;/em&gt;. The plugin is a simple &lt;em&gt;gain&lt;/em&gt; knob – it changes the volume of the audio passing through.&lt;/p&gt;
&lt;h2 id=&quot;constants-flags-and-image-resources&quot;&gt;Constants, Flags and Image Resources&lt;/h2&gt;
&lt;p&gt;Open &lt;em&gt;resource.h&lt;/em&gt; from the project navigator. This file has constants for your plugin such as name, version, unique ID and image resources.&lt;br&gt;In lines 23–26 you can set the unique &lt;em&gt;Plugin ID&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-c&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 4 chars, single quotes. At least one capital letter&lt;/span&gt;
&lt;span class=&quot;preprocessor&quot;&gt;#define PLUG_UNIQUE_ID 'Ipef'&lt;/span&gt;
&lt;span class=&quot;comment&quot;&gt;// make sure this is not the same as BUNDLE_MFR&lt;/span&gt;
&lt;span class=&quot;preprocessor&quot;&gt;#define PLUG_MFR_ID 'Acme'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The ID is important for cataloging plugins. You can register it &lt;a href=&quot;http://service.steinberg.de/databases/plugin.nsf/plugIn?openForm&quot;&gt;here&lt;/a&gt;.&lt;br&gt;Line 56+ defines an ID and image path for the knob you see when you run the App:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-c&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Unique IDs for each image resource.&lt;/span&gt;
&lt;span class=&quot;preprocessor&quot;&gt;#define KNOB_ID 101&lt;/span&gt;

&lt;span class=&quot;comment&quot;&gt;// Image resource locations for this plug.&lt;/span&gt;
&lt;span class=&quot;preprocessor&quot;&gt;#define KNOB_FN &quot;resources/img/knob.png&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the project navigator, open &lt;em&gt;Resources&lt;/em&gt; → &lt;em&gt;img&lt;/em&gt; → &lt;em&gt;knob.png&lt;/em&gt;. It’s a sprite with 60 different knob positions – each of them is 48x48 Pixels. So when you run the app and turn the knob, it doesn’t &lt;em&gt;rotate&lt;/em&gt; the image, but rather shows a certain 48x48 Pixel portion of it.&lt;br&gt;Why not just rotate a single image? Imagine you want your knob graphic to have a glossy look and a drop shadow. If you were to rotate the graphic, the gloss and shadow would also be rotated, which is not how it looks in the real world.&lt;/p&gt;
&lt;p&gt;Further down in &lt;em&gt;resource.h&lt;/em&gt;, you can set the size of your plugin’s window:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-c&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#define GUI_WIDTH 300&lt;/span&gt;
&lt;span class=&quot;preprocessor&quot;&gt;#define GUI_HEIGHT 300&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Try changing the values and run the app.&lt;/p&gt;
&lt;h2 id=&quot;the-plugin-class-interface&quot;&gt;The Plugin Class Interface&lt;/h2&gt;
&lt;p&gt;Open &lt;em&gt;MyFirstPlugin.h&lt;/em&gt;. It just contains the interface for your plugin class. The &lt;code&gt;public&lt;/code&gt; part contains Constructor, Destructor and three member functions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Reset&lt;/code&gt; is called when the &lt;a href=&quot;http://www.dspguide.com/ch3/2.htm&quot;&gt;sample rate&lt;/a&gt; is changed.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;OnParamChange&lt;/code&gt; is called when a plugin parameter changes, for example when you turn the knob.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ProcessDoubleReplacing&lt;/code&gt; is the core of your plugin. In this function you can process incoming audio.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In the &lt;code&gt;private&lt;/code&gt; section there’s just a &lt;code&gt;double&lt;/code&gt; holding the current gain value.&lt;/p&gt;
&lt;h2 id=&quot;the-implementation&quot;&gt;The Implementation&lt;/h2&gt;
&lt;p&gt;Now for the interesting part! Open &lt;em&gt;MyFirstPlugin.cpp&lt;/em&gt;. First of all we can see a nice trick for enums:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;enum&lt;/span&gt; EParams
{
  kGain = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,
  kNumParams
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;By setting the first option to &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;kNumParams&lt;/code&gt; at the end, &lt;code&gt;kNumParams&lt;/code&gt; becomes the number of options (1 in this case).&lt;br&gt;The following &lt;code&gt;enum&lt;/code&gt; uses the constants described in &lt;em&gt;resource.h&lt;/em&gt; and sets the position of the knob in the plugin’s window:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;enum&lt;/span&gt; ELayout
{
  kWidth = GUI_WIDTH,
  kHeight = GUI_HEIGHT,

  kGainX = &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;,
  kGainY = &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;,
  kKnobFrames = &lt;span class=&quot;number&quot;&gt;60&lt;/span&gt;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It also defines the number of frames in &lt;em&gt;knob.png&lt;/em&gt; as 60.&lt;br&gt;Below that, the constructor implementation starts by setting up the plugins’ attributes:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//arguments are: name, defaultVal, minVal, maxVal, step, label&lt;/span&gt;
GetParam(kGain)-&amp;gt;InitDouble(&lt;span class=&quot;string&quot;&gt;&quot;Gain&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;50.&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0.&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;100.0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0.01&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;%&quot;&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can’t see the value and percent sign in the GUI, but the value can be between &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;100&lt;/code&gt;, the default being &lt;code&gt;50&lt;/code&gt;. You may have noticed, though, that the knob isn’t at &lt;em&gt;twelve o’clock&lt;/em&gt;. This is because of the &lt;code&gt;SetShape(2.)&lt;/code&gt; below. Set it to &lt;code&gt;1.0&lt;/code&gt; and the knob will be as you expect. &lt;code&gt;SetShape&lt;/code&gt; gives a knob a non-linear behaviour.&lt;br&gt;Next, the constructor creates a graphic context with the right size and creates the red background:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;IGraphics* pGraphics = MakeGraphics(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, kWidth, kHeight);
pGraphics-&amp;gt;AttachPanelBackground(&amp;amp;COLOR_RED);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It then loads the &lt;em&gt;knob.png&lt;/em&gt;, creates a new &lt;code&gt;IKnobMultiControl&lt;/code&gt; with the image, and attaches it to the GUI. &lt;code&gt;IKnobMultiControl&lt;/code&gt; is the C++ class for the GUI knob. Note how &lt;code&gt;kKnobFrames&lt;/code&gt; is passed to indicate that the sprite contains 60 frames.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;IBitmap knob = pGraphics-&amp;gt;LoadIBitmap(KNOB_ID, KNOB_FN, kKnobFrames);
pGraphics-&amp;gt;AttachControl(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; IKnobMultiControl(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, kGainX, kGainY, kGain, &amp;amp;knob));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Finally, the constructor attaches the graphics context, and it creates a default preset for the plugin:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;MakeDefaultPreset((&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *) &lt;span class=&quot;string&quot;&gt;&quot;-&quot;&lt;/span&gt;, kNumPrograms);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let’s look at &lt;code&gt;OnParamChange&lt;/code&gt; (bottom of the file). The &lt;code&gt;IMutexLock&lt;/code&gt; ensures &lt;a href=&quot;http://en.wikipedia.org/wiki/Thread_safety&quot;&gt;Thread Safety&lt;/a&gt;, a concept we will dive into later. The rest is just a switch to do the right thing depending on which parameter was changed:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; kGain:
    mGain = GetParam(kGain)-&amp;gt;Value() / &lt;span class=&quot;number&quot;&gt;100.&lt;/span&gt;;
    &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Remember, the &lt;code&gt;kGain&lt;/code&gt; parameter has values between 0 and 100. So after dividing by 100, we assign the result (between 0 and 1) to the &lt;code&gt;private&lt;/code&gt; member &lt;code&gt;mGain&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;So far, we have looked at how a GUI is created and how it can be linked to parameters like &lt;code&gt;mGain&lt;/code&gt;. Let’s now look at how the plugin can process incoming audio. In our case, an audio stream is a sequence of &lt;code&gt;double&lt;/code&gt; samples, each containing the amplitude at a given point in time.&lt;br&gt;The first parameter to &lt;code&gt;ProcessDoubleReplacing&lt;/code&gt; is &lt;code&gt;double** inputs&lt;/code&gt;. A sequence of &lt;code&gt;double&lt;/code&gt; values can be passed using &lt;code&gt;double*&lt;/code&gt;. The plugin processes two (stereo) or even more channels at once, so we have several sequences of &lt;code&gt;double&lt;/code&gt; samples, that is, &lt;code&gt;double**&lt;/code&gt;.
The first two lines in the function make it more clear:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt;* in1 = inputs[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;];
&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt;* in2 = inputs[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, &lt;code&gt;in1&lt;/code&gt; points to the first sequence of samples (left channel), &lt;code&gt;in2&lt;/code&gt; to the samples for the right channel. After doing the same for the output buffer, we can iterate over the input and output buffers to process them:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; s = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; s &amp;lt; nFrames; ++s, ++in1, ++in2, ++out1, ++out2)
{
  *out1 = *in1 * mGain;
  *out2 = *in2 * mGain;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For every sample, we take the input value, multiply it by &lt;code&gt;mGain&lt;/code&gt; and write it to the output buffer. &lt;code&gt;nFrames&lt;/code&gt; tells us how many samples there are per channel so we know how long the buffers are.&lt;/p&gt;
&lt;p&gt;You may have noticed that when you run the app, you can hear yourself through your computer speakers. This is because by default, the standalone app takes your computer’s microphone as input. To change this (and some other audio preferences), go to the app’s preferences:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/blog/articles/audio-plugins-003-examining-the-code/preferences-menu.jpg&quot;&gt;&lt;img src=&quot;/blog/articles/audio-plugins-003-examining-the-code/preferences-menu.jpg&quot; alt=&quot;App Preferences Menu&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/blog/articles/audio-plugins-003-examining-the-code/preferences-window.jpg&quot;&gt;&lt;img src=&quot;/blog/articles/audio-plugins-003-examining-the-code/preferences-window.jpg&quot; alt=&quot;App Preferences Window&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Set a breakpoint in the &lt;code&gt;Reset&lt;/code&gt; function. Change the &lt;em&gt;Sampling Rate&lt;/em&gt; on the right and click &lt;em&gt;Apply&lt;/em&gt;. The debugger will break inside &lt;code&gt;Reset&lt;/code&gt;. In the lower right where &lt;code&gt;lldb&lt;/code&gt; is running, enter &lt;code&gt;print GetSampleRate()&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/blog/articles/audio-plugins-003-examining-the-code/debugger-output.jpg&quot;&gt;&lt;img src=&quot;/blog/articles/audio-plugins-003-examining-the-code/debugger-output.jpg&quot; alt=&quot;Debugger Output&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Notice how you can call any function from the debugger and it will show the correct return value. Press &lt;em&gt;Stop&lt;/em&gt; in the upper left corner when you’re ready to move on.&lt;br&gt;Now it’s time to actually create plugin versions of our app and load them into a host. We’ll cover that in the &lt;a href=&quot;http://www.martin-finke.de/articles/audio-plugins-004-vst-and-au/&quot;&gt;next post&lt;/a&gt;!&lt;/p&gt;
&lt;h2 id=&quot;further-reading&quot;&gt;Further Reading&lt;/h2&gt;
&lt;p&gt;To fill some gaps, read &lt;a href=&quot;http://olilarkin.blogspot.de/2012/01/m4u-convention-iplug-workshop-slides.html&quot;&gt;these slides&lt;/a&gt; by the ingenius Mr. Oli Larkin. They explain a lot of things about &lt;em&gt;WDL-OL&lt;/em&gt;.&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Making Audio Plugins Part 2: Setting up WDL-OL</title>
      <link>http://www.martin-finke.de/blog/articles/audio-plugins-002-setting-up-wdl-ol/</link>
      <pubDate>Sun, 15 Sep 2013 17:31:00 +0200</pubDate>
      <guid isPermaLink="true">http://www.martin-finke.de/blog/articles/audio-plugins-002-setting-up-wdl-ol/</guid>
      <author></author>
      <description>&lt;p&gt;In this post we’ll install the WDL-OL library and its dependencies. We will then run one of the demo projects to make sure everything’s working fine.&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;more&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Most of this is also covered in the videos by Oli Larkin:&lt;/p&gt;
&lt;div class=&quot;youtube-video&quot;&gt;&lt;iframe width=&quot;100%&quot; height=&quot;100%&quot; src=&quot;//www.youtube.com/embed/POP_z0dAn9c?rel=0&quot; frameborder=&quot;0&quot; allowfullscreen&gt;&lt;/iframe&gt;&lt;/div&gt;
&lt;div class=&quot;youtube-video&quot;&gt;&lt;iframe width=&quot;100%&quot; height=&quot;100%&quot; src=&quot;//www.youtube.com/embed/uWitp7EOWVA?rel=0&quot; frameborder=&quot;0&quot; allowfullscreen&gt;&lt;/iframe&gt;&lt;br/&gt;&lt;/div&gt;

&lt;p&gt;The following section is Mac-specific. The guide for Windows is &lt;a href=&quot;http://www.martin-finke.de/articles/audio-plugins-002-setting-up-wdl-ol/#windows_setup&quot;&gt;below&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;setup-on-mac-os-x-using-xcode-4&quot;&gt;Setup on Mac OS X using Xcode 4&lt;/h2&gt;
&lt;p&gt;Before we can get started, we have to download and install a few things. This part is a little laborious, but you only have to do it once.&lt;/p&gt;
&lt;p&gt;&lt;a name=&quot;prerequisites&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;prerequisites&quot;&gt;Prerequisites&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;If you don’t have Xcode installed, &lt;a href=&quot;https://developer.apple.com/xcode/&quot;&gt;download&lt;/a&gt; and install it.&lt;/li&gt;
&lt;li&gt;Download the &lt;a href=&quot;http://www.steinberg.net/en/company/developer.html&quot;&gt;VST3 SDK&lt;/a&gt;. You will have to register for an account first.&lt;/li&gt;
&lt;li&gt;Download the &lt;em&gt;Audio Tools for Xcode&lt;/em&gt;. In Xcode’s application menu, click &lt;em&gt;Open Developer Tool&lt;/em&gt; → &lt;em&gt;More Developer Tools…&lt;/em&gt; (or click &lt;a href=&quot;https://developer.apple.com/downloads/index.action?name=for%20Xcode%20-&quot;&gt;here&lt;/a&gt;). Find &lt;em&gt;Audio Tools for Xcode&lt;/em&gt; in the list, download and install it. There’s a different version for different OS X versions, make sure you get the right one.&lt;/li&gt;
&lt;li&gt;Download &lt;a href=&quot;http://www.music.mcgill.ca/~gary/rtaudio/&quot;&gt;RtAudio&lt;/a&gt; (includes the ASIO SDK files we need).&lt;/li&gt;
&lt;li&gt;If you don’t have &lt;em&gt;git&lt;/em&gt;, make sure you &lt;a href=&quot;http://git-scm.com/downloads&quot;&gt;install it&lt;/a&gt; first. It’s worth it!&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;downloading-wdl-ol&quot;&gt;Downloading WDL-OL&lt;/h3&gt;
&lt;p&gt;Now open a &lt;a href=&quot;http://smokingapples.com/software/tutorials/mac-terminal-tips/&quot;&gt;Terminal&lt;/a&gt;. Type the following lines to create a new folder inside your home directory and go into it:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mkdir ~/plugin-development
cd !$
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Let’s get WDL-OL:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git clone https://github.com/olilarkin/wdl-ol
cd wdl-ol
git checkout 0a360c90b3460717210eeaee7464bc7009c9a5ba .
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;You may want to copy &amp;amp; paste the last line. Don’t forget the dot at the end! It ensures that you’re using the same version of WDL‑OL that’s used for these tutorials.
You should have a new subfolder called &lt;em&gt;wdl-ol&lt;/em&gt;.&lt;br&gt;&lt;a name=&quot;copy_sdk_files&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;adding-the-dependencies&quot;&gt;Adding the Dependencies&lt;/h3&gt;
&lt;p&gt;Go into &lt;em&gt;ASIO_SDK&lt;/em&gt; and copy the .cpp/.h files from RtAudio’s &lt;em&gt;include&lt;/em&gt; folder here. Unzip the VST3 SDK, and copy the files &lt;em&gt;aeffect.h&lt;/em&gt; and &lt;em&gt;aeffectx.h&lt;/em&gt; from the folder &lt;em&gt;pluginterfaces&lt;/em&gt; → &lt;em&gt;vst2.x&lt;/em&gt; into WDL-OL’s &lt;em&gt;VST_SDK&lt;/em&gt; subfolder.
Apart from that, You only need the &lt;em&gt;base/source&lt;/em&gt;, &lt;em&gt;pluginterfaces&lt;/em&gt; and &lt;em&gt;public.sdk/source&lt;/em&gt; folders for VST3. Copy them like this:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/blog/articles/audio-plugins-002-setting-up-wdl-ol/vst3copy.png&quot;&gt;&lt;img src=&quot;/blog/articles/audio-plugins-002-setting-up-wdl-ol/vst3copy.png&quot; alt=&quot;How to copy VST3 SDK files&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Note that you’ll have to create the &lt;em&gt;public.sdk&lt;/em&gt; folder by hand. This is what your folder structure should look like:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/blog/articles/audio-plugins-002-setting-up-wdl-ol/folderstructure.png&quot;&gt;&lt;img src=&quot;folderstructure.png&quot; alt=&quot;Folder structure for WDL-OL&quot; style=&quot;width: auto; margin-left: auto; margin-right: auto;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Now open &lt;em&gt;common.xcconfig&lt;/em&gt; (it should open in Xcode) and make the following changes:&lt;/p&gt;
&lt;p&gt;&lt;a name=&quot;deployment_target&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-objectivec&quot;&gt;CERTIFICATE_ID = Your Name

&lt;span class=&quot;comment&quot;&gt;// Comment this line out:&lt;/span&gt;
&lt;span class=&quot;comment&quot;&gt;// COMPILER = com.apple.compilers.gcc.4_2&lt;/span&gt;
&lt;span class=&quot;comment&quot;&gt;// Uncomment this line:&lt;/span&gt;
COMPILER = com&lt;span class=&quot;variable&quot;&gt;.apple&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.compilers&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.llvm&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.clang&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;.1&lt;/span&gt;_0

&lt;span class=&quot;comment&quot;&gt;// Add these lines:&lt;/span&gt;
VST_FOLDER = ~/Library/Audio/Plug-Ins/VST
VST3_FOLDER = ~/Library/Audio/Plug-Ins/VST3
AU_FOLDER = ~/Library/Audio/Plug-Ins/Components
&lt;span class=&quot;comment&quot;&gt;// Comment these out:&lt;/span&gt;
&lt;span class=&quot;comment&quot;&gt;//VST_FOLDER = /Library/Audio/Plug-Ins/VST&lt;/span&gt;
&lt;span class=&quot;comment&quot;&gt;//VST3_FOLDER = /Library/Audio/Plug-Ins/VST3&lt;/span&gt;
&lt;span class=&quot;comment&quot;&gt;//AU_FOLDER = /Library/Audio/Plug-Ins/Components&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can also see that we’re going to use Mac OS X 10.5 as both &lt;code&gt;BASE_SDK&lt;/code&gt; and &lt;code&gt;MACOSX_DEPLOYMENT_TARGET&lt;/code&gt;. Music producers and especially recording studios are often &lt;em&gt;very&lt;/em&gt; lazy about updating their operating system: They don’t need any new features, but having the studio disfunctional for a few days due to updating problems could cause big losses.&lt;br&gt;Actually, the &lt;em&gt;deployment target&lt;/em&gt; is the version your users will need, but I prefer to set the base SDK to the same version as well.&lt;br&gt;The 10.5 SDK isn’t included with Xcode 4. If you already have it installed, skip to &lt;a href=&quot;http://www.martin-finke.de/articles/audio-plugins-002-setting-up-wdl-ol/#duplicating_example_project&quot;&gt;Running the Example Project&lt;/a&gt;. If you don’t have it, read on:&lt;/p&gt;
&lt;h3 id=&quot;installing-the-10-5-sdk&quot;&gt;Installing the 10.5 SDK&lt;/h3&gt;
&lt;p&gt;To get the 10.5 SDK, you need to &lt;a href=&quot;https://developer.apple.com/downloads/index.action?searchTextField=3.2.6&quot;&gt;download Xcode 3.2.6&lt;/a&gt;. Once you have it downloaded, mount the &lt;em&gt;.dmg&lt;/em&gt; file, open Terminal.app and enter:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;open /Volumes/Xcode\ and\ iOS\ SDK/Packages/
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;A Finder window will open and there will be a file called &lt;em&gt;MacOSX10.5.pkg&lt;/em&gt;. Double-click it. If you’re using OS X 10.8 or later, it’ll show a message saying that it can’t install software from an unidentified developer. In that case, right-click the file, choose &lt;em&gt;Open&lt;/em&gt; in the menu, and confirm that you really want to install the software. When installing, choose &lt;em&gt;change install location&lt;/em&gt; and option-click on the drive you want to install to, so that you can specify a folder. Install it to the &lt;em&gt;Downloads&lt;/em&gt; folder inside your user folder, for example.&lt;br&gt;After that’s done, you’ll have a new folder called &lt;em&gt;MacOSX10.5.sdk&lt;/em&gt; in the location you selected. In Terminal.app, type:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;open /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Again, a Finder window will open. Drag the &lt;em&gt;MacOSX10.5.sdk&lt;/em&gt; folder in there. After restarting Xcode, you should now have the old SDK available in Xcode 4. Make sure you keep the &lt;em&gt;MacOSX10.5.pkg&lt;/em&gt; around somewhere: If you update Xcode to a newer version, you’ll probably have to do this step again.&lt;br&gt;If you have any problems installing the 10.5 SDK, please leave a comment and I’ll be happy to help.&lt;/p&gt;
&lt;p&gt;&lt;a name=&quot;duplicating_example_project&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;running-the-example-project&quot;&gt;Running the Example Project&lt;/h3&gt;
&lt;p&gt;Back in your terminal, go to the examples folder:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cd IPlugExamples
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;a name=&quot;duplicate_script&quot;&gt;&lt;/a&gt;
Run the &lt;em&gt;duplicate&lt;/em&gt; script to create your first plugin (replace YourName with your name):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;./duplicate.py IPlugEffect/ MyFirstPlugin YourName
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;You will notice that there’s a new folder &lt;em&gt;MyFirstPlugin&lt;/em&gt;. Go into it and open &lt;em&gt;MyFirstPlugin.xcodeproj&lt;/em&gt;. Select the &lt;em&gt;APP&lt;/em&gt; Target:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/blog/articles/audio-plugins-002-setting-up-wdl-ol/target.png&quot;&gt;&lt;img src=&quot;/blog/articles/audio-plugins-002-setting-up-wdl-ol/target.png&quot; alt=&quot;Selecting the APP Target&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name=&quot;standalone_no_sound_fix&quot;&gt;&lt;/a&gt;
Now there’s a small bug in WDL-OL where the standalone app doesn’t output any sound unless you choose a different audio input. Fortunately that’s easy to fix: In Xcode’s project navigator, open &lt;em&gt;Other Sources&lt;/em&gt; → &lt;em&gt;OSX App Wrapper&lt;/em&gt; → &lt;em&gt;app_main.h&lt;/em&gt;. Change line 34 (the one with &lt;code&gt;#define DEFAULT_INPUT_DEV&lt;/code&gt;) to this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#define DEFAULT_INPUT_DEV &quot;Built-in Microphone&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Click &lt;em&gt;Run&lt;/em&gt;. You will get a few linker errors:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/blog/articles/audio-plugins-002-setting-up-wdl-ol/linker-error.png&quot;&gt;&lt;img src=&quot;/blog/articles/audio-plugins-002-setting-up-wdl-ol/linker-error.png&quot; alt=&quot;Linker errors&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;These are easy to fix. Go to your project’s build setting (make sure you select your project, not a specific target) and set the value for &lt;em&gt;Implicitly Link Objective-C Runtime Support&lt;/em&gt; to &lt;em&gt;No&lt;/em&gt;:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/blog/articles/audio-plugins-002-setting-up-wdl-ol/implicitly-link.png&quot;&gt;&lt;img src=&quot;/blog/articles/audio-plugins-002-setting-up-wdl-ol/implicitly-link.png&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name=&quot;run_first_plugin&quot;&gt;&lt;/a&gt;
Click &lt;em&gt;Run&lt;/em&gt; again. After a few seconds, you should see your first plugin run as a standalone app:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/blog/articles/audio-plugins-002-setting-up-wdl-ol/first-plugin.jpg&quot;&gt;&lt;img src=&quot;/blog/articles/audio-plugins-002-setting-up-wdl-ol/first-plugin.jpg&quot; alt=&quot;Screenshot of first plugin running&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;validating-the-audiounit-version-without-logic&quot;&gt;Validating the AudioUnit version without Logic&lt;/h3&gt;
&lt;p&gt;If you don’t own Logic, you can use Apple’s free &lt;code&gt;auval&lt;/code&gt; tool to check whether your plugin’s AU version is working correctly. Make sure you’ve successfully built the &lt;em&gt;AU&lt;/em&gt; target, open a Terminal and enter:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-bash&quot;&gt;auval &lt;span class=&quot;operator&quot;&gt;-a&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&amp;gt; /dev/null | grep MyFirstPlugin
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It should output a line similar to this one:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-bash&quot;&gt;aumu Abcd Efgh  -  YourName: MyFirstPlugin
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If it doesn’t give any output, try &lt;a href=&quot;http://www.martin-finke.de/articles/audio-plugins-002-setting-up-wdl-ol/#logic_doesnt_find_au&quot;&gt;this&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a name=&quot;logic_doesnt_find_au&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;troubleshooting&quot;&gt;Troubleshooting&lt;/h3&gt;
&lt;p&gt;If &lt;strong&gt;Logic (or &lt;code&gt;auval&lt;/code&gt;) doesn’t find the AU version&lt;/strong&gt; (and other hosts like REAPER see it): Go into the Build Settings, and make sure that the &lt;em&gt;AU&lt;/em&gt; target is selected in the upper left. Search for “active arch”, and the list should only show one entry: &lt;em&gt;Build Active Architecture Only&lt;/em&gt;, which has the value: &lt;em&gt;&amp;lt;Multiple&amp;nbsp;Values&amp;gt;&lt;/em&gt;. Change that to &lt;em&gt;No&lt;/em&gt;. This way, 32- and 64-Bit will be compiled even in Debug mode. After that, run &lt;em&gt;Product&lt;/em&gt; → &lt;em&gt;Clean&lt;/em&gt; (Cmd+Shift+K), build again and it should work.&lt;/p&gt;
&lt;p&gt;&lt;a name=&quot;windows_setup&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;setup-on-windows-using-visual-c-2010-express&quot;&gt;Setup on Windows using Visual C++ 2010 Express&lt;/h2&gt;
&lt;p&gt;First, install &lt;a href=&quot;http://www.microsoft.com/visualstudio/eng/downloads#d-2010-express&quot;&gt;Visual C++ 2010 Express&lt;/a&gt;. Visual Studio 2012 has been reported to work, but I can’t test it on my system. After that, install &lt;a href=&quot;http://git-scm.com/download/win&quot;&gt;Git for Windows&lt;/a&gt;, using the default settings. I used version 1.8.4. Run &lt;em&gt;Start&lt;/em&gt; → &lt;em&gt;Program Files&lt;/em&gt; → &lt;em&gt;Git&lt;/em&gt; → &lt;em&gt;Git Bash&lt;/em&gt;. A terminal window will open. In that window, run the following commands:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cd c:
git clone https://github.com/olilarkin/wdl-ol
cd wdl-ol
git checkout 0a360c90b3460717210eeaee7464bc7009c9a5ba .
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;To paste into the window, right-click the title bar and chosse &lt;em&gt;Edit&lt;/em&gt; → &lt;em&gt;Paste&lt;/em&gt;:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/blog/articles/audio-plugins-002-setting-up-wdl-ol/mingw_paste.png&quot;&gt;&lt;img src=&quot;/blog/articles/audio-plugins-002-setting-up-wdl-ol/mingw_paste.png&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Now copy all the VST2/VST3/ASIO SDK files into the right folders, as &lt;a href=&quot;http://www.martin-finke.de/articles/audio-plugins-002-setting-up-wdl-ol/#copy_sdk_files&quot;&gt;described above&lt;/a&gt;. Install &lt;a href=&quot;http://www.python.org/getit/&quot;&gt;Python&lt;/a&gt; using the default settings. I used version 2.7.5.&lt;/p&gt;
&lt;p&gt;To be able to build VST3 plugins, we have to create the VST3 folder. Run this command in the terminal:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-bash&quot;&gt;mkdir -p &lt;span class=&quot;string&quot;&gt;&quot;C:\Program Files\Common Files\VST3&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now (in the terminal), navigate to the &lt;em&gt;IPlugExamples&lt;/em&gt; subfolder:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cd IPlugExamples/
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Run the &lt;em&gt;duplicate&lt;/em&gt; script using the Python you just installed:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/c/Python27/python.exe duplicate.py IPlugEffect MyFirstPlugin YourName
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;You’ll get a new folder &lt;em&gt;MyFirstPlugin&lt;/em&gt;. Go into it and open &lt;em&gt;MyFirstPlugin.sln&lt;/em&gt;. Ignore the warning, it just means that you can’t compile AAX and TDM formats. In the project explorer on the left, make sure &lt;em&gt;MyFirstPlugin-app&lt;/em&gt; is shown bold:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/blog/articles/audio-plugins-002-setting-up-wdl-ol/project_explorer.png&quot;&gt;&lt;img src=&quot;/blog/articles/audio-plugins-002-setting-up-wdl-ol/project_explorer.png&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;If it isn’t, right-click it and choose &lt;em&gt;Set as StartUp Project&lt;/em&gt;. Now press the &lt;em&gt;F5&lt;/em&gt; key, and you should see a window like this:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/blog/articles/audio-plugins-002-setting-up-wdl-ol/run_app.png&quot;&gt;&lt;img src=&quot;/blog/articles/audio-plugins-002-setting-up-wdl-ol/run_app.png&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Lovely, right?&lt;/p&gt;
&lt;h3 id=&quot;troubleshooting&quot;&gt;Troubleshooting&lt;/h3&gt;
&lt;p&gt;&lt;a name=&quot;error_lnk1123&quot;&gt;&lt;/a&gt;
If you get a &lt;strong&gt;fatal error LNK1123&lt;/strong&gt; when building, you may have to disable &lt;em&gt;incremental linking&lt;/em&gt;: Right-click the &lt;em&gt;MyFirstPlugin-app&lt;/em&gt; project, click &lt;em&gt;Properties&lt;/em&gt; and go to &lt;em&gt;Configuration Properties&lt;/em&gt; → &lt;em&gt;Linker (General)&lt;/em&gt; → &lt;em&gt;Enable Incremental Linking&lt;/em&gt; → &lt;em&gt;“No (/INCREMENTAL:NO)”&lt;/em&gt;.&lt;br&gt;If that doesn’t solve it, try installing &lt;a href=&quot;http://www.microsoft.com/en-us/download/details.aspx?id=23691&quot;&gt;Visual Studio 2010 SP1&lt;/a&gt;. You may also want the &lt;a href=&quot;http://www.microsoft.com/en-us/download/details.aspx?id=4422&quot;&gt;Compiler Update&lt;/a&gt; to get 64-Bit support.&lt;/p&gt;
&lt;p&gt;If you get warnings that &lt;strong&gt;CreatePackage.bat […] exited with code 1&lt;/strong&gt;, don’t worry about it (unless you want to build an AAX plugin). The warning just means that the AAX SDK isn’t there.&lt;/p&gt;
&lt;p&gt;The warning &lt;strong&gt;Cannot open include file: ‘ForcedInclude.h’: No such file or directory&lt;/strong&gt; means that the RTAS SDK wasn’t found. If you’re not trying to build RTAS, you can ignore this.&lt;/p&gt;
&lt;p&gt;If you have any other problems, feel free to leave a comment! &lt;a href=&quot;http://www.martin-finke.de/articles/audio-plugins-003-examining-the-code/&quot;&gt;Next time&lt;/a&gt; we’ll examine the code.&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Making Audio Plugins Part 1: Introduction</title>
      <link>http://www.martin-finke.de/blog/articles/audio-plugins-001-introduction/</link>
      <pubDate>Sun, 15 Sep 2013 17:30:00 +0200</pubDate>
      <guid isPermaLink="true">http://www.martin-finke.de/blog/articles/audio-plugins-001-introduction/</guid>
      <author></author>
      <description>&lt;p&gt;Welcome! In this tutorial series we will be learning how to create audio plugins that run as &lt;a href=&quot;http://en.wikipedia.org/wiki/Virtual_Studio_Technology&quot;&gt;VST&lt;/a&gt;, &lt;a href=&quot;http://www.steinberg.net/en/company/technologies/vst3.html&quot;&gt;VST3&lt;/a&gt;, &lt;a href=&quot;http://en.wikipedia.org/wiki/Audio_Units&quot;&gt;AU&lt;/a&gt;, &lt;a href=&quot;http://en.wikipedia.org/wiki/Real_Time_AudioSuite&quot;&gt;RTAS&lt;/a&gt;, &lt;a href=&quot;http://www.protoolerblog.com/2011/10/20/aax-a-new-plugin-format/&quot;&gt;AAX&lt;/a&gt; or as a standalone application.&lt;br&gt;&lt;span class=&quot;more&quot;&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Audio plugins are programs that are loaded into a &lt;em&gt;host&lt;/em&gt; software (such as &lt;a href=&quot;http://www.ableton.com/live&quot;&gt;Ableton Live&lt;/a&gt;, &lt;a href=&quot;http://www.apple.com/logic-pro/&quot;&gt;Logic&lt;/a&gt; or &lt;a href=&quot;http://http://reaper.fm&quot;&gt;REAPER&lt;/a&gt;). They process Audio and/or MIDI data and can have a graphical user interface. Here are three examples (&lt;a href=&quot;http://www.u-he.com/cms/zebra&quot;&gt;U-He Zebra&lt;/a&gt;, &lt;a href=&quot;http://www.sonalksis.com/freeg.htm&quot;&gt;Sonalksis FreeG&lt;/a&gt; and &lt;a href=&quot;http://www.d16.pl/index.php?menu=203&quot;&gt;D16 Decimort&lt;/a&gt;):&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/blog/articles/audio-plugins-001-introduction/plugins.jpg&quot;&gt;&lt;img src=&quot;/blog/articles/audio-plugins-001-introduction/plugins.jpg&quot; alt=&quot;Some plugin windows&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;As you can see, the GUI usually contains some &lt;strong&gt;controls&lt;/strong&gt; (the &lt;em&gt;knob&lt;/em&gt; being the most common) that change how the plugin &lt;strong&gt;processes incoming data&lt;/strong&gt;. A plugin has &lt;strong&gt;presets&lt;/strong&gt; (in the screenshot they’re called &lt;em&gt;Combo&lt;/em&gt; and &lt;em&gt;Emulator&lt;/em&gt;) that store all knob positions and other values.&lt;/p&gt;
&lt;p&gt;We’ll start with a simple distortion plugin. After that, we’ll create this subtractive synthesizer plugin step by step:&lt;/p&gt;
&lt;div class=&quot;youtube-video&quot;&gt;&lt;iframe width=&quot;100%&quot; height=&quot;100%&quot; src=&quot;//www.youtube.com/embed/8cjuburLVgc?rel=0&quot; frameborder=&quot;0&quot; allowfullscreen&gt;&lt;/iframe&gt;&lt;/div&gt;

&lt;p&gt;We will use C++ and the &lt;a href=&quot;https://github.com/olilarkin/wdl-ol&quot;&gt;WDL-OL&lt;/a&gt; library. It is based on &lt;a href=&quot;http://www.cockos.com/wdl/&quot;&gt;Cockos WDL&lt;/a&gt; (pronounced &lt;em&gt;whittle&lt;/em&gt;). It basically does a lot of work for us, most importantly:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Ready-made Xcode / Visual Studio Projects&lt;/li&gt;
&lt;li&gt;Create VST, AudioUnit, VST3 and RTAS formats from one codebase: Just choose the plugin format and click &lt;em&gt;run&lt;/em&gt;!&lt;/li&gt;
&lt;li&gt;Create 32/64-Bit executables&lt;/li&gt;
&lt;li&gt;Make your plugin run as a standalone Win/Mac application&lt;/li&gt;
&lt;li&gt;Most GUI controls used in audio plugins&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;It also gives you most GUI controls used in audio plugins, and some commonly used audio algorithms like for example resampling. &lt;a href=&quot;http://forum.cockos.com/showthread.php?t=122276&quot;&gt;This forum thread&lt;/a&gt; has screenshots of a lot of plugins that were done using WDL.&lt;/p&gt;
&lt;p&gt;The different plugin formats all do &lt;em&gt;more or less&lt;/em&gt; the same, so normally there would be a lot of copy &amp;amp; paste in your code. As a programmer you want to stay &lt;a href=&quot;http://en.wikipedia.org/wiki/Don&amp;#39;t_repeat_yourself&quot;&gt;DRY&lt;/a&gt;, so sooner or later you’d write an abstraction layer over the different formats. This work has already been done in the form of &lt;em&gt;IPlug&lt;/em&gt;, which is a part of WDL. These are the annoying parts of audio plugin development, so we can now focus on the fun stuff, such as:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;How the plugin processes incoming Audio/MIDI&lt;/li&gt;
&lt;li&gt;What the plugin looks like&lt;/li&gt;
&lt;li&gt;How it integrates with the host (automation, presets, etc.)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Another good thing about WDL is its permissive license: You can use it freely for commercial applications. See the links above for details.&lt;/p&gt;
&lt;h2 id=&quot;how-we-will-do-this&quot;&gt;How we will do this&lt;/h2&gt;
&lt;p&gt;&lt;blockquote&gt;&lt;q cite=&quot;http://www.azlyrics.com/lyrics/scooter/howmuchisthefish.html&quot;&gt;The chase is better than the catch.&lt;/q&gt;&lt;footer&gt;Hans Peter Geerdes&lt;/footer&gt;&lt;/blockquote&gt;
In programming, the result is rewarding, but the journey is where we learn. In this tutorial series, I won’t just give you long code listings with the perfect solution. We will start with something that &lt;em&gt;works&lt;/em&gt; and improve it as soon as we face problems.&lt;br&gt;The disadvantage is that you will write code that you’ll later replace with something better. As a programmer, you’re probably used to that.
The first advantage: It won’t be as overwhelming because we will approach the solution step by step instead of just jumping there. The second advantage is that we might learn valueable programming lessons along the way.&lt;/p&gt;
&lt;p&gt;This series isn’t about calculating complex math by hand. It’s about creating awesome software that you can give to your music producer friends so they can make a fatter bassline.&lt;/p&gt;
&lt;h2 id=&quot;what-you-will-need&quot;&gt;What you will need&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;A Mac running Xcode 4 or later &lt;em&gt;or&lt;/em&gt; a Windows system with Visual C++ 2010 or later. I’ll use a Mac, but you can use almost all information on Windows as well.&lt;/li&gt;
&lt;li&gt;Some understanding of C++ (Syntax, Pointers, Basic OOP, Memory). You may have heard that C++ is very hard, but we’re not going to use too much of the advanced stuff.&lt;/li&gt;
&lt;li&gt;Some knowledge about (digital) audio in general: What &lt;a href=&quot;http://en.wikipedia.org/wiki/Amplitude&quot;&gt;&lt;em&gt;amplitude&lt;/em&gt;&lt;/a&gt; and &lt;a href=&quot;http://en.wikipedia.org/wiki/Audio_frequency&quot;&gt;&lt;em&gt;frequency&lt;/em&gt;&lt;/a&gt; means, what a &lt;a href=&quot;http://en.wikipedia.org/wiki/Audio_filter&quot;&gt;&lt;em&gt;filter&lt;/em&gt;&lt;/a&gt; does, how audio is stored at a &lt;a href=&quot;http://en.wikipedia.org/wiki/Sampling_rate&quot;&gt;&lt;em&gt;sample rate&lt;/em&gt;&lt;/a&gt; and &lt;a href=&quot;http://en.wikipedia.org/wiki/Audio_bit_depth&quot;&gt;&lt;em&gt;bit depth&lt;/em&gt;&lt;/a&gt;. If you’ve recorded or produced music before, you are probably well set.&lt;/li&gt;
&lt;li&gt;Interest for &lt;em&gt;Digital Signal Processing&lt;/em&gt; and &lt;em&gt;GUI Programming&lt;/em&gt;: Those will be the two main topics of this series. If you have no prior DSP knowledge at all, you may have to read up on a few topics at some point. I’ll try to provide &lt;em&gt;further reading&lt;/em&gt; type links whenever that’s the case.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;helpful-resources&quot;&gt;Helpful resources&lt;/h2&gt;
&lt;p&gt;Here are a few links that may be helpful later:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://http://stackoverflow.com/&quot;&gt;Stack Overflow&lt;/a&gt;: Search for things like obscure compiler warnings and find out what they mean.&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.dspguide.com/pdfbook.htm&quot;&gt;DSP Guide&lt;/a&gt;: Very good free book, covers probably more than we’ll use. Refer to it if somewhere on the way you don’t understand a DSP concept.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Sounds exciting? &lt;a href=&quot;http://www.martin-finke.de/articles/audio-plugins-002-setting-up-wdl-ol/&quot;&gt;Next time&lt;/a&gt; we’ll set up everything we need to get started!&lt;/p&gt;
</description>
    </item>
  </channel>
</rss>